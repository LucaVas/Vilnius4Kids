"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// ../node_modules/moo/moo.js
var require_moo = __commonJS({
  "../node_modules/moo/moo.js"(exports, module2) {
    "use strict";
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.moo = factory();
      }
    })(exports, function() {
      "use strict";
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var toString5 = Object.prototype.toString;
      var hasSticky = typeof new RegExp().sticky === "boolean";
      function isRegExp2(o) {
        return o && toString5.call(o) === "[object RegExp]";
      }
      function isObject(o) {
        return o && typeof o === "object" && !isRegExp2(o) && !Array.isArray(o);
      }
      function reEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      function reGroups(s) {
        var re = new RegExp("|" + s);
        return re.exec("").length - 1;
      }
      function reCapture(s) {
        return "(" + s + ")";
      }
      function reUnion(regexps) {
        if (!regexps.length)
          return "(?!)";
        var source = regexps.map(function(s) {
          return "(?:" + s + ")";
        }).join("|");
        return "(?:" + source + ")";
      }
      function regexpOrLiteral(obj) {
        if (typeof obj === "string") {
          return "(?:" + reEscape(obj) + ")";
        } else if (isRegExp2(obj)) {
          if (obj.ignoreCase)
            throw new Error("RegExp /i flag not allowed");
          if (obj.global)
            throw new Error("RegExp /g flag is implied");
          if (obj.sticky)
            throw new Error("RegExp /y flag is implied");
          if (obj.multiline)
            throw new Error("RegExp /m flag is implied");
          return obj.source;
        } else {
          throw new Error("Not a pattern: " + obj);
        }
      }
      function pad(s, length) {
        if (s.length > length) {
          return s;
        }
        return Array(length - s.length + 1).join(" ") + s;
      }
      function lastNLines(string2, numLines) {
        var position = string2.length;
        var lineBreaks = 0;
        while (true) {
          var idx = string2.lastIndexOf("\n", position - 1);
          if (idx === -1) {
            break;
          } else {
            lineBreaks++;
          }
          position = idx;
          if (lineBreaks === numLines) {
            break;
          }
          if (position === 0) {
            break;
          }
        }
        var startPosition = lineBreaks < numLines ? 0 : position + 1;
        return string2.substring(startPosition).split("\n");
      }
      function objectToRules(object) {
        var keys2 = Object.getOwnPropertyNames(object);
        var result = [];
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          var thing = object[key];
          var rules = [].concat(thing);
          if (key === "include") {
            for (var j = 0; j < rules.length; j++) {
              result.push({ include: rules[j] });
            }
            continue;
          }
          var match = [];
          rules.forEach(function(rule) {
            if (isObject(rule)) {
              if (match.length)
                result.push(ruleOptions(key, match));
              result.push(ruleOptions(key, rule));
              match = [];
            } else {
              match.push(rule);
            }
          });
          if (match.length)
            result.push(ruleOptions(key, match));
        }
        return result;
      }
      function arrayToRules(array) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
          var obj = array[i];
          if (obj.include) {
            var include = [].concat(obj.include);
            for (var j = 0; j < include.length; j++) {
              result.push({ include: include[j] });
            }
            continue;
          }
          if (!obj.type) {
            throw new Error("Rule has no type: " + JSON.stringify(obj));
          }
          result.push(ruleOptions(obj.type, obj));
        }
        return result;
      }
      function ruleOptions(type, obj) {
        if (!isObject(obj)) {
          obj = { match: obj };
        }
        if (obj.include) {
          throw new Error("Matching rules cannot also include states");
        }
        var options = {
          defaultType: type,
          lineBreaks: !!obj.error || !!obj.fallback,
          pop: false,
          next: null,
          push: null,
          error: false,
          fallback: false,
          value: null,
          type: null,
          shouldThrow: false
        };
        for (var key in obj) {
          if (hasOwnProperty2.call(obj, key)) {
            options[key] = obj[key];
          }
        }
        if (typeof options.type === "string" && type !== options.type) {
          throw new Error("Type transform cannot be a string (type '" + options.type + "' for token '" + type + "')");
        }
        var match = options.match;
        options.match = Array.isArray(match) ? match : match ? [match] : [];
        options.match.sort(function(a, b) {
          return isRegExp2(a) && isRegExp2(b) ? 0 : isRegExp2(b) ? -1 : isRegExp2(a) ? 1 : b.length - a.length;
        });
        return options;
      }
      function toRules(spec) {
        return Array.isArray(spec) ? arrayToRules(spec) : objectToRules(spec);
      }
      var defaultErrorRule = ruleOptions("error", { lineBreaks: true, shouldThrow: true });
      function compileRules(rules, hasStates) {
        var errorRule = null;
        var fast = /* @__PURE__ */ Object.create(null);
        var fastAllowed = true;
        var unicodeFlag = null;
        var groups = [];
        var parts = [];
        for (var i = 0; i < rules.length; i++) {
          if (rules[i].fallback) {
            fastAllowed = false;
          }
        }
        for (var i = 0; i < rules.length; i++) {
          var options = rules[i];
          if (options.include) {
            throw new Error("Inheritance is not allowed in stateless lexers");
          }
          if (options.error || options.fallback) {
            if (errorRule) {
              if (!options.fallback === !errorRule.fallback) {
                throw new Error("Multiple " + (options.fallback ? "fallback" : "error") + " rules not allowed (for token '" + options.defaultType + "')");
              } else {
                throw new Error("fallback and error are mutually exclusive (for token '" + options.defaultType + "')");
              }
            }
            errorRule = options;
          }
          var match = options.match.slice();
          if (fastAllowed) {
            while (match.length && typeof match[0] === "string" && match[0].length === 1) {
              var word2 = match.shift();
              fast[word2.charCodeAt(0)] = options;
            }
          }
          if (options.pop || options.push || options.next) {
            if (!hasStates) {
              throw new Error("State-switching options are not allowed in stateless lexers (for token '" + options.defaultType + "')");
            }
            if (options.fallback) {
              throw new Error("State-switching options are not allowed on fallback tokens (for token '" + options.defaultType + "')");
            }
          }
          if (match.length === 0) {
            continue;
          }
          fastAllowed = false;
          groups.push(options);
          for (var j = 0; j < match.length; j++) {
            var obj = match[j];
            if (!isRegExp2(obj)) {
              continue;
            }
            if (unicodeFlag === null) {
              unicodeFlag = obj.unicode;
            } else if (unicodeFlag !== obj.unicode && options.fallback === false) {
              throw new Error("If one rule is /u then all must be");
            }
          }
          var pat = reUnion(match.map(regexpOrLiteral));
          var regexp = new RegExp(pat);
          if (regexp.test("")) {
            throw new Error("RegExp matches empty string: " + regexp);
          }
          var groupCount = reGroups(pat);
          if (groupCount > 0) {
            throw new Error("RegExp has capture groups: " + regexp + "\nUse (?: \u2026 ) instead");
          }
          if (!options.lineBreaks && regexp.test("\n")) {
            throw new Error("Rule should declare lineBreaks: " + regexp);
          }
          parts.push(reCapture(pat));
        }
        var fallbackRule = errorRule && errorRule.fallback;
        var flags = hasSticky && !fallbackRule ? "ym" : "gm";
        var suffix = hasSticky || fallbackRule ? "" : "|";
        if (unicodeFlag === true)
          flags += "u";
        var combined = new RegExp(reUnion(parts) + suffix, flags);
        return { regexp: combined, groups, fast, error: errorRule || defaultErrorRule };
      }
      function compile(rules) {
        var result = compileRules(toRules(rules));
        return new Lexer({ start: result }, "start");
      }
      function checkStateGroup(g, name, map2) {
        var state = g && (g.push || g.next);
        if (state && !map2[state]) {
          throw new Error("Missing state '" + state + "' (in token '" + g.defaultType + "' of state '" + name + "')");
        }
        if (g && g.pop && +g.pop !== 1) {
          throw new Error("pop must be 1 (in token '" + g.defaultType + "' of state '" + name + "')");
        }
      }
      function compileStates(states, start) {
        var all = states.$all ? toRules(states.$all) : [];
        delete states.$all;
        var keys2 = Object.getOwnPropertyNames(states);
        if (!start)
          start = keys2[0];
        var ruleMap = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          ruleMap[key] = toRules(states[key]).concat(all);
        }
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          var rules = ruleMap[key];
          var included = /* @__PURE__ */ Object.create(null);
          for (var j = 0; j < rules.length; j++) {
            var rule = rules[j];
            if (!rule.include)
              continue;
            var splice2 = [j, 1];
            if (rule.include !== key && !included[rule.include]) {
              included[rule.include] = true;
              var newRules = ruleMap[rule.include];
              if (!newRules) {
                throw new Error("Cannot include nonexistent state '" + rule.include + "' (in state '" + key + "')");
              }
              for (var k = 0; k < newRules.length; k++) {
                var newRule = newRules[k];
                if (rules.indexOf(newRule) !== -1)
                  continue;
                splice2.push(newRule);
              }
            }
            rules.splice.apply(rules, splice2);
            j--;
          }
        }
        var map2 = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          map2[key] = compileRules(ruleMap[key], true);
        }
        for (var i = 0; i < keys2.length; i++) {
          var name = keys2[i];
          var state = map2[name];
          var groups = state.groups;
          for (var j = 0; j < groups.length; j++) {
            checkStateGroup(groups[j], name, map2);
          }
          var fastKeys = Object.getOwnPropertyNames(state.fast);
          for (var j = 0; j < fastKeys.length; j++) {
            checkStateGroup(state.fast[fastKeys[j]], name, map2);
          }
        }
        return new Lexer(map2, start);
      }
      function keywordTransform(map2) {
        var isMap3 = typeof Map !== "undefined";
        var reverseMap = isMap3 ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
        var types = Object.getOwnPropertyNames(map2);
        for (var i = 0; i < types.length; i++) {
          var tokenType = types[i];
          var item = map2[tokenType];
          var keywordList = Array.isArray(item) ? item : [item];
          keywordList.forEach(function(keyword) {
            if (typeof keyword !== "string") {
              throw new Error("keyword must be string (in keyword '" + tokenType + "')");
            }
            if (isMap3) {
              reverseMap.set(keyword, tokenType);
            } else {
              reverseMap[keyword] = tokenType;
            }
          });
        }
        return function(k) {
          return isMap3 ? reverseMap.get(k) : reverseMap[k];
        };
      }
      var Lexer = function(states, state) {
        this.startState = state;
        this.states = states;
        this.buffer = "";
        this.stack = [];
        this.reset();
      };
      Lexer.prototype.reset = function(data, info) {
        this.buffer = data || "";
        this.index = 0;
        this.line = info ? info.line : 1;
        this.col = info ? info.col : 1;
        this.queuedToken = info ? info.queuedToken : null;
        this.queuedText = info ? info.queuedText : "";
        this.queuedThrow = info ? info.queuedThrow : null;
        this.setState(info ? info.state : this.startState);
        this.stack = info && info.stack ? info.stack.slice() : [];
        return this;
      };
      Lexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.col,
          state: this.state,
          stack: this.stack.slice(),
          queuedToken: this.queuedToken,
          queuedText: this.queuedText,
          queuedThrow: this.queuedThrow
        };
      };
      Lexer.prototype.setState = function(state) {
        if (!state || this.state === state)
          return;
        this.state = state;
        var info = this.states[state];
        this.groups = info.groups;
        this.error = info.error;
        this.re = info.regexp;
        this.fast = info.fast;
      };
      Lexer.prototype.popState = function() {
        this.setState(this.stack.pop());
      };
      Lexer.prototype.pushState = function(state) {
        this.stack.push(this.state);
        this.setState(state);
      };
      var eat = hasSticky ? function(re, buffer) {
        return re.exec(buffer);
      } : function(re, buffer) {
        var match = re.exec(buffer);
        if (match[0].length === 0) {
          return null;
        }
        return match;
      };
      Lexer.prototype._getGroup = function(match) {
        var groupCount = this.groups.length;
        for (var i = 0; i < groupCount; i++) {
          if (match[i + 1] !== void 0) {
            return this.groups[i];
          }
        }
        throw new Error("Cannot find token type for matched text");
      };
      function tokenToString() {
        return this.value;
      }
      Lexer.prototype.next = function() {
        var index = this.index;
        if (this.queuedGroup) {
          var token = this._token(this.queuedGroup, this.queuedText, index);
          this.queuedGroup = null;
          this.queuedText = "";
          return token;
        }
        var buffer = this.buffer;
        if (index === buffer.length) {
          return;
        }
        var group = this.fast[buffer.charCodeAt(index)];
        if (group) {
          return this._token(group, buffer.charAt(index), index);
        }
        var re = this.re;
        re.lastIndex = index;
        var match = eat(re, buffer);
        var error = this.error;
        if (match == null) {
          return this._token(error, buffer.slice(index, buffer.length), index);
        }
        var group = this._getGroup(match);
        var text = match[0];
        if (error.fallback && match.index !== index) {
          this.queuedGroup = group;
          this.queuedText = text;
          return this._token(error, buffer.slice(index, match.index), index);
        }
        return this._token(group, text, index);
      };
      Lexer.prototype._token = function(group, text, offset) {
        var lineBreaks = 0;
        if (group.lineBreaks) {
          var matchNL = /\n/g;
          var nl = 1;
          if (text === "\n") {
            lineBreaks = 1;
          } else {
            while (matchNL.exec(text)) {
              lineBreaks++;
              nl = matchNL.lastIndex;
            }
          }
        }
        var token = {
          type: typeof group.type === "function" && group.type(text) || group.defaultType,
          value: typeof group.value === "function" ? group.value(text) : text,
          text,
          toString: tokenToString,
          offset,
          lineBreaks,
          line: this.line,
          col: this.col
        };
        var size = text.length;
        this.index += size;
        this.line += lineBreaks;
        if (lineBreaks !== 0) {
          this.col = size - nl + 1;
        } else {
          this.col += size;
        }
        if (group.shouldThrow) {
          var err = new Error(this.formatError(token, "invalid syntax"));
          throw err;
        }
        if (group.pop)
          this.popState();
        else if (group.push)
          this.pushState(group.push);
        else if (group.next)
          this.setState(group.next);
        return token;
      };
      if (typeof Symbol !== "undefined" && Symbol.iterator) {
        var LexerIterator = function(lexer) {
          this.lexer = lexer;
        };
        LexerIterator.prototype.next = function() {
          var token = this.lexer.next();
          return { value: token, done: !token };
        };
        LexerIterator.prototype[Symbol.iterator] = function() {
          return this;
        };
        Lexer.prototype[Symbol.iterator] = function() {
          return new LexerIterator(this);
        };
      }
      Lexer.prototype.formatError = function(token, message) {
        if (token == null) {
          var text = this.buffer.slice(this.index);
          var token = {
            text,
            offset: this.index,
            lineBreaks: text.indexOf("\n") === -1 ? 0 : 1,
            line: this.line,
            col: this.col
          };
        }
        var numLinesAround = 2;
        var firstDisplayedLine = Math.max(token.line - numLinesAround, 1);
        var lastDisplayedLine = token.line + numLinesAround;
        var lastLineDigits = String(lastDisplayedLine).length;
        var displayedLines = lastNLines(
          this.buffer,
          this.line - token.line + numLinesAround + 1
        ).slice(0, 5);
        var errorLines = [];
        errorLines.push(message + " at line " + token.line + " col " + token.col + ":");
        errorLines.push("");
        for (var i = 0; i < displayedLines.length; i++) {
          var line = displayedLines[i];
          var lineNo = firstDisplayedLine + i;
          errorLines.push(pad(String(lineNo), lastLineDigits) + "  " + line);
          if (lineNo === token.line) {
            errorLines.push(pad("", lastLineDigits + token.col + 1) + "^");
          }
        }
        return errorLines.join("\n");
      };
      Lexer.prototype.clone = function() {
        return new Lexer(this.states, this.state);
      };
      Lexer.prototype.has = function(tokenType) {
        return true;
      };
      return {
        compile,
        states: compileStates,
        error: Object.freeze({ error: true }),
        fallback: Object.freeze({ fallback: true }),
        keywords: keywordTransform
      };
    });
  }
});

// ../node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "../node_modules/nearley/lib/nearley.js"(exports, module2) {
    "use strict";
    (function(root, factory) {
      if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " \u25CF " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " \u2192 " + symbolSequence;
      };
      function State(rule, dot2, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot2;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column6(grammar, index) {
        this.grammar = grammar;
        this.index = index;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column6.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column6.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column6.prototype.complete = function(left, right) {
        var copy2 = left.nextState(right);
        this.states.push(copy2);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1)
            nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column6(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column6(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column6(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value2 = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value2) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next = state.nextState({ data: value2, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index = column.index;
        this.current = index;
        this.table[index] = column;
        this.table.splice(index + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t2) {
          if (t2.rule.name === start && t2.dot === t2.rule.symbols.length && t2.reference === 0 && t2.data !== Parser.fail) {
            considerations.push(t2);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// ../node_modules/pgsql-ast-parser/index.js
var require_pgsql_ast_parser = __commonJS({
  "../node_modules/pgsql-ast-parser/index.js"(exports) {
    "use strict";
    (function(e, a) {
      for (var i in a)
        e[i] = a[i];
    })(
      exports,
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value2, mode) {
          if (mode & 1)
            value2 = __webpack_require__(value2);
          if (mode & 8)
            return value2;
          if (mode & 4 && typeof value2 === "object" && value2 && value2.__esModule)
            return value2;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value: value2 });
          if (mode & 2 && typeof value2 != "string")
            for (var key in value2)
              __webpack_require__.d(ns, key, function(key2) {
                return value2[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 7);
      }([
        /* 0 */
        /***/
        function(module3, exports2) {
          module3.exports = require_moo();
        },
        /* 1 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.unbox = exports2.doubleQuoted = exports2.box = exports2.track = exports2.tracking = exports2.trackingComments = exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          const keywords_1 = __webpack_require__(3);
          const keywordsMap = {};
          for (const k of keywords_1.sqlKeywords) {
            keywordsMap["kw_" + k.toLowerCase()] = k;
          }
          const caseInsensitiveKeywords = (map2) => {
            const transform = (0, moo_1.keywords)(map2);
            return (text) => transform(text.toUpperCase());
          };
          exports2.lexer = (0, moo_1.compile)({
            word: {
              match: /[eE](?!')[A-Za-z0-9_]*|[a-df-zA-DF-Z_][A-Za-z0-9_]*/,
              type: caseInsensitiveKeywords(keywordsMap),
              value: (x) => x.toLowerCase()
            },
            wordQuoted: {
              match: /"(?:[^"\*]|"")+"/,
              type: () => "quoted_word",
              value: (x) => x.substring(1, x.length - 1)
            },
            string: {
              match: /'(?:[^']|\'\')*'/,
              value: (x) => {
                return x.substring(1, x.length - 1).replace(/''/g, "'");
              }
            },
            eString: {
              match: /\b(?:e|E)'(?:[^'\\]|[\r\n\s]|(?:\\\s)|(?:\\\n)|(?:\\.)|(?:\'\'))+'/,
              value: (x) => {
                return x.substring(2, x.length - 1).replace(/''/g, "'").replace(/\\([\s\n])/g, (_, x2) => x2).replace(/\\./g, (m) => JSON.parse('"' + m + '"'));
              }
            },
            qparam: {
              match: /\$\d+/
            },
            commentLine: /\-\-.*?$[\s\r\n]*/,
            commentFullOpen: /\/\*/,
            commentFullClose: /\*\/[\s\r\n]*/,
            star: "*",
            comma: ",",
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            int: /\-?\d+(?![\.\d])/,
            float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
            // word: /[a-zA-Z][A-Za-z0-9_\-]*/,
            lparen: "(",
            rparen: ")",
            lbracket: "[",
            rbracket: "]",
            semicolon: ";",
            dot: /\.(?!\d)/,
            op_cast: "::",
            op_colon: ":",
            op_plus: "+",
            op_eq: "=",
            op_neq: {
              match: /(?:!=)|(?:\<\>)/,
              value: () => "!="
            },
            op_membertext: "->>",
            op_member: "->",
            op_minus: "-",
            op_div: /\//,
            op_not_ilike: /\!~~\*/,
            op_not_like: /\!~~/,
            op_ilike: /~~\*/,
            op_like: /~~/,
            op_mod: "%",
            op_exp: "^",
            op_additive: {
              // group other additive operators
              match: ["||", "-", "#-", "&&"]
            },
            op_compare: {
              // group other comparison operators
              // ... to add: "IN" and "NOT IN" that are matched by keywords
              match: [">", ">=", "<", "<=", "@>", "<@", "?", "?|", "?&", "#>>", ">>", "<<", "~", "~*", "!~", "!~*", "@@"]
            },
            ops_others: {
              // referenced as (any other operator) in https://www.postgresql.org/docs/12/sql-syntax-lexical.html#SQL-PRECEDENCE
              // see also https://www.postgresql.org/docs/9.0/functions-math.html
              match: ["|", "&", "^", "#"]
            },
            codeblock: {
              match: /\$\$(?:.|[\s\t\n\v\f\r])*?\$\$/s,
              lineBreaks: true,
              value: (x) => x.substring(2, x.length - 2)
            }
          });
          exports2.lexer.next = ((next) => () => {
            let tok;
            let commentFull = null;
            while (tok = next.call(exports2.lexer)) {
              if (tok.type === "commentFullOpen") {
                if (commentFull === null) {
                  commentFull = {
                    nested: 0,
                    offset: tok.offset,
                    text: tok.text
                  };
                  continue;
                }
                commentFull.nested++;
              }
              if (commentFull != null) {
                commentFull.text += tok.text;
                if (tok.type === "commentFullClose") {
                  if (commentFull.nested === 0) {
                    comments === null || comments === void 0 ? void 0 : comments.push(makeComment(commentFull));
                    commentFull = null;
                    continue;
                  }
                  commentFull.nested--;
                }
                continue;
              }
              if (tok.type === "space") {
                continue;
              }
              if (tok.type === "commentLine") {
                comments === null || comments === void 0 ? void 0 : comments.push(makeComment(tok));
                continue;
              }
              break;
            }
            if (trackingLoc && tok) {
              const start = tok.offset;
              const loc = {
                start,
                end: start + tok.text.length
              };
              tok._location = loc;
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
          let comments = null;
          const makeComment = ({ offset, text }) => ({
            _location: { start: offset, end: offset + text.length },
            comment: text
          });
          function trackingComments(act) {
            if (comments) {
              throw new Error("WAT ? Recursive comments tracking \u{1F914}\u{1F928} ?");
            }
            try {
              comments = [];
              const ast = act();
              return { comments, ast };
            } finally {
              comments = null;
            }
          }
          exports2.trackingComments = trackingComments;
          let trackingLoc = false;
          function tracking(act) {
            if (trackingLoc) {
              return act();
            }
            try {
              trackingLoc = true;
              return act();
            } finally {
              trackingLoc = false;
            }
          }
          exports2.tracking = tracking;
          function track(xs, ret) {
            if (!trackingLoc || !ret || typeof ret !== "object") {
              return ret;
            }
            const start = seek(xs, true);
            const end = seek(xs, false);
            if (!start || !end) {
              return ret;
            }
            if (start === end) {
              ret._location = start;
            } else {
              const loc = {
                start: start.start,
                end: end.end
              };
              ret._location = loc;
            }
            return ret;
          }
          exports2.track = track;
          const literal = Symbol("_literal");
          const doubleQuotedSym = Symbol("_doublequoted");
          function box(xs, value2, doubleQuoted2) {
            if (!trackingLoc && !doubleQuoted2) {
              return value2;
            }
            return track(xs, { [literal]: value2, [doubleQuotedSym]: doubleQuoted2 });
          }
          exports2.box = box;
          function unwrapNoBox(e) {
            if (Array.isArray(e) && e.length === 1) {
              e = unwrapNoBox(e[0]);
            }
            if (Array.isArray(e) && !e.length) {
              return null;
            }
            return e;
          }
          function doubleQuoted(value2) {
            const uw = unwrapNoBox(value2);
            if (typeof value2 === "object" && (uw === null || uw === void 0 ? void 0 : uw[doubleQuotedSym])) {
              return { doubleQuoted: true };
            }
            return void 0;
          }
          exports2.doubleQuoted = doubleQuoted;
          function unbox(value2) {
            var _a;
            if (typeof value2 === "object") {
              return (_a = value2 === null || value2 === void 0 ? void 0 : value2[literal]) !== null && _a !== void 0 ? _a : value2;
            }
            return value2;
          }
          exports2.unbox = unbox;
          function seek(xs, start) {
            if (!xs) {
              return null;
            }
            if (Array.isArray(xs)) {
              const diff = start ? 1 : -1;
              for (let i = start ? 0 : xs.length - 1; i >= 0 && i < xs.length; i += diff) {
                const v = seek(xs[i], start);
                if (v) {
                  return v;
                }
              }
              return null;
            }
            if (typeof xs !== "object") {
              return null;
            }
            return xs._location;
          }
        },
        /* 2 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.AstDefaultMapper = exports2.arrayNilMap = exports2.assignChanged = exports2.astMapper = void 0;
          const utils_1 = __webpack_require__(6);
          function astMapper(modifierBuilder) {
            const instance = new AstDefaultMapper();
            instance.wrapped = modifierBuilder(instance);
            return instance;
          }
          exports2.astMapper = astMapper;
          function assignChanged(orig, assign) {
            if (!orig) {
              return orig;
            }
            let changed = false;
            for (const k of Object.keys(assign)) {
              if (orig[k] !== assign[k]) {
                changed = true;
                break;
              }
            }
            if (!changed) {
              return orig;
            }
            return (0, utils_1.trimNullish)({
              ...orig,
              ...assign
            }, 0);
          }
          exports2.assignChanged = assignChanged;
          function arrayNilMap(collection, mapper) {
            if (!(collection === null || collection === void 0 ? void 0 : collection.length)) {
              return collection;
            }
            let changed = false;
            let ret = collection;
            for (let i = 0; i < collection.length; i++) {
              const orig = collection[i];
              const val = mapper(orig);
              if (!changed && (!val || val !== orig)) {
                changed = true;
                ret = collection.slice(0, i);
              }
              if (!val) {
                continue;
              }
              if (changed) {
                ret.push(val);
              }
            }
            return ret;
          }
          exports2.arrayNilMap = arrayNilMap;
          function withAccepts(val) {
            switch (val === null || val === void 0 ? void 0 : val.type) {
              case "select":
              case "delete":
              case "insert":
              case "update":
              case "union":
              case "union all":
              case "with":
                return true;
              default:
                return false;
            }
          }
          class AstDefaultMapper {
            super() {
              return new SkipModifier(this);
            }
            statement(val) {
              switch (val.type) {
                case "alter table":
                  return this.alterTable(val);
                case "alter index":
                  return this.alterIndex(val);
                case "commit":
                case "start transaction":
                case "rollback":
                  return this.transaction(val);
                case "create index":
                  return this.createIndex(val);
                case "create table":
                  return this.createTable(val);
                case "truncate table":
                  return this.truncateTable(val);
                case "delete":
                  return this.delete(val);
                case "insert":
                  return this.insert(val);
                case "with":
                  return this.with(val);
                case "with recursive":
                  return this.withRecursive(val);
                case "select":
                  return this.selection(val);
                case "update":
                  return this.update(val);
                case "create extension":
                  return this.createExtension(val);
                case "tablespace":
                  return this.tablespace(val);
                case "set":
                  return this.setGlobal(val);
                case "set timezone":
                  return this.setTimezone(val);
                case "create sequence":
                  return this.createSequence(val);
                case "alter sequence":
                  return this.alterSequence(val);
                case "begin":
                  return this.begin(val);
                case "drop table":
                case "drop index":
                case "drop sequence":
                case "drop type":
                case "drop trigger":
                  return this.drop(val);
                case "create enum":
                  return this.createEnum(val);
                case "create composite type":
                  return this.createCompositeType(val);
                case "union":
                case "union all":
                  return this.union(val);
                case "show":
                  return this.show(val);
                case "prepare":
                  return this.prepare(val);
                case "deallocate":
                  return this.deallocate(val);
                case "create view":
                  return this.createView(val);
                case "create materialized view":
                  return this.createMaterializedView(val);
                case "refresh materialized view":
                  return this.refreshMaterializedView(val);
                case "create schema":
                  return this.createSchema(val);
                case "raise":
                  return this.raise(val);
                case "comment":
                  return this.comment(val);
                case "do":
                  return this.do(val);
                case "create function":
                  return this.createFunction(val);
                case "drop function":
                  return this.dropFunction(val);
                case "values":
                  return this.values(val);
                default:
                  throw utils_1.NotSupported.never(val);
              }
            }
            comment(val) {
              return val;
            }
            createView(val) {
              const query = this.select(val.query);
              if (!query) {
                return null;
              }
              const ref = this.tableRef(val.name);
              if (!ref) {
                return null;
              }
              return assignChanged(val, {
                query,
                name: ref
              });
            }
            createMaterializedView(val) {
              const query = this.select(val.query);
              if (!query) {
                return null;
              }
              const ref = this.tableRef(val.name);
              if (!ref) {
                return null;
              }
              return assignChanged(val, {
                query,
                name: ref
              });
            }
            refreshMaterializedView(val) {
              return val;
            }
            do(val) {
              return val;
            }
            createFunction(val) {
              const args = arrayNilMap(val.arguments, (a) => {
                const type = this.dataType(a.type);
                return assignChanged(a, { type });
              });
              let returns;
              if (val.returns) {
                switch (val.returns.kind) {
                  case "table":
                    returns = assignChanged(val.returns, {
                      columns: arrayNilMap(val.returns.columns, (v) => {
                        const type = this.dataType(v.type);
                        return type && assignChanged(v, { type });
                      })
                    });
                    break;
                  case void 0:
                  case null:
                  case "array":
                    returns = this.dataType(val.returns);
                    break;
                  default:
                    throw utils_1.NotSupported.never(val.returns);
                }
              }
              return assignChanged(val, {
                returns,
                arguments: args
              });
            }
            dropFunction(val) {
              const args = arrayNilMap(val.arguments, (a) => {
                const type = this.dataType(a.type);
                return assignChanged(a, { type });
              });
              return assignChanged(val, {
                arguments: args
              });
            }
            show(val) {
              return val;
            }
            createEnum(val) {
              return val;
            }
            createCompositeType(val) {
              const attributes = arrayNilMap(val.attributes, (a) => assignChanged(a, {
                dataType: this.dataType(a.dataType)
              }));
              return assignChanged(val, { attributes });
            }
            drop(val) {
              return val;
            }
            alterSequence(seq) {
              if (seq.change.type === "set options") {
                if (seq.change.as) {
                  this.dataType(seq.change.as);
                }
              }
              return seq;
            }
            begin(begin) {
              return begin;
            }
            createSequence(seq) {
              if (seq.options.as) {
                this.dataType(seq.options.as);
              }
              return seq;
            }
            tablespace(val) {
              return val;
            }
            setGlobal(val) {
              return val;
            }
            setTimezone(val) {
              return val;
            }
            update(val) {
              if (!val) {
                return val;
              }
              const table = this.tableRef(val.table);
              if (!table) {
                return null;
              }
              const from = val.from && this.from(val.from);
              const where = val.where && this.expr(val.where);
              const sets = arrayNilMap(val.sets, (x) => this.set(x));
              if (!(sets === null || sets === void 0 ? void 0 : sets.length)) {
                return null;
              }
              const returning = arrayNilMap(val.returning, (c) => this.selectionColumn(c));
              return assignChanged(val, {
                table,
                where,
                sets,
                from,
                returning
              });
            }
            insert(val) {
              var _a, _b;
              const into = this.tableRef(val.into);
              if (!into) {
                return null;
              }
              const select = val.insert && this.select(val.insert);
              if (!select) {
                return null;
              }
              const returning = arrayNilMap(val.returning, (c) => this.selectionColumn(c));
              let on = (_a = val.onConflict) === null || _a === void 0 ? void 0 : _a.on;
              switch (on === null || on === void 0 ? void 0 : on.type) {
                case "on constraint":
                  break;
                case "on expr":
                  on = assignChanged(on, {
                    exprs: arrayNilMap(on.exprs, (e) => this.expr(e))
                  });
                  break;
                case null:
                case void 0:
                  break;
                default:
                  throw utils_1.NotSupported.never(on);
              }
              let ocdo = (_b = val.onConflict) === null || _b === void 0 ? void 0 : _b.do;
              if (ocdo && ocdo !== "do nothing") {
                const sets = arrayNilMap(ocdo.sets, (x) => this.set(x));
                if (!(sets === null || sets === void 0 ? void 0 : sets.length)) {
                  ocdo = "do nothing";
                } else if (ocdo.sets !== sets) {
                  ocdo = { sets };
                }
              }
              return assignChanged(val, {
                into,
                insert: select,
                returning,
                onConflict: !ocdo ? val.onConflict : assignChanged(val.onConflict, {
                  do: ocdo,
                  on
                })
              });
            }
            raise(val) {
              return assignChanged(val, {
                formatExprs: val.formatExprs && arrayNilMap(val.formatExprs, (x) => this.expr(x)),
                using: val.using && arrayNilMap(val.using, (u) => {
                  return assignChanged(u, {
                    value: this.expr(u.value)
                  });
                })
              });
            }
            delete(val) {
              const from = this.tableRef(val.from);
              if (!from) {
                return null;
              }
              const where = val.where && this.expr(val.where);
              const returning = arrayNilMap(val.returning, (c) => this.selectionColumn(c));
              return assignChanged(val, {
                where,
                returning,
                from
              });
            }
            createSchema(val) {
              return val;
            }
            createTable(val) {
              const columns = arrayNilMap(val.columns, (col) => {
                switch (col.kind) {
                  case "column":
                    return this.createColumn(col);
                  case "like table":
                    return this.likeTable(col);
                  default:
                    throw utils_1.NotSupported.never(col);
                }
              });
              if (!(columns === null || columns === void 0 ? void 0 : columns.length)) {
                return null;
              }
              return assignChanged(val, {
                columns
              });
            }
            likeTable(col) {
              const like = this.tableRef(col.like);
              if (!like) {
                return null;
              }
              return assignChanged(col, { like });
            }
            truncateTable(val) {
              return val;
            }
            constraint(c) {
              switch (c.type) {
                case "not null":
                case "null":
                case "primary key":
                case "unique":
                case "add generated":
                  return c;
                case "default": {
                  const def = this.expr(c.default);
                  if (!def) {
                    return null;
                  }
                  return assignChanged(c, {
                    default: def
                  });
                }
                case "check": {
                  const def = this.expr(c.expr);
                  if (!def) {
                    return null;
                  }
                  return assignChanged(c, {
                    expr: def
                  });
                }
                case "reference": {
                  const foreignTable = this.tableRef(c.foreignTable);
                  if (!foreignTable) {
                    return null;
                  }
                  return assignChanged(c, {
                    foreignTable
                  });
                }
                default:
                  throw utils_1.NotSupported.never(c);
              }
            }
            set(st) {
              const value2 = this.expr(st.value);
              if (!value2) {
                return null;
              }
              return assignChanged(st, {
                value: value2
              });
            }
            // =========================================
            // ================ STUFF ==================
            // =========================================
            /** Called when a data type definition is encountered */
            dataType(dataType) {
              return dataType;
            }
            /** Called when an alias of a table is created */
            tableRef(st) {
              return st;
            }
            transaction(val) {
              return val;
            }
            createExtension(val) {
              return val;
            }
            createIndex(val) {
              const expressions = arrayNilMap(val.expressions, (e) => {
                const expression = this.expr(e.expression);
                if (expression === e.expression) {
                  return e;
                }
                if (!expression) {
                  return null;
                }
                return {
                  ...e,
                  expression
                };
              });
              if (!(expressions === null || expressions === void 0 ? void 0 : expressions.length)) {
                return null;
              }
              return assignChanged(val, {
                expressions
              });
            }
            prepare(st) {
              const statement = this.statement(st.statement);
              if (!statement) {
                return null;
              }
              return assignChanged(st, {
                args: arrayNilMap(st.args, (a) => this.dataType(a)),
                statement
              });
            }
            deallocate(st) {
              return st;
            }
            // =========================================
            // ============== ALTER INDEX ==============
            // =========================================
            alterIndex(st) {
              return st;
            }
            // =========================================
            // ============== ALTER TABLE ==============
            // =========================================
            alterTable(st) {
              var _a;
              const table = this.tableRef(st.table);
              if (!table) {
                return null;
              }
              let changes = [];
              let hasChanged = false;
              for (let i = 0; i < (((_a = st.changes) === null || _a === void 0 ? void 0 : _a.length) || 0); i++) {
                const currentChange = st.changes[i];
                const change = this.tableAlteration(currentChange, st.table);
                hasChanged = hasChanged || change != currentChange;
                if (!!change) {
                  changes.push(change);
                }
              }
              if (!changes.length) {
                return null;
              }
              if (!hasChanged) {
                return st;
              }
              return assignChanged(st, {
                table,
                changes
              });
            }
            tableAlteration(change, table) {
              switch (change.type) {
                case "add column":
                  return this.addColumn(change, table);
                case "add constraint":
                  return this.addConstraint(change, table);
                case "alter column":
                  return this.alterColumn(change, table);
                case "rename":
                  return this.renameTable(change, table);
                case "rename column":
                  return this.renameColumn(change, table);
                case "rename constraint":
                  return this.renameConstraint(change, table);
                case "drop column":
                  return this.dropColumn(change, table);
                case "drop constraint":
                  return this.dropConstraint(change, table);
                case "owner":
                  return this.setTableOwner(change, table);
                default:
                  throw utils_1.NotSupported.never(change);
              }
            }
            dropColumn(change, table) {
              return change;
            }
            dropConstraint(change, table) {
              return change;
            }
            setTableOwner(change, table) {
              return change;
            }
            renameConstraint(change, table) {
              return change;
            }
            renameColumn(change, table) {
              return change;
            }
            renameTable(change, table) {
              return change;
            }
            alterColumn(change, inTable) {
              let alter;
              switch (change.alter.type) {
                case "set default":
                  alter = this.setColumnDefault(change.alter, inTable, change.column);
                  break;
                case "set type":
                  alter = this.setColumnType(change.alter, inTable, change.column);
                  break;
                case "drop default":
                case "set not null":
                case "drop not null":
                  alter = this.alterColumnSimple(change.alter, inTable, change.column);
                  break;
                case "add generated":
                  alter = this.alterColumnAddGenerated(change.alter, inTable, change.column);
                  break;
                default:
                  throw utils_1.NotSupported.never(change.alter);
              }
              if (!alter) {
                return null;
              }
              return assignChanged(change, {
                alter
              });
            }
            setColumnType(alter, inTable, inColumn) {
              const dataType = this.dataType(alter.dataType);
              return assignChanged(alter, {
                dataType
              });
            }
            alterColumnAddGenerated(alter, inTable, inColumn) {
              return alter;
            }
            alterColumnSimple(alter, inTable, inColumn) {
              return alter;
            }
            setColumnDefault(alter, inTable, inColumn) {
              const def = this.expr(alter.default);
              if (!def) {
                return null;
              }
              return assignChanged(alter, {
                default: def
              });
            }
            addConstraint(change, inTable) {
              return change;
            }
            addColumn(change, inTable) {
              const column = this.createColumn(change.column);
              if (!column) {
                return null;
              }
              return assignChanged(change, {
                column
              });
            }
            createColumn(col) {
              var _a;
              const dataType = this.dataType(col.dataType);
              if (!dataType) {
                return null;
              }
              const constraints = (_a = arrayNilMap(col.constraints, (m) => this.constraint(m))) !== null && _a !== void 0 ? _a : void 0;
              return assignChanged(col, {
                dataType,
                constraints
              });
            }
            // =========================================
            // ============== SELECTIONS ==============
            // =========================================
            select(val) {
              switch (val.type) {
                case "select":
                  return this.selection(val);
                case "union":
                case "union all":
                  return this.union(val);
                case "with":
                  return this.with(val);
                case "values":
                  return this.values(val);
                case "with recursive":
                  return this.withRecursive(val);
                default:
                  throw utils_1.NotSupported.never(val);
              }
            }
            selection(val) {
              var _a, _b;
              const from = arrayNilMap(val.from, (c) => this.from(c));
              const columns = arrayNilMap(val.columns, (c) => this.selectionColumn(c));
              const where = val.where && this.expr(val.where);
              const groupBy2 = arrayNilMap(val.groupBy, (c) => this.expr(c));
              const having = val.having && this.expr(val.having);
              const orderBy = this.orderBy(val.orderBy);
              const limit = assignChanged(val.limit, {
                limit: this.expr((_a = val.limit) === null || _a === void 0 ? void 0 : _a.limit),
                offset: this.expr((_b = val.limit) === null || _b === void 0 ? void 0 : _b.offset)
              });
              return assignChanged(val, {
                from,
                columns,
                where,
                groupBy: groupBy2,
                having,
                orderBy,
                limit
              });
            }
            orderBy(orderBy) {
              return arrayNilMap(orderBy, (c) => {
                const by = this.expr(c.by);
                if (!by) {
                  return null;
                }
                if (by === c.by) {
                  return c;
                }
                return {
                  ...c,
                  by
                };
              });
            }
            union(val) {
              const left = this.select(val.left);
              const right = this.select(val.right);
              if (!left || !right) {
                return left !== null && left !== void 0 ? left : right;
              }
              return assignChanged(val, {
                left,
                right
              });
            }
            with(val) {
              const bind = arrayNilMap(val.bind, (s) => {
                const statement = this.statement(s.statement);
                return withAccepts(statement) ? assignChanged(s, { statement }) : null;
              });
              if (!bind) {
                return null;
              }
              const _in = this.statement(val.in);
              if (!withAccepts(_in)) {
                return null;
              }
              return assignChanged(val, {
                bind,
                in: _in
              });
            }
            withRecursive(val) {
              const statement = this.union(val.bind);
              if (!statement) {
                return null;
              }
              if (statement.type !== "union" && statement.type !== "union all") {
                return null;
              }
              const _in = this.statement(val.in);
              if (!withAccepts(_in)) {
                return null;
              }
              return assignChanged(val, {
                bind: statement,
                in: _in
              });
            }
            from(from) {
              switch (from.type) {
                case "table":
                  return this.fromTable(from);
                case "statement":
                  return this.fromStatement(from);
                case "call":
                  return this.fromCall(from);
                default:
                  throw utils_1.NotSupported.never(from);
              }
            }
            fromCall(from) {
              const call = this.call(from);
              if (!call || call.type !== "call") {
                return null;
              }
              return assignChanged(from, call);
            }
            fromStatement(from) {
              const statement = this.select(from.statement);
              if (!statement) {
                return null;
              }
              const join3 = from.join && this.join(from.join);
              return assignChanged(from, {
                statement,
                join: join3
              });
            }
            values(from) {
              const values2 = arrayNilMap(from.values, (x) => arrayNilMap(x, (y) => this.expr(y)));
              if (!(values2 === null || values2 === void 0 ? void 0 : values2.length)) {
                return null;
              }
              return assignChanged(from, {
                values: values2
              });
            }
            join(join3) {
              const on = join3.on && this.expr(join3.on);
              if (!on && !join3.using) {
                return join3;
              }
              return assignChanged(join3, {
                on
              });
            }
            fromTable(from) {
              const nfrom = this.tableRef(from.name);
              if (!nfrom) {
                return null;
              }
              const join3 = from.join && this.join(from.join);
              return assignChanged(from, {
                name: nfrom,
                join: join3
              });
            }
            selectionColumn(val) {
              const expr = this.expr(val.expr);
              if (!expr) {
                return null;
              }
              return assignChanged(val, {
                expr
              });
            }
            // =========================================
            // ============== EXPRESSIONS ==============
            // =========================================
            expr(val) {
              if (!val) {
                return val;
              }
              switch (val.type) {
                case "binary":
                  return this.binary(val);
                case "unary":
                  return this.unary(val);
                case "ref":
                  return this.ref(val);
                case "string":
                case "numeric":
                case "integer":
                case "boolean":
                case "constant":
                case "null":
                  return this.constant(val);
                case "list":
                case "array":
                  return this.array(val);
                case "array select":
                  return this.arraySelect(val);
                case "call":
                  return this.call(val);
                case "cast":
                  return this.cast(val);
                case "case":
                  return this.case(val);
                case "member":
                  return this.member(val);
                case "arrayIndex":
                  return this.arrayIndex(val);
                case "ternary":
                  return this.ternary(val);
                case "select":
                case "union":
                case "union all":
                case "with":
                case "with recursive":
                  return this.select(val);
                case "keyword":
                  return this.valueKeyword(val);
                case "parameter":
                  return this.parameter(val);
                case "extract":
                  return this.extract(val);
                case "overlay":
                  return this.callOverlay(val);
                case "substring":
                  return this.callSubstring(val);
                case "values":
                  return this.values(val);
                case "default":
                  return this.default(val);
                default:
                  throw utils_1.NotSupported.never(val);
              }
            }
            arraySelect(val) {
              const select = this.select(val.select);
              if (!select) {
                return null;
              }
              return assignChanged(val, { select });
            }
            extract(st) {
              const from = this.expr(st.from);
              if (!from) {
                return null;
              }
              return assignChanged(st, { from });
            }
            valueKeyword(val) {
              return val;
            }
            ternary(val) {
              const value2 = this.expr(val.value);
              const lo = this.expr(val.lo);
              const hi = this.expr(val.hi);
              if (!value2 || !lo || !hi) {
                return null;
              }
              return assignChanged(val, {
                value: value2,
                lo,
                hi
              });
            }
            parameter(st) {
              return st;
            }
            arrayIndex(val) {
              const array = this.expr(val.array);
              const index = this.expr(val.index);
              if (!array || !index) {
                return null;
              }
              return assignChanged(val, {
                array,
                index
              });
            }
            member(val) {
              const operand = this.expr(val.operand);
              if (!operand) {
                return null;
              }
              return assignChanged(val, {
                operand
              });
            }
            case(val) {
              const value2 = val.value && this.expr(val.value);
              const whens = arrayNilMap(val.whens, (w) => {
                const when = this.expr(w.when);
                const value3 = this.expr(w.value);
                if (!when || !value3) {
                  return null;
                }
                return assignChanged(w, {
                  value: value3,
                  when
                });
              });
              if (!(whens === null || whens === void 0 ? void 0 : whens.length)) {
                return null;
              }
              const els = val.else && this.expr(val.else);
              return assignChanged(val, {
                value: value2,
                whens,
                else: els
              });
            }
            cast(val) {
              const operand = this.expr(val.operand);
              if (!operand) {
                return null;
              }
              return assignChanged(val, {
                operand
              });
            }
            call(val) {
              const args = arrayNilMap(val.args, (a) => this.expr(a));
              if (!args) {
                return null;
              }
              const orderBy = this.orderBy(val.orderBy);
              const filter3 = this.expr(val.filter);
              return assignChanged(val, {
                args,
                orderBy,
                filter: filter3
              });
            }
            callSubstring(val) {
              return assignChanged(val, {
                value: this.expr(val.value),
                from: this.expr(val.from),
                for: this.expr(val.for)
              });
            }
            callOverlay(val) {
              return assignChanged(val, {
                value: this.expr(val.value),
                placing: this.expr(val.placing),
                from: this.expr(val.from),
                for: this.expr(val.for)
              });
            }
            array(val) {
              const expressions = arrayNilMap(val.expressions, (a) => this.expr(a));
              if (!expressions) {
                return null;
              }
              return assignChanged(val, {
                expressions
              });
            }
            constant(value2) {
              return value2;
            }
            default(value2) {
              return value2;
            }
            /** Called when a reference is used */
            ref(val) {
              return val;
            }
            unary(val) {
              const operand = this.expr(val.operand);
              if (!operand) {
                return null;
              }
              return assignChanged(val, {
                operand
              });
            }
            binary(val) {
              const left = this.expr(val.left);
              const right = this.expr(val.right);
              if (!left || !right) {
                return null;
              }
              return assignChanged(val, {
                left,
                right
              });
            }
          }
          exports2.AstDefaultMapper = AstDefaultMapper;
          const proto = AstDefaultMapper.prototype;
          for (const k of Object.getOwnPropertyNames(proto)) {
            const orig = proto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(proto, k, {
              configurable: false,
              get() {
                return function(...args) {
                  var _a;
                  if (this.skipNext) {
                    this.skipNext = false;
                    return orig.apply(this, args);
                  }
                  const impl = (_a = this.wrapped) === null || _a === void 0 ? void 0 : _a[k];
                  if (!impl) {
                    return orig.apply(this, args);
                  }
                  return impl.apply(this.wrapped, args);
                };
              }
            });
          }
          class SkipModifier extends AstDefaultMapper {
            constructor(parent) {
              super();
              this.parent = parent;
            }
          }
          for (const k of Object.getOwnPropertyNames(proto)) {
            const orig = proto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(SkipModifier.prototype, k, {
              configurable: false,
              get() {
                return function(...args) {
                  this.parent.skipNext = true;
                  return orig.apply(this.parent, args);
                };
              }
            });
          }
        },
        /* 3 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.sqlKeywords = void 0;
          exports2.sqlKeywords = [
            "ALL",
            "ANALYSE",
            "ANALYZE",
            "AND",
            "ANY",
            "ARRAY",
            "AS",
            "ASC",
            "ASYMMETRIC",
            "AUTHORIZATION",
            "BINARY",
            "BOTH",
            "CASE",
            "CAST",
            "CHECK",
            "COLLATE",
            "COLLATION",
            "CONCURRENTLY",
            "CONSTRAINT",
            "CREATE",
            "CROSS",
            "CURRENT_CATALOG",
            "CURRENT_DATE",
            "CURRENT_ROLE",
            "CURRENT_SCHEMA",
            "CURRENT_TIME",
            "CURRENT_TIMESTAMP",
            "CURRENT_USER",
            "DEFAULT",
            "DEFERRABLE",
            "DESC",
            "DISTINCT",
            "DO",
            "ELSE",
            "END",
            "EXCEPT",
            "FALSE",
            "FETCH",
            "FOR",
            "FOREIGN",
            "FREEZE",
            "FROM",
            "FULL",
            "GRANT",
            "GROUP",
            "HAVING",
            "ILIKE",
            "IN",
            "INITIALLY",
            "INNER",
            "INTERSECT",
            "INTO",
            "IS",
            "ISNULL",
            "JOIN",
            "LATERAL",
            "LEADING",
            "LEFT",
            "LIKE",
            "LIMIT",
            "LOCALTIME",
            "LOCALTIMESTAMP",
            "NATURAL",
            "NOT",
            "NOTNULL",
            "NULL",
            "OFFSET",
            "ON",
            "ONLY",
            "OR",
            "ORDER",
            "OUTER",
            "OVERLAPS",
            "PLACING",
            "PRIMARY",
            "REFERENCES",
            "RETURNING",
            "RIGHT",
            "SELECT",
            "SESSION_USER",
            "SIMILAR",
            "SOME",
            "SYMMETRIC",
            "TABLE",
            "TABLESAMPLE",
            "THEN",
            "TO",
            "TRAILING",
            "TRUE",
            "UNION",
            "UNIQUE",
            "USER",
            "USING",
            "VARIADIC",
            "VERBOSE",
            "WHEN",
            "WHERE",
            "WINDOW",
            "WITH",
            "PRECISION"
          ];
        },
        /* 4 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.intervalToString = exports2.normalizeInterval = exports2.buildInterval = void 0;
          const types = [
            ["years", 12],
            ["months", 30],
            ["days", 24],
            ["hours", 60],
            ["minutes", 60],
            ["seconds", 1e3],
            ["milliseconds", 0]
          ];
          function* unwrap(k) {
            if (typeof k[1] === "number") {
              yield k;
            } else {
              for (const v of k) {
                yield* unwrap(v);
              }
            }
          }
          function buildInterval(orig, vals) {
            var _a;
            const ret = {};
            if (vals === "invalid") {
              throw new Error(`invalid input syntax for type interval: "${orig}"`);
            }
            for (const [k, v] of unwrap(vals)) {
              ret[k] = ((_a = ret[k]) !== null && _a !== void 0 ? _a : 0) + v;
            }
            return ret;
          }
          exports2.buildInterval = buildInterval;
          function normalizeInterval(value2) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const ret = { ...value2 };
            for (let i = 0; i < types.length; i++) {
              const [k, mul] = types[i];
              const v = (_a = ret[k]) !== null && _a !== void 0 ? _a : 0;
              const int2 = v >= 0 ? Math.floor(v) : Math.ceil(v);
              if (!v || int2 === v) {
                continue;
              }
              const nk = (_b = types[i + 1]) === null || _b === void 0 ? void 0 : _b[0];
              if (nk) {
                ret[nk] = ((_c = ret[nk]) !== null && _c !== void 0 ? _c : 0) + mul * (v - int2);
              }
              ret[k] = int2;
            }
            if (ret.months || ret.years) {
              const m = ((_d = ret.months) !== null && _d !== void 0 ? _d : 0) + ((_e = ret.years) !== null && _e !== void 0 ? _e : 0) * 12;
              ret.months = m % 12;
              ret.years = (m - ret.months) / 12;
            }
            let t2 = ((_f = ret.hours) !== null && _f !== void 0 ? _f : 0) * 3600 + ((_g = ret.minutes) !== null && _g !== void 0 ? _g : 0) * 60 + ((_h = ret.seconds) !== null && _h !== void 0 ? _h : 0) + ((_j = ret.milliseconds) !== null && _j !== void 0 ? _j : 0) / 1e3;
            let sign = 1;
            if (t2 < 0) {
              sign = -1;
              t2 = -t2;
            }
            if (t2 >= 3600) {
              ret.hours = sign * Math.floor(t2 / 3600);
              t2 -= sign * ret.hours * 3600;
            } else {
              delete ret.hours;
            }
            if (t2 >= 60) {
              ret.minutes = sign * Math.floor(t2 / 60);
              t2 -= sign * ret.minutes * 60;
            } else {
              delete ret.minutes;
            }
            if (t2 > 0) {
              ret.seconds = sign * Math.floor(t2);
              t2 -= sign * ret.seconds;
            } else {
              delete ret.seconds;
            }
            if (t2 > 0) {
              ret.milliseconds = sign * Math.round(t2 * 1e3);
            } else {
              delete ret.milliseconds;
            }
            for (const [k] of types) {
              if (!ret[k]) {
                delete ret[k];
              }
            }
            return ret;
          }
          exports2.normalizeInterval = normalizeInterval;
          function intervalToString(value2) {
            var _a, _b, _c;
            value2 = normalizeInterval(value2);
            const ret = [];
            if (value2.years) {
              ret.push(value2.years === 1 ? "1 year" : value2.years + " years");
            }
            if (value2.months) {
              ret.push(value2.months === 1 ? "1 month" : value2.months + " months");
            }
            if (value2.days) {
              ret.push(value2.days === 1 ? "1 day" : value2.days + " days");
            }
            if (value2.hours || value2.minutes || value2.seconds || value2.milliseconds) {
              let time = `${num((_a = value2.hours) !== null && _a !== void 0 ? _a : 0)}:${num((_b = value2.minutes) !== null && _b !== void 0 ? _b : 0)}:${num((_c = value2.seconds) !== null && _c !== void 0 ? _c : 0)}`;
              if (value2.milliseconds) {
                time = time + (value2.milliseconds / 1e3).toString().substr(1);
              }
              if (neg3(value2.hours) || neg3(value2.minutes) || neg3(value2.seconds) || neg3(value2.milliseconds)) {
                time = "-" + time;
              }
              ret.push(time);
            }
            return ret.join(" ");
          }
          exports2.intervalToString = intervalToString;
          function num(v) {
            v = Math.abs(v);
            return v < 10 ? "0" + v : v.toString();
          }
          function neg3(v) {
            return v && v < 0;
          }
        },
        /* 5 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.astVisitor = void 0;
          const ast_mapper_1 = __webpack_require__(2);
          class Visitor {
            super() {
              return new SkipVisitor(this);
            }
          }
          const mapperProto = ast_mapper_1.AstDefaultMapper.prototype;
          for (const k of Object.getOwnPropertyNames(mapperProto)) {
            const orig = mapperProto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(Visitor.prototype, k, {
              configurable: false,
              get() {
                return function(...args) {
                  const impl = this.visitor[k];
                  if (!impl) {
                    return orig.apply(this, args);
                  }
                  impl.apply(this.visitor, args);
                  return args[0];
                };
              }
            });
          }
          class SkipVisitor {
            constructor(parent) {
              this.parent = parent;
            }
          }
          for (const k of Object.getOwnPropertyNames(mapperProto)) {
            const orig = mapperProto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            Object.defineProperty(SkipVisitor.prototype, k, {
              configurable: false,
              get() {
                return function(...args) {
                  return orig.apply(this.parent, args);
                };
              }
            });
          }
          function astVisitor(visitorBuilder) {
            return (0, ast_mapper_1.astMapper)((m) => {
              const ret = new Visitor();
              ret.mapper = m;
              ret.visitor = visitorBuilder(ret);
              return ret;
            });
          }
          exports2.astVisitor = astVisitor;
        },
        /* 6 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.trimNullish = exports2.NotSupported = void 0;
          class NotSupported extends Error {
            constructor(what) {
              super("Not supported" + (what ? ": " + what : ""));
            }
            static never(value2, msg) {
              return new NotSupported(`${msg !== null && msg !== void 0 ? msg : ""} ${JSON.stringify(value2)}`);
            }
          }
          exports2.NotSupported = NotSupported;
          function trimNullish(value2, depth = 5) {
            if (depth < 0)
              return value2;
            if (value2 instanceof Array) {
              value2.forEach((x) => trimNullish(x, depth - 1));
            }
            if (typeof value2 !== "object" || value2 instanceof Date)
              return value2;
            if (!value2) {
              return value2;
            }
            for (const k of Object.keys(value2)) {
              const val = value2[k];
              if (val === void 0 || val === null)
                delete value2[k];
              else
                trimNullish(val, depth - 1);
            }
            return value2;
          }
          exports2.trimNullish = trimNullish;
        },
        /* 7 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          });
          var __exportStar = this && this.__exportStar || function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.normalizeInterval = exports2.intervalToString = exports2.toSql = exports2.astMapper = exports2.assignChanged = exports2.arrayNilMap = exports2.astVisitor = exports2.parseWithComments = exports2.parseIntervalLiteral = exports2.parseGeometricLiteral = exports2.parseArrayLiteral = exports2.parseFirst = exports2.parse = void 0;
          var parser_1 = __webpack_require__(8);
          Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
            return parser_1.parse;
          } });
          Object.defineProperty(exports2, "parseFirst", { enumerable: true, get: function() {
            return parser_1.parseFirst;
          } });
          Object.defineProperty(exports2, "parseArrayLiteral", { enumerable: true, get: function() {
            return parser_1.parseArrayLiteral;
          } });
          Object.defineProperty(exports2, "parseGeometricLiteral", { enumerable: true, get: function() {
            return parser_1.parseGeometricLiteral;
          } });
          Object.defineProperty(exports2, "parseIntervalLiteral", { enumerable: true, get: function() {
            return parser_1.parseIntervalLiteral;
          } });
          Object.defineProperty(exports2, "parseWithComments", { enumerable: true, get: function() {
            return parser_1.parseWithComments;
          } });
          var ast_visitor_1 = __webpack_require__(5);
          Object.defineProperty(exports2, "astVisitor", { enumerable: true, get: function() {
            return ast_visitor_1.astVisitor;
          } });
          var ast_mapper_1 = __webpack_require__(2);
          Object.defineProperty(exports2, "arrayNilMap", { enumerable: true, get: function() {
            return ast_mapper_1.arrayNilMap;
          } });
          Object.defineProperty(exports2, "assignChanged", { enumerable: true, get: function() {
            return ast_mapper_1.assignChanged;
          } });
          Object.defineProperty(exports2, "astMapper", { enumerable: true, get: function() {
            return ast_mapper_1.astMapper;
          } });
          var to_sql_1 = __webpack_require__(19);
          Object.defineProperty(exports2, "toSql", { enumerable: true, get: function() {
            return to_sql_1.toSql;
          } });
          __exportStar(__webpack_require__(21), exports2);
          var interval_builder_1 = __webpack_require__(4);
          Object.defineProperty(exports2, "intervalToString", { enumerable: true, get: function() {
            return interval_builder_1.intervalToString;
          } });
          Object.defineProperty(exports2, "normalizeInterval", { enumerable: true, get: function() {
            return interval_builder_1.normalizeInterval;
          } });
        },
        /* 8 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.parseGeometricLiteral = exports2.parseIntervalLiteral = exports2.parseArrayLiteral = exports2.parse = exports2.parseWithComments = exports2.parseFirst = void 0;
          const nearley_1 = __webpack_require__(9);
          const main_ne_1 = __importDefault(__webpack_require__(10));
          const array_ne_1 = __importDefault(__webpack_require__(11));
          const geometric_ne_1 = __importDefault(__webpack_require__(13));
          const interval_ne_1 = __importDefault(__webpack_require__(15));
          const interval_iso_ne_1 = __importDefault(__webpack_require__(17));
          const interval_builder_1 = __webpack_require__(4);
          const lexer_1 = __webpack_require__(1);
          let sqlCompiled;
          let arrayCompiled;
          let geometricCompiled;
          let intervalTextCompiled;
          let intervalIsoCompiled;
          function parseFirst(sql) {
            const first3 = parse2(sql);
            return first3[0];
          }
          exports2.parseFirst = parseFirst;
          function parseWithComments(sql, options) {
            return (0, lexer_1.trackingComments)(() => parse2(sql, options));
          }
          exports2.parseWithComments = parseWithComments;
          function parse2(sql, optEntry) {
            if (!sqlCompiled) {
              sqlCompiled = nearley_1.Grammar.fromCompiled(main_ne_1.default);
            }
            const entry = typeof optEntry === "string" ? optEntry : optEntry === null || optEntry === void 0 ? void 0 : optEntry.entry;
            const opts = typeof optEntry === "string" ? null : optEntry;
            const doParse = () => _parse(sql, sqlCompiled, entry);
            let parsed = (opts === null || opts === void 0 ? void 0 : opts.locationTracking) ? (0, lexer_1.tracking)(doParse) : doParse();
            if (typeof optEntry !== "string" && !Array.isArray(parsed)) {
              parsed = [parsed];
            }
            return parsed;
          }
          exports2.parse = parse2;
          function parseArrayLiteral(sql) {
            if (!arrayCompiled) {
              arrayCompiled = nearley_1.Grammar.fromCompiled(array_ne_1.default);
            }
            return _parse(sql, arrayCompiled);
          }
          exports2.parseArrayLiteral = parseArrayLiteral;
          function parseIntervalLiteral(literal) {
            if (literal.startsWith("P")) {
              if (!intervalIsoCompiled) {
                intervalIsoCompiled = nearley_1.Grammar.fromCompiled(interval_iso_ne_1.default);
              }
              return (0, interval_builder_1.buildInterval)(literal, _parse(literal, intervalIsoCompiled));
            } else {
              if (!intervalTextCompiled) {
                intervalTextCompiled = nearley_1.Grammar.fromCompiled(interval_ne_1.default);
              }
              const low = literal.toLowerCase();
              return (0, interval_builder_1.buildInterval)(literal, _parse(low, intervalTextCompiled));
            }
          }
          exports2.parseIntervalLiteral = parseIntervalLiteral;
          function parseGeometricLiteral(sql, type) {
            if (!geometricCompiled) {
              geometricCompiled = nearley_1.Grammar.fromCompiled(geometric_ne_1.default);
            }
            return _parse(sql, geometricCompiled, type);
          }
          exports2.parseGeometricLiteral = parseGeometricLiteral;
          function _parse(sql, grammar, entry) {
            try {
              grammar.start = entry !== null && entry !== void 0 ? entry : "main";
              const parser = new nearley_1.Parser(grammar);
              parser.feed(sql);
              const asts = parser.finish();
              if (!asts.length) {
                throw new Error("Unexpected end of input");
              } else if (asts.length !== 1) {
                throw new Error(`\u{1F480} Ambiguous SQL syntax: Please file an issue stating the request that has failed at https://github.com/oguimbal/pgsql-ast-parser:

        ${sql}

        `);
              }
              return asts[0];
            } catch (e) {
              if (typeof (e === null || e === void 0 ? void 0 : e.message) !== "string") {
                throw e;
              }
              let msg = e.message;
              let begin = null;
              const parts = [];
              const reg = /A (.+) token based on:/g;
              let m;
              while (m = reg.exec(msg)) {
                begin = begin !== null && begin !== void 0 ? begin : msg.substr(0, m.index);
                parts.push(`    - A "${m[1]}" token`);
              }
              if (begin) {
                msg = begin + parts.join("\n") + "\n\n";
              }
              e.message = msg;
              throw e;
            }
          }
        },
        /* 9 */
        /***/
        function(module3, exports2) {
          module3.exports = require_nearley();
        },
        /* 10 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const lexer_1 = __webpack_require__(1);
          const lexer_2 = __webpack_require__(1);
          function debug(fn) {
            fn = fn || ((x) => x);
            return (x, ...args) => {
              debugger;
              return fn(x, ...args);
            };
          }
          function asName(val) {
            return asNameWithColumns(val, void 0);
          }
          function asNameWithColumns(val, columns) {
            const name = toStr(val);
            if (!columns || columns.length === 0) {
              return (0, lexer_2.track)(val, { name });
            }
            return (0, lexer_2.track)(val, {
              name,
              columns: columns.map((c) => ({ name: toStr(c) }))
            });
          }
          function asLit(val) {
            const value3 = toStr(val);
            return (0, lexer_2.track)(val, { value: value3 });
          }
          function unwrap(e) {
            if (Array.isArray(e) && e.length === 1) {
              e = unwrap(e[0]);
            }
            if (Array.isArray(e) && !e.length) {
              return null;
            }
            return (0, lexer_2.unbox)(e);
          }
          const get11 = (i) => (x) => (0, lexer_2.track)(x, x[i]);
          const last3 = (x) => Array.isArray(x) ? (0, lexer_2.track)(x[x.length - 1], x[x.length - 1]) : x;
          const trim = (x) => x && x.trim();
          const value2 = (x) => x && x.value;
          function flatten3(e) {
            if (Array.isArray(e)) {
              const ret = [];
              for (const i of e) {
                ret.push(...flatten3(i));
              }
              return ret;
            }
            if (!e) {
              return [];
            }
            return [e];
          }
          function asStr(value3) {
            var _a;
            value3 = (0, lexer_2.unbox)(value3);
            return (_a = value3 === null || value3 === void 0 ? void 0 : value3.value) !== null && _a !== void 0 ? _a : value3;
          }
          function flattenStr(e) {
            const fl = flatten3((0, lexer_2.unbox)(e));
            return fl.filter((x) => !!x).map((x) => asStr(x)).filter((x) => typeof x === "string").map((x) => x.trim()).filter((x) => !!x);
          }
          function toStr(e, join3) {
            return flattenStr(e).join(join3 || "");
          }
          function fromEntries(vals) {
            const ret = {};
            for (const [k, v] of vals) {
              ret[k] = v;
            }
            return ret;
          }
          const kwSensitivity = { sensitivity: "accent" };
          const eqInsensitive = (a, b) => a.localeCompare(b, void 0, kwSensitivity) === 0;
          const notReservedKw = (kw2) => (x, _, rej) => {
            const val = asStr(x[0]);
            if (eqInsensitive(val, kw2)) {
              return (0, lexer_2.box)(x, kw2);
            }
            return rej;
          };
          const kw = notReservedKw;
          const anyKw = (...kw2) => {
            const kwSet = new Set(kw2);
            return (x, _, rej) => {
              const val = typeof x[0] === "string" ? x[0] : x[0].value;
              return kwSet.has(val) ? val : rej;
            };
          };
          function setSeqOpts(ret, opts) {
            const defs = /* @__PURE__ */ new Set();
            const unboxed = opts.map(lexer_2.unbox);
            for (const [k, v] of unboxed) {
              if (defs.has(k)) {
                throw new Error("conflicting or redundant options");
              }
              defs.add(k);
              ret[k] = (0, lexer_2.unbox)(v);
            }
          }
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: lexer_1.lexerAny,
            ParserRules: [
              { "name": "lparen", "symbols": [lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen] },
              { "name": "rparen", "symbols": [lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen] },
              { "name": "number$subexpression$1", "symbols": ["float"] },
              { "name": "number$subexpression$1", "symbols": ["int"] },
              { "name": "number", "symbols": ["number$subexpression$1"], "postprocess": unwrap },
              { "name": "dot", "symbols": [lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot], "postprocess": id },
              { "name": "float", "symbols": [lexer_1.lexerAny.has("float") ? { type: "float" } : float], "postprocess": (x) => (0, lexer_2.box)(x, parseFloat(unwrap(x))) },
              { "name": "int", "symbols": [lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": (x) => (0, lexer_2.box)(x, parseInt(unwrap(x), 10)) },
              { "name": "comma", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma], "postprocess": id },
              { "name": "star", "symbols": [lexer_1.lexerAny.has("star") ? { type: "star" } : star], "postprocess": (x) => (0, lexer_2.box)(x, x[0].value) },
              { "name": "string$subexpression$1", "symbols": [lexer_1.lexerAny.has("string") ? { type: "string" } : string] },
              { "name": "string$subexpression$1", "symbols": [lexer_1.lexerAny.has("eString") ? { type: "eString" } : eString] },
              { "name": "string", "symbols": ["string$subexpression$1"], "postprocess": (x) => (0, lexer_2.box)(x, unwrap(x[0]).value) },
              { "name": "ident", "symbols": ["word"], "postprocess": get11(0) },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("kw_primary") ? { type: "kw_primary" } : kw_primary], "postprocess": (x) => (0, lexer_2.box)(x, "primary") },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique], "postprocess": (x) => (0, lexer_2.box)(x, "unique") },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("quoted_word") ? { type: "quoted_word" } : quoted_word], "postprocess": (x) => (0, lexer_2.box)(x, x[0].value, true) },
              { "name": "word", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": (x) => (0, lexer_2.box)(x, x[0].value) },
              { "name": "collist_paren", "symbols": ["lparen", "collist", "rparen"], "postprocess": get11(1) },
              { "name": "collist$ebnf$1", "symbols": [] },
              { "name": "collist$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last3 },
              { "name": "collist$ebnf$1", "symbols": ["collist$ebnf$1", "collist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "collist", "symbols": ["ident", "collist$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "kw_between", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("between") },
              { "name": "kw_conflict", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("conflict") },
              { "name": "kw_nothing", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("nothing") },
              { "name": "kw_begin", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("begin") },
              { "name": "kw_if", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("if") },
              { "name": "kw_exists", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("exists") },
              { "name": "kw_key", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("key") },
              { "name": "kw_index", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("index") },
              { "name": "kw_extension", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("extension") },
              { "name": "kw_schema", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("schema") },
              { "name": "kw_nulls", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("nulls") },
              { "name": "kw_first", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("first") },
              { "name": "kw_last", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("last") },
              { "name": "kw_start", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("start") },
              { "name": "kw_restart", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("restart") },
              { "name": "kw_filter", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("filter") },
              { "name": "kw_commit", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("commit") },
              { "name": "kw_tablespace", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("tablespace") },
              { "name": "kw_transaction", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("transaction") },
              { "name": "kw_work", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("work") },
              { "name": "kw_read", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("read") },
              { "name": "kw_write", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("write") },
              { "name": "kw_isolation", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("isolation") },
              { "name": "kw_level", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("level") },
              { "name": "kw_serializable", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("serializable") },
              { "name": "kw_rollback", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("rollback") },
              { "name": "kw_insert", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("insert") },
              { "name": "kw_value", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("value") },
              { "name": "kw_values", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("values") },
              { "name": "kw_update", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("update") },
              { "name": "kw_column", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("column") },
              { "name": "kw_set", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("set") },
              { "name": "kw_version", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("version") },
              { "name": "kw_alter", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("alter") },
              { "name": "kw_rename", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("rename") },
              { "name": "kw_sequence", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("sequence") },
              { "name": "kw_temp", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("temp") },
              { "name": "kw_temporary", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("temporary") },
              { "name": "kw_add", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("add") },
              { "name": "kw_owner", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("owner") },
              { "name": "kw_owned", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("owned") },
              { "name": "kw_including", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("including") },
              { "name": "kw_excluding", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("excluding") },
              { "name": "kw_none", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("none") },
              { "name": "kw_drop", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("drop") },
              { "name": "kw_operator", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("operator") },
              { "name": "kw_minvalue", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("minvalue") },
              { "name": "kw_maxvalue", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("maxvalue") },
              { "name": "kw_data", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("data") },
              { "name": "kw_type", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("type") },
              { "name": "kw_trigger", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("trigger") },
              { "name": "kw_delete", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("delete") },
              { "name": "kw_cache", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cache") },
              { "name": "kw_cascade", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cascade") },
              { "name": "kw_no", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("no") },
              { "name": "kw_timestamp", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("timestamp") },
              { "name": "kw_cycle", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cycle") },
              { "name": "kw_function", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("function") },
              { "name": "kw_returns", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("returns") },
              { "name": "kw_language", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("language") },
              { "name": "kw_out", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("out") },
              { "name": "kw_inout", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("inout") },
              { "name": "kw_variadic", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("variadic") },
              { "name": "kw_action", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("action") },
              { "name": "kw_restrict", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("restrict") },
              { "name": "kw_truncate", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("truncate") },
              { "name": "kw_increment", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("increment") },
              { "name": "kw_by", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("by") },
              { "name": "kw_row", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("row") },
              { "name": "kw_rows", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("rows") },
              { "name": "kw_next", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("next") },
              { "name": "kw_match", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("match") },
              { "name": "kw_replace", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("replace") },
              { "name": "kw_recursive", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("recursive") },
              { "name": "kw_view", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("view") },
              { "name": "kw_cascaded", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("cascaded") },
              { "name": "kw_unlogged", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("unlogged") },
              { "name": "kw_global", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("global") },
              { "name": "kw_option", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("option") },
              { "name": "kw_materialized", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("materialized") },
              { "name": "kw_partial", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("partial") },
              { "name": "kw_partition", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("partition") },
              { "name": "kw_simple", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("simple") },
              { "name": "kw_generated", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("generated") },
              { "name": "kw_always", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("always") },
              { "name": "kw_identity", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("identity") },
              { "name": "kw_name", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("name") },
              { "name": "kw_enum", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("enum") },
              { "name": "kw_show", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("show") },
              { "name": "kw_ordinality", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("ordinality") },
              { "name": "kw_overriding", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("overriding") },
              { "name": "kw_over", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("over") },
              { "name": "kw_system", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("system") },
              { "name": "kw_comment", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("comment") },
              { "name": "kw_time", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("time") },
              { "name": "kw_at", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("at") },
              { "name": "kw_zone", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("zone") },
              { "name": "kw_interval", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("interval") },
              { "name": "kw_hour", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("hour") },
              { "name": "kw_minute", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("minute") },
              { "name": "kw_local", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("local") },
              { "name": "kw_prepare", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("prepare") },
              { "name": "kw_deallocate", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("deallocate") },
              { "name": "kw_raise", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("raise") },
              { "name": "kw_continue", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("continue") },
              { "name": "kw_share", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("share") },
              { "name": "kw_refresh", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("refresh") },
              { "name": "kw_nowait", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("nowait") },
              { "name": "kw_skip", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("skip") },
              { "name": "kw_locked", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": notReservedKw("locked") },
              { "name": "kw_ifnotexists", "symbols": ["kw_if", lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not, "kw_exists"] },
              { "name": "kw_ifexists", "symbols": ["kw_if", "kw_exists"] },
              { "name": "kw_withordinality", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "kw_ordinality"] },
              { "name": "kw_not_null", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not, lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "kw_primary_key", "symbols": [lexer_1.lexerAny.has("kw_primary") ? { type: "kw_primary" } : kw_primary, "kw_key"] },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$2", "symbols": ["int"] },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "data_type$ebnf$1$subexpression$1$macrocall$2"], "postprocess": last3 },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "symbols": ["data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1", "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "data_type$ebnf$1$subexpression$1$macrocall$1", "symbols": ["data_type$ebnf$1$subexpression$1$macrocall$2", "data_type$ebnf$1$subexpression$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "data_type$ebnf$1$subexpression$1", "symbols": ["lparen", "data_type$ebnf$1$subexpression$1$macrocall$1", "rparen"], "postprocess": get11(1) },
              { "name": "data_type$ebnf$1", "symbols": ["data_type$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "data_type$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "data_type$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$1"] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket] },
              { "name": "data_type$ebnf$2$subexpression$1$ebnf$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1", "data_type$ebnf$2$subexpression$1$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "data_type$ebnf$2$subexpression$1", "symbols": ["data_type$ebnf$2$subexpression$1$ebnf$1"] },
              { "name": "data_type$ebnf$2", "symbols": ["data_type$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "data_type$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "data_type", "symbols": ["data_type_simple", "data_type$ebnf$1", "data_type$ebnf$2"], "postprocess": (x) => {
                let asArray = x[2];
                const name = unwrap(x[0]);
                let ret;
                ret = {
                  ...name,
                  ...Array.isArray(x[1]) && x[1].length ? { config: x[1].map(unwrap) } : {}
                };
                if (asArray) {
                  if (asArray[0].type === "kw_array") {
                    asArray = [["array"]];
                  }
                  for (const _ of asArray[0]) {
                    ret = {
                      kind: "array",
                      arrayOf: ret
                    };
                  }
                }
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "data_type_list$ebnf$1", "symbols": [] },
              { "name": "data_type_list$ebnf$1$subexpression$1", "symbols": ["comma", "data_type"], "postprocess": last3 },
              { "name": "data_type_list$ebnf$1", "symbols": ["data_type_list$ebnf$1", "data_type_list$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "data_type_list", "symbols": ["data_type", "data_type_list$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "data_type_simple", "symbols": ["data_type_text"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x, " ") }) },
              { "name": "data_type_simple", "symbols": ["data_type_numeric"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x, " ") }) },
              { "name": "data_type_simple", "symbols": ["data_type_date"] },
              { "name": "data_type_simple", "symbols": ["qualified_name_mark_quotes"] },
              { "name": "data_type_numeric$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("double") },
              { "name": "data_type_numeric", "symbols": ["data_type_numeric$subexpression$1", lexer_1.lexerAny.has("kw_precision") ? { type: "kw_precision" } : kw_precision] },
              { "name": "data_type_text$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("character", "bit") },
              { "name": "data_type_text$subexpression$2", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("varying") },
              { "name": "data_type_text", "symbols": ["data_type_text$subexpression$1", "data_type_text$subexpression$2"] },
              { "name": "data_type_date$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("timestamp", "time") },
              { "name": "data_type_date$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with] },
              { "name": "data_type_date$subexpression$2", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("without") },
              { "name": "data_type_date$subexpression$3", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("time") },
              { "name": "data_type_date$subexpression$4", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("zone") },
              { "name": "data_type_date", "symbols": ["data_type_date$subexpression$1", "data_type_date$subexpression$2", "data_type_date$subexpression$3", "data_type_date$subexpression$4"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x, " ") }) },
              { "name": "data_type_date$subexpression$5", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("timestamp", "time") },
              { "name": "data_type_date$subexpression$6", "symbols": ["lparen", "int", "rparen"], "postprocess": get11(1) },
              { "name": "data_type_date$subexpression$7", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with] },
              { "name": "data_type_date$subexpression$7", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("without") },
              { "name": "data_type_date$subexpression$8", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("time") },
              { "name": "data_type_date$subexpression$9", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": kw("zone") },
              { "name": "data_type_date", "symbols": ["data_type_date$subexpression$5", "data_type_date$subexpression$6", "data_type_date$subexpression$7", "data_type_date$subexpression$8", "data_type_date$subexpression$9"], "postprocess": (x) => (0, lexer_2.track)(x, { name: `timestamp ${toStr(x[2])} time zone`, config: [(0, lexer_2.unbox)(x[1])] }) },
              { "name": "ident_aliased$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "ident"], "postprocess": last3 },
              { "name": "ident_aliased", "symbols": ["ident_aliased$subexpression$1"] },
              { "name": "ident_aliased", "symbols": ["ident"], "postprocess": unwrap },
              { "name": "table_ref", "symbols": ["qualified_name"], "postprocess": unwrap },
              { "name": "qcolumn$ebnf$1$subexpression$1", "symbols": ["dot", "ident"], "postprocess": last3 },
              { "name": "qcolumn$ebnf$1", "symbols": ["qcolumn$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "qcolumn$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "qcolumn", "symbols": ["ident", "dot", "ident", "qcolumn$ebnf$1"], "postprocess": (x) => {
                if (!x[3]) {
                  return (0, lexer_2.track)(x, {
                    table: (0, lexer_2.unbox)(x[0]),
                    column: (0, lexer_2.unbox)(x[2])
                  });
                }
                return (0, lexer_2.track)(x, {
                  schema: (0, lexer_2.unbox)(x[0]),
                  table: (0, lexer_2.unbox)(x[2]),
                  column: (0, lexer_2.unbox)(x[3])
                });
              } },
              { "name": "table_ref_aliased$ebnf$1", "symbols": ["ident_aliased"], "postprocess": id },
              { "name": "table_ref_aliased$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "table_ref_aliased", "symbols": ["table_ref", "table_ref_aliased$ebnf$1"], "postprocess": (x) => {
                const alias = unwrap(x[1]);
                return (0, lexer_2.track)(x, {
                  ...unwrap(x[0]),
                  ...alias ? { alias } : {}
                });
              } },
              { "name": "qualified_name", "symbols": ["qname_ident"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x) }) },
              { "name": "qualified_name", "symbols": ["ident", "dot", "ident_extended"], "postprocess": (x) => {
                const schema2 = toStr(x[0]);
                const name = toStr(x[2]);
                return (0, lexer_2.track)(x, { schema: schema2, name });
              } },
              { "name": "qualified_name", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema], "postprocess": (x) => (0, lexer_2.track)(x, { name: "current_schema" }) },
              { "name": "qualified_name_mark_quotes", "symbols": ["qname_ident"], "postprocess": (x) => (0, lexer_2.track)(x, { name: toStr(x), ...(0, lexer_2.doubleQuoted)(x) }) },
              { "name": "qualified_name_mark_quotes", "symbols": ["ident", "dot", "ident_extended"], "postprocess": (x) => {
                const schema2 = toStr(x[0]);
                const name = toStr(x[2]);
                return (0, lexer_2.track)(x, { schema: schema2, name, ...(0, lexer_2.doubleQuoted)(x[2]) });
              } },
              { "name": "qualified_name_mark_quotes", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema], "postprocess": (x) => (0, lexer_2.track)(x, { name: "current_schema" }) },
              { "name": "qname_ident", "symbols": ["ident"] },
              { "name": "qname_ident", "symbols": [lexer_1.lexerAny.has("kw_precision") ? { type: "kw_precision" } : kw_precision] },
              { "name": "qname", "symbols": ["qualified_name"], "postprocess": unwrap },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_analyse") ? { type: "kw_analyse" } : kw_analyse] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_analyze") ? { type: "kw_analyze" } : kw_analyze] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_and") ? { type: "kw_and" } : kw_and] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_any") ? { type: "kw_any" } : kw_any] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_asc") ? { type: "kw_asc" } : kw_asc] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_asymmetric") ? { type: "kw_asymmetric" } : kw_asymmetric] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_authorization") ? { type: "kw_authorization" } : kw_authorization] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_binary") ? { type: "kw_binary" } : kw_binary] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_both") ? { type: "kw_both" } : kw_both] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_case") ? { type: "kw_case" } : kw_case] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_cast") ? { type: "kw_cast" } : kw_cast] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_collate") ? { type: "kw_collate" } : kw_collate] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_collation") ? { type: "kw_collation" } : kw_collation] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_concurrently") ? { type: "kw_concurrently" } : kw_concurrently] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_cross") ? { type: "kw_cross" } : kw_cross] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_catalog") ? { type: "kw_current_catalog" } : kw_current_catalog] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_date") ? { type: "kw_current_date" } : kw_current_date] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_role") ? { type: "kw_current_role" } : kw_current_role] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_time") ? { type: "kw_current_time" } : kw_current_time] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_timestamp") ? { type: "kw_current_timestamp" } : kw_current_timestamp] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_user") ? { type: "kw_current_user" } : kw_current_user] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_deferrable") ? { type: "kw_deferrable" } : kw_deferrable] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_desc") ? { type: "kw_desc" } : kw_desc] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_distinct") ? { type: "kw_distinct" } : kw_distinct] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_else") ? { type: "kw_else" } : kw_else] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_end") ? { type: "kw_end" } : kw_end] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_except") ? { type: "kw_except" } : kw_except] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_fetch") ? { type: "kw_fetch" } : kw_fetch] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_foreign") ? { type: "kw_foreign" } : kw_foreign] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_freeze") ? { type: "kw_freeze" } : kw_freeze] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_full") ? { type: "kw_full" } : kw_full] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_grant") ? { type: "kw_grant" } : kw_grant] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_group") ? { type: "kw_group" } : kw_group] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_having") ? { type: "kw_having" } : kw_having] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_ilike") ? { type: "kw_ilike" } : kw_ilike] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_in") ? { type: "kw_in" } : kw_in] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_initially") ? { type: "kw_initially" } : kw_initially] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_inner") ? { type: "kw_inner" } : kw_inner] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_intersect") ? { type: "kw_intersect" } : kw_intersect] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_into") ? { type: "kw_into" } : kw_into] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_isnull") ? { type: "kw_isnull" } : kw_isnull] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_join") ? { type: "kw_join" } : kw_join] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_lateral") ? { type: "kw_lateral" } : kw_lateral] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_leading") ? { type: "kw_leading" } : kw_leading] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_left") ? { type: "kw_left" } : kw_left] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_like") ? { type: "kw_like" } : kw_like] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_limit") ? { type: "kw_limit" } : kw_limit] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtime") ? { type: "kw_localtime" } : kw_localtime] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtimestamp") ? { type: "kw_localtimestamp" } : kw_localtimestamp] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_natural") ? { type: "kw_natural" } : kw_natural] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_notnull") ? { type: "kw_notnull" } : kw_notnull] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_offset") ? { type: "kw_offset" } : kw_offset] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_order") ? { type: "kw_order" } : kw_order] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_overlaps") ? { type: "kw_overlaps" } : kw_overlaps] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_placing") ? { type: "kw_placing" } : kw_placing] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_primary") ? { type: "kw_primary" } : kw_primary] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_references") ? { type: "kw_references" } : kw_references] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_right") ? { type: "kw_right" } : kw_right] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_select") ? { type: "kw_select" } : kw_select] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_session_user") ? { type: "kw_session_user" } : kw_session_user] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_similar") ? { type: "kw_similar" } : kw_similar] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_some") ? { type: "kw_some" } : kw_some] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_symmetric") ? { type: "kw_symmetric" } : kw_symmetric] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_tablesample") ? { type: "kw_tablesample" } : kw_tablesample] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_then") ? { type: "kw_then" } : kw_then] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_trailing") ? { type: "kw_trailing" } : kw_trailing] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_union") ? { type: "kw_union" } : kw_union] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_user") ? { type: "kw_user" } : kw_user] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_variadic") ? { type: "kw_variadic" } : kw_variadic] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_verbose") ? { type: "kw_verbose" } : kw_verbose] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_when") ? { type: "kw_when" } : kw_when] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_window") ? { type: "kw_window" } : kw_window] },
              { "name": "any_keyword", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with] },
              { "name": "ident_extended", "symbols": ["ident"] },
              { "name": "ident_extended", "symbols": ["any_keyword"] },
              { "name": "select_statement$ebnf$1", "symbols": ["select_from"], "postprocess": id },
              { "name": "select_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$2", "symbols": ["select_where"], "postprocess": id },
              { "name": "select_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$3$subexpression$1$ebnf$1", "symbols": ["select_having"], "postprocess": id },
              { "name": "select_statement$ebnf$3$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$3$subexpression$1", "symbols": ["select_groupby", "select_statement$ebnf$3$subexpression$1$ebnf$1"] },
              { "name": "select_statement$ebnf$3", "symbols": ["select_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "select_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$4", "symbols": ["select_order_by"], "postprocess": id },
              { "name": "select_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$5", "symbols": ["select_limit_offset"], "postprocess": id },
              { "name": "select_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$6$subexpression$1$ebnf$1", "symbols": ["select_skip"], "postprocess": id },
              { "name": "select_statement$ebnf$6$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_statement$ebnf$6$subexpression$1", "symbols": ["select_for", "select_statement$ebnf$6$subexpression$1$ebnf$1"] },
              { "name": "select_statement$ebnf$6", "symbols": ["select_statement$ebnf$6$subexpression$1"], "postprocess": id },
              { "name": "select_statement$ebnf$6", "symbols": [], "postprocess": () => null },
              { "name": "select_statement", "symbols": ["select_what", "select_statement$ebnf$1", "select_statement$ebnf$2", "select_statement$ebnf$3", "select_statement$ebnf$4", "select_statement$ebnf$5", "select_statement$ebnf$6"], "postprocess": (x) => {
                let [what, from, where, _groupBy, orderBy, limit, _selectFor] = x;
                from = unwrap(from);
                let groupBy2 = _groupBy && _groupBy[0];
                let having = _groupBy && _groupBy[1];
                groupBy2 = groupBy2 && (groupBy2.length === 1 && groupBy2[0].type === "list" ? groupBy2[0].expressions : groupBy2);
                having = having && unwrap(having);
                let selectFor = _selectFor && _selectFor[0];
                let skip2 = _selectFor && _selectFor[1];
                skip2 = unwrap(skip2);
                return (0, lexer_2.track)(x, {
                  ...what,
                  ...from ? { from: Array.isArray(from) ? from : [from] } : {},
                  ...groupBy2 ? { groupBy: groupBy2 } : {},
                  ...having ? { having } : {},
                  ...limit ? { limit: unwrap(limit) } : {},
                  ...orderBy ? { orderBy } : {},
                  ...where ? { where } : {},
                  ...selectFor ? { for: selectFor[1] } : {},
                  ...skip2 ? { skip: skip2 } : {},
                  type: "select"
                });
              } },
              { "name": "select_from", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "select_from_items"], "postprocess": last3 },
              { "name": "select_from_items$ebnf$1", "symbols": [] },
              { "name": "select_from_items$ebnf$1$subexpression$1", "symbols": ["comma", "select_from_item"], "postprocess": last3 },
              { "name": "select_from_items$ebnf$1", "symbols": ["select_from_items$ebnf$1", "select_from_items$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_from_items", "symbols": ["select_from_item", "select_from_items$ebnf$1"], "postprocess": ([head, tail]) => {
                return [...head, ...flatten3(tail) || []];
              } },
              { "name": "select_from_item", "symbols": ["select_from_subject"] },
              { "name": "select_from_item", "symbols": ["select_from_item_joins"], "postprocess": get11(0) },
              { "name": "select_from_item_joins$subexpression$1", "symbols": ["select_from_item"], "postprocess": get11(0) },
              { "name": "select_from_item_joins", "symbols": ["select_from_item_joins$subexpression$1", "select_table_join"], "postprocess": flatten3 },
              { "name": "select_from_item_joins", "symbols": ["lparen", "select_from_item_joins", "rparen"], "postprocess": get11(1) },
              { "name": "select_from_subject", "symbols": ["stb_table"], "postprocess": unwrap },
              { "name": "select_from_subject", "symbols": ["stb_statement"], "postprocess": unwrap },
              { "name": "select_from_subject", "symbols": ["stb_call"], "postprocess": unwrap },
              { "name": "stb_opts$ebnf$1", "symbols": ["collist_paren"], "postprocess": id },
              { "name": "stb_opts$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_opts", "symbols": ["ident_aliased", "stb_opts$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                alias: toStr(x[0]),
                ...x[1] && { columnNames: (0, lexer_2.unbox)(x[1]).map(asName) }
              }) },
              { "name": "stb_table$ebnf$1", "symbols": ["stb_opts"], "postprocess": id },
              { "name": "stb_table$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_table", "symbols": ["table_ref", "stb_table$ebnf$1"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "table",
                  name: (0, lexer_2.track)(x, {
                    ...x[0],
                    ...x[1]
                  })
                });
              } },
              { "name": "stb_statement", "symbols": ["selection_paren", "stb_opts"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "statement",
                statement: unwrap(x[0]),
                ...x[1]
              }) },
              { "name": "select_values", "symbols": ["kw_values", "insert_values"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "values",
                values: x[1]
              }) },
              { "name": "stb_call$ebnf$1", "symbols": ["kw_withordinality"], "postprocess": id },
              { "name": "stb_call$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_call$ebnf$2", "symbols": ["stb_call_alias"], "postprocess": id },
              { "name": "stb_call$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "stb_call", "symbols": ["expr_function_call", "stb_call$ebnf$1", "stb_call$ebnf$2"], "postprocess": (x) => {
                const withOrdinality = x[1];
                const alias = x[2];
                if (!withOrdinality && !alias) {
                  return x[0];
                }
                return (0, lexer_2.track)(x, {
                  ...x[0],
                  ...withOrdinality && { withOrdinality: true },
                  alias: alias ? asNameWithColumns(alias[0], alias[1]) : void 0
                });
              } },
              { "name": "stb_call_alias$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as], "postprocess": id },
              { "name": "stb_call_alias$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_call_alias$subexpression$1", "symbols": ["stb_call_alias$subexpression$1$ebnf$1", "ident"], "postprocess": last3 },
              { "name": "stb_call_alias$ebnf$1", "symbols": ["stb_call_alias_list"], "postprocess": id },
              { "name": "stb_call_alias$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "stb_call_alias", "symbols": ["stb_call_alias$subexpression$1", "stb_call_alias$ebnf$1"] },
              { "name": "stb_call_alias_list", "symbols": ["lparen", "stb_call_alias_list_raw", "rparen"], "postprocess": get11(1) },
              { "name": "stb_call_alias_list_raw$ebnf$1", "symbols": [] },
              { "name": "stb_call_alias_list_raw$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last3 },
              { "name": "stb_call_alias_list_raw$ebnf$1", "symbols": ["stb_call_alias_list_raw$ebnf$1", "stb_call_alias_list_raw$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "stb_call_alias_list_raw", "symbols": ["ident", "stb_call_alias_list_raw$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "select_table_join$ebnf$1", "symbols": ["select_table_join_clause"], "postprocess": id },
              { "name": "select_table_join$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_table_join", "symbols": ["select_join_op", lexer_1.lexerAny.has("kw_join") ? { type: "kw_join" } : kw_join, "select_from_subject", "select_table_join$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                ...unwrap(x[2]),
                join: {
                  type: toStr(x[0], " "),
                  ...x[3] && unwrap(x[3])
                }
              }) },
              { "name": "select_table_join_clause", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, { on: last3(x) }) },
              { "name": "select_table_join_clause$macrocall$2", "symbols": ["ident"] },
              { "name": "select_table_join_clause$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "select_table_join_clause$macrocall$2"], "postprocess": last3 },
              { "name": "select_table_join_clause$macrocall$1$ebnf$1", "symbols": ["select_table_join_clause$macrocall$1$ebnf$1", "select_table_join_clause$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_table_join_clause$macrocall$1", "symbols": ["select_table_join_clause$macrocall$2", "select_table_join_clause$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "select_table_join_clause", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using, "lparen", "select_table_join_clause$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, { using: x[2].map(asName) }) },
              { "name": "select_join_op$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_inner") ? { type: "kw_inner" } : kw_inner], "postprocess": id },
              { "name": "select_join_op$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$1", "symbols": ["select_join_op$subexpression$1$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "INNER JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$1"] },
              { "name": "select_join_op$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_cross") ? { type: "kw_cross" } : kw_cross], "postprocess": (x) => (0, lexer_2.box)(x, "CROSS JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$2"] },
              { "name": "select_join_op$subexpression$3$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer], "postprocess": id },
              { "name": "select_join_op$subexpression$3$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$3", "symbols": [lexer_1.lexerAny.has("kw_left") ? { type: "kw_left" } : kw_left, "select_join_op$subexpression$3$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "LEFT JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$3"] },
              { "name": "select_join_op$subexpression$4$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer], "postprocess": id },
              { "name": "select_join_op$subexpression$4$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_right") ? { type: "kw_right" } : kw_right, "select_join_op$subexpression$4$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "RIGHT JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$4"] },
              { "name": "select_join_op$subexpression$5$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_outer") ? { type: "kw_outer" } : kw_outer], "postprocess": id },
              { "name": "select_join_op$subexpression$5$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_join_op$subexpression$5", "symbols": [lexer_1.lexerAny.has("kw_full") ? { type: "kw_full" } : kw_full, "select_join_op$subexpression$5$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, "FULL JOIN") },
              { "name": "select_join_op", "symbols": ["select_join_op$subexpression$5"] },
              { "name": "select_what$ebnf$1", "symbols": ["select_distinct"], "postprocess": id },
              { "name": "select_what$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_what$ebnf$2", "symbols": ["select_expr_list_aliased"], "postprocess": id },
              { "name": "select_what$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "select_what", "symbols": [lexer_1.lexerAny.has("kw_select") ? { type: "kw_select" } : kw_select, "select_what$ebnf$1", "select_what$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                columns: x[2],
                ...x[1] && { distinct: (0, lexer_2.unbox)(x[1]) }
              }) },
              { "name": "select_expr_list_aliased$ebnf$1", "symbols": [] },
              { "name": "select_expr_list_aliased$ebnf$1$subexpression$1", "symbols": ["comma", "select_expr_list_item"], "postprocess": last3 },
              { "name": "select_expr_list_aliased$ebnf$1", "symbols": ["select_expr_list_aliased$ebnf$1", "select_expr_list_aliased$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_expr_list_aliased", "symbols": ["select_expr_list_item", "select_expr_list_aliased$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "select_expr_list_item$ebnf$1", "symbols": ["ident_aliased"], "postprocess": id },
              { "name": "select_expr_list_item$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_expr_list_item", "symbols": ["expr", "select_expr_list_item$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                expr: x[0],
                ...x[1] ? { alias: asName(x[1]) } : {}
              }) },
              { "name": "select_distinct", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all], "postprocess": (x) => (0, lexer_2.box)(x, "all") },
              { "name": "select_distinct$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "lparen", "expr_list_raw", "rparen"], "postprocess": get11(2) },
              { "name": "select_distinct$ebnf$1", "symbols": ["select_distinct$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_distinct$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_distinct", "symbols": [lexer_1.lexerAny.has("kw_distinct") ? { type: "kw_distinct" } : kw_distinct, "select_distinct$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, x[1] || "distinct") },
              { "name": "select_where", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr"], "postprocess": last3 },
              { "name": "select_groupby", "symbols": [lexer_1.lexerAny.has("kw_group") ? { type: "kw_group" } : kw_group, "kw_by", "expr_list_raw"], "postprocess": last3 },
              { "name": "select_having", "symbols": [lexer_1.lexerAny.has("kw_having") ? { type: "kw_having" } : kw_having, "expr"], "postprocess": last3 },
              { "name": "select_limit_offset$ebnf$1$subexpression$1", "symbols": ["select_offset"] },
              { "name": "select_limit_offset$ebnf$1$subexpression$1", "symbols": ["select_limit"] },
              { "name": "select_limit_offset$ebnf$1", "symbols": ["select_limit_offset$ebnf$1$subexpression$1"] },
              { "name": "select_limit_offset$ebnf$1$subexpression$2", "symbols": ["select_offset"] },
              { "name": "select_limit_offset$ebnf$1$subexpression$2", "symbols": ["select_limit"] },
              { "name": "select_limit_offset$ebnf$1", "symbols": ["select_limit_offset$ebnf$1", "select_limit_offset$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_limit_offset", "symbols": ["select_limit_offset$ebnf$1"], "postprocess": (x, rej) => {
                const value3 = unwrap(x);
                if (!Array.isArray(value3)) {
                  return (0, lexer_2.track)(x, value3);
                }
                if (value3.length != 2) {
                  return rej;
                }
                const a = unwrap(value3[0]);
                const b = unwrap(value3[1]);
                if (a.offset && b.offset || a.limit && b.limit) {
                  return rej;
                }
                return (0, lexer_2.track)(x, {
                  ...a,
                  ...b
                });
              } },
              { "name": "select_offset$ebnf$1$subexpression$1", "symbols": ["kw_row"] },
              { "name": "select_offset$ebnf$1$subexpression$1", "symbols": ["kw_rows"] },
              { "name": "select_offset$ebnf$1", "symbols": ["select_offset$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_offset$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_offset", "symbols": [lexer_1.lexerAny.has("kw_offset") ? { type: "kw_offset" } : kw_offset, "expr_nostar", "select_offset$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, { offset: unwrap(x[1]) }) },
              { "name": "select_limit$subexpression$1", "symbols": ["select_limit_1"] },
              { "name": "select_limit$subexpression$1", "symbols": ["select_limit_2"] },
              { "name": "select_limit", "symbols": ["select_limit$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { limit: unwrap(x) }) },
              { "name": "select_limit_1", "symbols": [lexer_1.lexerAny.has("kw_limit") ? { type: "kw_limit" } : kw_limit, "expr_nostar"], "postprocess": last3 },
              { "name": "select_limit_2$ebnf$1$subexpression$1", "symbols": ["kw_first"] },
              { "name": "select_limit_2$ebnf$1$subexpression$1", "symbols": ["kw_next"] },
              { "name": "select_limit_2$ebnf$1", "symbols": ["select_limit_2$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_limit_2$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_limit_2$subexpression$1", "symbols": ["kw_row"] },
              { "name": "select_limit_2$subexpression$1", "symbols": ["kw_rows"] },
              { "name": "select_limit_2", "symbols": [lexer_1.lexerAny.has("kw_fetch") ? { type: "kw_fetch" } : kw_fetch, "select_limit_2$ebnf$1", "expr_nostar", "select_limit_2$subexpression$1", lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only], "postprocess": get11(2) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_update"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "update" }) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_no", "kw_key", "kw_update"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "no key update" }) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_share"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "share" }) },
              { "name": "select_for$subexpression$1", "symbols": ["kw_key", "kw_share"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "key share" }) },
              { "name": "select_for", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for, "select_for$subexpression$1"] },
              { "name": "select_skip$subexpression$1", "symbols": ["kw_nowait"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "nowait" }) },
              { "name": "select_skip$subexpression$1", "symbols": ["kw_skip", "kw_locked"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "skip locked" }) },
              { "name": "select_skip", "symbols": ["select_skip$subexpression$1"] },
              { "name": "select_order_by$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_order") ? { type: "kw_order" } : kw_order, "kw_by"] },
              { "name": "select_order_by$ebnf$1", "symbols": [] },
              { "name": "select_order_by$ebnf$1$subexpression$1", "symbols": ["comma", "select_order_by_expr"], "postprocess": last3 },
              { "name": "select_order_by$ebnf$1", "symbols": ["select_order_by$ebnf$1", "select_order_by$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "select_order_by", "symbols": ["select_order_by$subexpression$1", "select_order_by_expr", "select_order_by$ebnf$1"], "postprocess": ([_, head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "select_order_by_expr$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_asc") ? { type: "kw_asc" } : kw_asc] },
              { "name": "select_order_by_expr$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_desc") ? { type: "kw_desc" } : kw_desc] },
              { "name": "select_order_by_expr$ebnf$1", "symbols": ["select_order_by_expr$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "select_order_by_expr$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_first"] },
              { "name": "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_last"] },
              { "name": "select_order_by_expr$ebnf$2$subexpression$1", "symbols": ["kw_nulls", "select_order_by_expr$ebnf$2$subexpression$1$subexpression$1"], "postprocess": last3 },
              { "name": "select_order_by_expr$ebnf$2", "symbols": ["select_order_by_expr$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "select_order_by_expr$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "select_order_by_expr", "symbols": ["expr", "select_order_by_expr$ebnf$1", "select_order_by_expr$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                by: x[0],
                ...x[1] && { order: toStr(x[1]).toUpperCase() },
                ...x[2] && { nulls: toStr(x[2]).toUpperCase() }
              }) },
              { "name": "expr", "symbols": ["expr_nostar"], "postprocess": unwrap },
              { "name": "expr", "symbols": ["expr_star"], "postprocess": unwrap },
              { "name": "expr_nostar", "symbols": ["expr_paren"], "postprocess": unwrap },
              { "name": "expr_nostar", "symbols": ["expr_or"], "postprocess": unwrap },
              { "name": "expr_paren$subexpression$1", "symbols": ["expr_or_select"] },
              { "name": "expr_paren$subexpression$1", "symbols": ["expr_list_many"] },
              { "name": "expr_paren", "symbols": ["lparen", "expr_paren$subexpression$1", "rparen"], "postprocess": get11(1) },
              { "name": "expr_or$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or] },
              { "name": "expr_or$macrocall$2$macrocall$1", "symbols": ["expr_or$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_or$macrocall$2", "symbols": ["expr_or$macrocall$2$macrocall$1"] },
              { "name": "expr_or$macrocall$3", "symbols": ["expr_or"] },
              { "name": "expr_or$macrocall$4", "symbols": ["expr_and"] },
              { "name": "expr_or$macrocall$1$subexpression$1", "symbols": ["expr_or$macrocall$3"] },
              { "name": "expr_or$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_or$macrocall$1$subexpression$2", "symbols": ["expr_or$macrocall$4"] },
              { "name": "expr_or$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_or$macrocall$1", "symbols": ["expr_or$macrocall$1$subexpression$1", "expr_or$macrocall$2", "expr_or$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_or$macrocall$1", "symbols": ["expr_or$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_or", "symbols": ["expr_or$macrocall$1"] },
              { "name": "expr_and$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("kw_and") ? { type: "kw_and" } : kw_and] },
              { "name": "expr_and$macrocall$2$macrocall$1", "symbols": ["expr_and$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_and$macrocall$2", "symbols": ["expr_and$macrocall$2$macrocall$1"] },
              { "name": "expr_and$macrocall$3", "symbols": ["expr_and"] },
              { "name": "expr_and$macrocall$4", "symbols": ["expr_not"] },
              { "name": "expr_and$macrocall$1$subexpression$1", "symbols": ["expr_and$macrocall$3"] },
              { "name": "expr_and$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_and$macrocall$1$subexpression$2", "symbols": ["expr_and$macrocall$4"] },
              { "name": "expr_and$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_and$macrocall$1", "symbols": ["expr_and$macrocall$1$subexpression$1", "expr_and$macrocall$2", "expr_and$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_and$macrocall$1", "symbols": ["expr_and$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_and", "symbols": ["expr_and$macrocall$1"] },
              { "name": "expr_not$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not] },
              { "name": "expr_not$macrocall$2$macrocall$1", "symbols": ["expr_not$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_not$macrocall$2", "symbols": ["expr_not$macrocall$2$macrocall$1"] },
              { "name": "expr_not$macrocall$3", "symbols": ["expr_not"] },
              { "name": "expr_not$macrocall$4", "symbols": ["expr_eq"] },
              { "name": "expr_not$macrocall$1$subexpression$1", "symbols": ["expr_not$macrocall$3"] },
              { "name": "expr_not$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_not$macrocall$1", "symbols": ["expr_not$macrocall$2", "expr_not$macrocall$1$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "unary",
                ...unwrap(x[0]),
                operand: unwrap(x[1])
              }) },
              { "name": "expr_not$macrocall$1", "symbols": ["expr_not$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_not", "symbols": ["expr_not$macrocall$1"] },
              { "name": "expr_eq$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq] },
              { "name": "expr_eq$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_neq") ? { type: "op_neq" } : op_neq] },
              { "name": "expr_eq$macrocall$2$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_eq$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$2"] },
              { "name": "expr_eq$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_eq$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_eq$macrocall$2$macrocall$1", "symbols": ["expr_eq$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_eq$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_eq$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_eq$macrocall$2", "symbols": ["expr_eq$macrocall$2$macrocall$1"] },
              { "name": "expr_eq$macrocall$3", "symbols": ["expr_eq"] },
              { "name": "expr_eq$macrocall$4", "symbols": ["expr_is"] },
              { "name": "expr_eq$macrocall$1$subexpression$1", "symbols": ["expr_eq$macrocall$3"] },
              { "name": "expr_eq$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_eq$macrocall$1$subexpression$2", "symbols": ["expr_eq$macrocall$4"] },
              { "name": "expr_eq$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_eq$macrocall$1", "symbols": ["expr_eq$macrocall$1$subexpression$1", "expr_eq$macrocall$2", "expr_eq$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_eq$macrocall$1", "symbols": ["expr_eq$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_eq", "symbols": ["expr_eq$macrocall$1"] },
              { "name": "expr_star", "symbols": ["star"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "ref", name: "*" }) },
              { "name": "expr_is$subexpression$1", "symbols": ["expr_is"] },
              { "name": "expr_is$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_is$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_isnull") ? { type: "kw_isnull" } : kw_isnull] },
              { "name": "expr_is$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "expr_is", "symbols": ["expr_is$subexpression$1", "expr_is$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "unary", op: "IS NULL", operand: unwrap(x[0]) }) },
              { "name": "expr_is$subexpression$3", "symbols": ["expr_is"] },
              { "name": "expr_is$subexpression$3", "symbols": ["expr_paren"] },
              { "name": "expr_is$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_notnull") ? { type: "kw_notnull" } : kw_notnull] },
              { "name": "expr_is$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, "kw_not_null"] },
              { "name": "expr_is", "symbols": ["expr_is$subexpression$3", "expr_is$subexpression$4"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "unary", op: "IS NOT NULL", operand: unwrap(x[0]) }) },
              { "name": "expr_is$subexpression$5", "symbols": ["expr_is"] },
              { "name": "expr_is$subexpression$5", "symbols": ["expr_paren"] },
              { "name": "expr_is$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "expr_is$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_is$subexpression$6", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true] },
              { "name": "expr_is$subexpression$6", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false] },
              { "name": "expr_is", "symbols": ["expr_is$subexpression$5", lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, "expr_is$ebnf$1", "expr_is$subexpression$6"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "unary",
                op: "IS " + flattenStr([x[2], x[3]]).join(" ").toUpperCase(),
                operand: unwrap(x[0])
              }) },
              { "name": "expr_is", "symbols": ["expr_compare"], "postprocess": unwrap },
              { "name": "expr_compare$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("op_compare") ? { type: "op_compare" } : op_compare] },
              { "name": "expr_compare$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_compare$macrocall$2$macrocall$2"] },
              { "name": "expr_compare$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_compare$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_compare$macrocall$2$macrocall$1", "symbols": ["expr_compare$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_compare$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_compare$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_compare$macrocall$2", "symbols": ["expr_compare$macrocall$2$macrocall$1"] },
              { "name": "expr_compare$macrocall$3", "symbols": ["expr_compare"] },
              { "name": "expr_compare$macrocall$4", "symbols": ["expr_range"] },
              { "name": "expr_compare$macrocall$1$subexpression$1", "symbols": ["expr_compare$macrocall$3"] },
              { "name": "expr_compare$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_compare$macrocall$1$subexpression$2", "symbols": ["expr_compare$macrocall$4"] },
              { "name": "expr_compare$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_compare$macrocall$1", "symbols": ["expr_compare$macrocall$1$subexpression$1", "expr_compare$macrocall$2", "expr_compare$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_compare$macrocall$1", "symbols": ["expr_compare$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_compare", "symbols": ["expr_compare$macrocall$1"] },
              { "name": "expr_range$macrocall$2", "symbols": ["ops_between"] },
              { "name": "expr_range$macrocall$3", "symbols": [lexer_1.lexerAny.has("kw_and") ? { type: "kw_and" } : kw_and] },
              { "name": "expr_range$macrocall$4", "symbols": ["expr_range"] },
              { "name": "expr_range$macrocall$5", "symbols": ["expr_others"] },
              { "name": "expr_range$macrocall$1$subexpression$1", "symbols": ["expr_range$macrocall$4"] },
              { "name": "expr_range$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_range$macrocall$1$subexpression$2", "symbols": ["expr_range$macrocall$4"] },
              { "name": "expr_range$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_range$macrocall$1$subexpression$3", "symbols": ["expr_range$macrocall$5"] },
              { "name": "expr_range$macrocall$1$subexpression$3", "symbols": ["expr_paren"] },
              { "name": "expr_range$macrocall$1", "symbols": ["expr_range$macrocall$1$subexpression$1", "expr_range$macrocall$2", "expr_range$macrocall$1$subexpression$2", "expr_range$macrocall$3", "expr_range$macrocall$1$subexpression$3"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "ternary",
                value: unwrap(x[0]),
                lo: unwrap(x[2]),
                hi: unwrap(x[4]),
                op: (flattenStr(x[1]).join(" ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_range$macrocall$1", "symbols": ["expr_range$macrocall$5"], "postprocess": unwrap },
              { "name": "expr_range", "symbols": ["expr_range$macrocall$1"] },
              { "name": "expr_others$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("ops_others") ? { type: "ops_others" } : ops_others] },
              { "name": "expr_others$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_others$macrocall$2$macrocall$2"] },
              { "name": "expr_others$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_others$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_others$macrocall$2$macrocall$1", "symbols": ["expr_others$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_others$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_others$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_others$macrocall$2", "symbols": ["expr_others$macrocall$2$macrocall$1"] },
              { "name": "expr_others$macrocall$3", "symbols": ["expr_others"] },
              { "name": "expr_others$macrocall$4", "symbols": ["expr_like"] },
              { "name": "expr_others$macrocall$1$subexpression$1", "symbols": ["expr_others$macrocall$3"] },
              { "name": "expr_others$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_others$macrocall$1$subexpression$2", "symbols": ["expr_others$macrocall$4"] },
              { "name": "expr_others$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_others$macrocall$1", "symbols": ["expr_others$macrocall$1$subexpression$1", "expr_others$macrocall$2", "expr_others$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_others$macrocall$1", "symbols": ["expr_others$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_others", "symbols": ["expr_others$macrocall$1"] },
              { "name": "expr_like$macrocall$2$macrocall$2", "symbols": ["ops_like"] },
              { "name": "expr_like$macrocall$2$macrocall$1", "symbols": ["expr_like$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_like$macrocall$2", "symbols": ["expr_like$macrocall$2$macrocall$1"] },
              { "name": "expr_like$macrocall$3", "symbols": ["expr_like"] },
              { "name": "expr_like$macrocall$4", "symbols": ["expr_in"] },
              { "name": "expr_like$macrocall$1$subexpression$1", "symbols": ["expr_like$macrocall$3"] },
              { "name": "expr_like$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_like$macrocall$1$subexpression$2", "symbols": ["expr_like$macrocall$4"] },
              { "name": "expr_like$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_like$macrocall$1", "symbols": ["expr_like$macrocall$1$subexpression$1", "expr_like$macrocall$2", "expr_like$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_like$macrocall$1", "symbols": ["expr_like$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_like", "symbols": ["expr_like$macrocall$1"] },
              { "name": "expr_in$macrocall$2$macrocall$2", "symbols": ["ops_in"] },
              { "name": "expr_in$macrocall$2$macrocall$1", "symbols": ["expr_in$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_in$macrocall$2", "symbols": ["expr_in$macrocall$2$macrocall$1"] },
              { "name": "expr_in$macrocall$3", "symbols": ["expr_in"] },
              { "name": "expr_in$macrocall$4", "symbols": ["expr_add"] },
              { "name": "expr_in$macrocall$1$subexpression$1", "symbols": ["expr_in$macrocall$3"] },
              { "name": "expr_in$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_in$macrocall$1$subexpression$2", "symbols": ["expr_in$macrocall$4"] },
              { "name": "expr_in$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_in$macrocall$1", "symbols": ["expr_in$macrocall$1$subexpression$1", "expr_in$macrocall$2", "expr_in$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_in$macrocall$1", "symbols": ["expr_in$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_in", "symbols": ["expr_in$macrocall$1"] },
              { "name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_plus") ? { type: "op_plus" } : op_plus] },
              { "name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_minus") ? { type: "op_minus" } : op_minus] },
              { "name": "expr_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_additive") ? { type: "op_additive" } : op_additive] },
              { "name": "expr_add$macrocall$2$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_add$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$2"] },
              { "name": "expr_add$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_add$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_add$macrocall$2$macrocall$1", "symbols": ["expr_add$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_add$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_add$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_add$macrocall$2", "symbols": ["expr_add$macrocall$2$macrocall$1"] },
              { "name": "expr_add$macrocall$3", "symbols": ["expr_add"] },
              { "name": "expr_add$macrocall$4", "symbols": ["expr_mult"] },
              { "name": "expr_add$macrocall$1$subexpression$1", "symbols": ["expr_add$macrocall$3"] },
              { "name": "expr_add$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_add$macrocall$1$subexpression$2", "symbols": ["expr_add$macrocall$4"] },
              { "name": "expr_add$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_add$macrocall$1", "symbols": ["expr_add$macrocall$1$subexpression$1", "expr_add$macrocall$2", "expr_add$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_add$macrocall$1", "symbols": ["expr_add$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_add", "symbols": ["expr_add$macrocall$1"] },
              { "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("star") ? { type: "star" } : star] },
              { "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_div") ? { type: "op_div" } : op_div] },
              { "name": "expr_mult$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_mod") ? { type: "op_mod" } : op_mod] },
              { "name": "expr_mult$macrocall$2$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_mult$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$2"] },
              { "name": "expr_mult$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_mult$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_mult$macrocall$2$macrocall$1", "symbols": ["expr_mult$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_mult$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_mult$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_mult$macrocall$2", "symbols": ["expr_mult$macrocall$2$macrocall$1"] },
              { "name": "expr_mult$macrocall$3", "symbols": ["expr_mult"] },
              { "name": "expr_mult$macrocall$4", "symbols": ["expr_exp"] },
              { "name": "expr_mult$macrocall$1$subexpression$1", "symbols": ["expr_mult$macrocall$3"] },
              { "name": "expr_mult$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_mult$macrocall$1$subexpression$2", "symbols": ["expr_mult$macrocall$4"] },
              { "name": "expr_mult$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_mult$macrocall$1", "symbols": ["expr_mult$macrocall$1$subexpression$1", "expr_mult$macrocall$2", "expr_mult$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_mult$macrocall$1", "symbols": ["expr_mult$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_mult", "symbols": ["expr_mult$macrocall$1"] },
              { "name": "expr_exp$macrocall$2$macrocall$2", "symbols": [lexer_1.lexerAny.has("op_exp") ? { type: "op_exp" } : op_exp] },
              { "name": "expr_exp$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_exp$macrocall$2$macrocall$2"] },
              { "name": "expr_exp$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_exp$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_exp$macrocall$2$macrocall$1", "symbols": ["expr_exp$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_exp$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_exp$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_exp$macrocall$2", "symbols": ["expr_exp$macrocall$2$macrocall$1"] },
              { "name": "expr_exp$macrocall$3", "symbols": ["expr_exp"] },
              { "name": "expr_exp$macrocall$4", "symbols": ["expr_unary_add"] },
              { "name": "expr_exp$macrocall$1$subexpression$1", "symbols": ["expr_exp$macrocall$3"] },
              { "name": "expr_exp$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_exp$macrocall$1$subexpression$2", "symbols": ["expr_exp$macrocall$4"] },
              { "name": "expr_exp$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_exp$macrocall$1", "symbols": ["expr_exp$macrocall$1$subexpression$1", "expr_exp$macrocall$2", "expr_exp$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_exp$macrocall$1", "symbols": ["expr_exp$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_exp", "symbols": ["expr_exp$macrocall$1"] },
              { "name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_plus") ? { type: "op_plus" } : op_plus] },
              { "name": "expr_unary_add$macrocall$2$macrocall$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_minus") ? { type: "op_minus" } : op_minus] },
              { "name": "expr_unary_add$macrocall$2$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$2$subexpression$1"] },
              { "name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$2"] },
              { "name": "expr_unary_add$macrocall$2$macrocall$1$macrocall$1", "symbols": ["expr_unary_add$macrocall$2$macrocall$1$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_unary_add$macrocall$2$macrocall$1", "symbols": ["expr_unary_add$macrocall$2$macrocall$1$macrocall$1"], "postprocess": unwrap },
              { "name": "expr_unary_add$macrocall$2$macrocall$1", "symbols": ["kw_operator", "lparen", "ident", "dot", "expr_unary_add$macrocall$2$macrocall$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x[4], " ") || "<error>").toUpperCase(),
                opSchema: toStr(x[2])
              }) },
              { "name": "expr_unary_add$macrocall$2", "symbols": ["expr_unary_add$macrocall$2$macrocall$1"] },
              { "name": "expr_unary_add$macrocall$3", "symbols": ["expr_unary_add"] },
              { "name": "expr_unary_add$macrocall$4", "symbols": ["expr_various_constructs"] },
              { "name": "expr_unary_add$macrocall$1$subexpression$1", "symbols": ["expr_unary_add$macrocall$3"] },
              { "name": "expr_unary_add$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_unary_add$macrocall$1", "symbols": ["expr_unary_add$macrocall$2", "expr_unary_add$macrocall$1$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "unary",
                ...unwrap(x[0]),
                operand: unwrap(x[1])
              }) },
              { "name": "expr_unary_add$macrocall$1", "symbols": ["expr_unary_add$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_unary_add", "symbols": ["expr_unary_add$macrocall$1"] },
              { "name": "expr_various_constructs$macrocall$2$macrocall$2", "symbols": ["various_binaries"] },
              { "name": "expr_various_constructs$macrocall$2$macrocall$1", "symbols": ["expr_various_constructs$macrocall$2$macrocall$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                op: (toStr(x, " ") || "<error>").toUpperCase()
              }) },
              { "name": "expr_various_constructs$macrocall$2", "symbols": ["expr_various_constructs$macrocall$2$macrocall$1"] },
              { "name": "expr_various_constructs$macrocall$3", "symbols": ["expr_various_constructs"] },
              { "name": "expr_various_constructs$macrocall$4", "symbols": ["expr_array_index"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$1", "symbols": ["expr_various_constructs$macrocall$3"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$2", "symbols": ["expr_various_constructs$macrocall$4"] },
              { "name": "expr_various_constructs$macrocall$1$subexpression$2", "symbols": ["expr_paren"] },
              { "name": "expr_various_constructs$macrocall$1", "symbols": ["expr_various_constructs$macrocall$1$subexpression$1", "expr_various_constructs$macrocall$2", "expr_various_constructs$macrocall$1$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "binary",
                left: unwrap(x[0]),
                right: unwrap(x[2]),
                ...unwrap(x[1])
              }) },
              { "name": "expr_various_constructs$macrocall$1", "symbols": ["expr_various_constructs$macrocall$4"], "postprocess": unwrap },
              { "name": "expr_various_constructs", "symbols": ["expr_various_constructs$macrocall$1"] },
              { "name": "expr_array_index$subexpression$1", "symbols": ["expr_array_index"] },
              { "name": "expr_array_index$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_array_index", "symbols": ["expr_array_index$subexpression$1", lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, "expr_nostar", lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "arrayIndex",
                array: unwrap(x[0]),
                index: unwrap(x[2])
              }) },
              { "name": "expr_array_index", "symbols": ["expr_member"], "postprocess": unwrap },
              { "name": "expr_member$subexpression$1", "symbols": ["expr_member"] },
              { "name": "expr_member$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "expr_member$subexpression$2", "symbols": ["string"] },
              { "name": "expr_member$subexpression$2", "symbols": ["int"] },
              { "name": "expr_member", "symbols": ["expr_member$subexpression$1", "ops_member", "expr_member$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "member",
                operand: unwrap(x[0]),
                op: x[1],
                member: unwrap(x[2])
              }) },
              { "name": "expr_member$subexpression$3", "symbols": ["expr_member"] },
              { "name": "expr_member$subexpression$3", "symbols": ["expr_paren"] },
              { "name": "expr_member", "symbols": ["expr_member$subexpression$3", lexer_1.lexerAny.has("op_cast") ? { type: "op_cast" } : op_cast, "data_type"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "cast",
                operand: unwrap(x[0]),
                to: x[2]
              }) },
              { "name": "expr_member", "symbols": [lexer_1.lexerAny.has("kw_cast") ? { type: "kw_cast" } : kw_cast, "lparen", "expr_nostar", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "data_type", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "cast",
                operand: unwrap(x[2]),
                to: x[4]
              }) },
              { "name": "expr_member", "symbols": ["data_type", "string"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "cast",
                operand: (0, lexer_2.track)(x[1], {
                  type: "string",
                  value: (0, lexer_2.unbox)(x[1])
                }),
                to: (0, lexer_2.unbox)(x[0])
              }) },
              { "name": "expr_member", "symbols": ["expr_dot"], "postprocess": unwrap },
              { "name": "expr_dot$subexpression$1", "symbols": ["word"] },
              { "name": "expr_dot$subexpression$1", "symbols": ["star"] },
              { "name": "expr_dot", "symbols": ["qname", lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot, "expr_dot$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "ref",
                table: unwrap(x[0]),
                name: toStr(x[2])
              }) },
              { "name": "expr_dot", "symbols": ["expr_final"], "postprocess": unwrap },
              { "name": "expr_final", "symbols": ["expr_basic"] },
              { "name": "expr_final", "symbols": ["expr_primary"] },
              { "name": "expr_basic", "symbols": ["expr_special_calls"] },
              { "name": "expr_basic", "symbols": ["expr_call"] },
              { "name": "expr_basic", "symbols": ["expr_array"] },
              { "name": "expr_basic", "symbols": ["expr_case"] },
              { "name": "expr_basic", "symbols": ["expr_extract"] },
              { "name": "expr_basic", "symbols": ["word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "ref",
                name: unwrap(x[0])
              }) },
              { "name": "expr_array$ebnf$1", "symbols": ["expr_subarray_items"], "postprocess": id },
              { "name": "expr_array$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_array", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array, lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, "expr_array$ebnf$1", lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "array",
                expressions: x[2] || []
              }) },
              { "name": "expr_array", "symbols": [lexer_1.lexerAny.has("kw_array") ? { type: "kw_array" } : kw_array, "lparen", "selection", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "array select",
                select: unwrap(x[2])
              }) },
              { "name": "expr_subarray$ebnf$1", "symbols": ["expr_subarray_items"], "postprocess": id },
              { "name": "expr_subarray$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_subarray", "symbols": [lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket, "expr_subarray$ebnf$1", lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket], "postprocess": get11(1) },
              { "name": "expr_subarray_items$macrocall$2", "symbols": ["expr_list_item"] },
              { "name": "expr_subarray_items$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_subarray_items$macrocall$2"], "postprocess": last3 },
              { "name": "expr_subarray_items$macrocall$1$ebnf$1", "symbols": ["expr_subarray_items$macrocall$1$ebnf$1", "expr_subarray_items$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_subarray_items$macrocall$1", "symbols": ["expr_subarray_items$macrocall$2", "expr_subarray_items$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_subarray_items", "symbols": ["expr_subarray_items$macrocall$1"], "postprocess": (x) => x[0].map(unwrap) },
              { "name": "expr_subarray_items$macrocall$4", "symbols": ["expr_subarray"] },
              { "name": "expr_subarray_items$macrocall$3$ebnf$1", "symbols": [] },
              { "name": "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_subarray_items$macrocall$4"], "postprocess": last3 },
              { "name": "expr_subarray_items$macrocall$3$ebnf$1", "symbols": ["expr_subarray_items$macrocall$3$ebnf$1", "expr_subarray_items$macrocall$3$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_subarray_items$macrocall$3", "symbols": ["expr_subarray_items$macrocall$4", "expr_subarray_items$macrocall$3$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_subarray_items", "symbols": ["expr_subarray_items$macrocall$3"], "postprocess": (x) => {
                return x[0].map((v) => {
                  return (0, lexer_2.track)(v, {
                    type: "array",
                    expressions: v[0].map(unwrap)
                  });
                });
              } },
              { "name": "expr_function_call$ebnf$1", "symbols": ["expr_list_raw"], "postprocess": id },
              { "name": "expr_function_call$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_function_call", "symbols": ["expr_fn_name", "lparen", "expr_function_call$ebnf$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "call",
                function: unwrap(x[0]),
                args: x[2] || []
              }) },
              { "name": "expr_call$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "expr_call$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_distinct") ? { type: "kw_distinct" } : kw_distinct] },
              { "name": "expr_call$ebnf$1", "symbols": ["expr_call$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "expr_call$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$2", "symbols": ["expr_list_raw"], "postprocess": id },
              { "name": "expr_call$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$3", "symbols": ["select_order_by"], "postprocess": id },
              { "name": "expr_call$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$4$subexpression$1", "symbols": ["kw_filter", "lparen", lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr", "rparen"], "postprocess": get11(3) },
              { "name": "expr_call$ebnf$4", "symbols": ["expr_call$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "expr_call$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "expr_call$ebnf$5", "symbols": ["expr_call_over"], "postprocess": id },
              { "name": "expr_call$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "expr_call", "symbols": ["expr_fn_name", "lparen", "expr_call$ebnf$1", "expr_call$ebnf$2", "expr_call$ebnf$3", "rparen", "expr_call$ebnf$4", "expr_call$ebnf$5"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "call",
                function: unwrap(x[0]),
                ...x[2] && { distinct: toStr(x[2]) },
                args: x[3] || [],
                ...x[4] && { orderBy: x[4] },
                ...x[6] && { filter: unwrap(x[6]) },
                ...x[7] && { over: unwrap(x[7]) }
              }) },
              { "name": "expr_call_over$ebnf$1$subexpression$1", "symbols": ["kw_partition", "kw_by", "expr_list_raw"], "postprocess": last3 },
              { "name": "expr_call_over$ebnf$1", "symbols": ["expr_call_over$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "expr_call_over$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_call_over$ebnf$2", "symbols": ["select_order_by"], "postprocess": id },
              { "name": "expr_call_over$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "expr_call_over", "symbols": ["kw_over", "lparen", "expr_call_over$ebnf$1", "expr_call_over$ebnf$2", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                ...x[2] && { partitionBy: x[2] },
                ...x[3] && { orderBy: x[3] }
              }) },
              { "name": "expr_extract$subexpression$1", "symbols": ["word"], "postprocess": kw("extract") },
              { "name": "expr_extract", "symbols": ["expr_extract$subexpression$1", "lparen", "word", lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "expr", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "extract",
                field: asName(x[2]),
                from: x[4]
              }) },
              { "name": "expr_primary", "symbols": ["float"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "numeric", value: (0, lexer_2.unbox)(x[0]) }) },
              { "name": "expr_primary", "symbols": ["int"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "integer", value: (0, lexer_2.unbox)(x[0]) }) },
              { "name": "expr_primary", "symbols": ["string"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "string", value: (0, lexer_2.unbox)(x[0]) }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true], "postprocess": (x) => (0, lexer_2.track)(x, { type: "boolean", value: true }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false], "postprocess": (x) => (0, lexer_2.track)(x, { type: "boolean", value: false }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null], "postprocess": (x) => (0, lexer_2.track)(x, { type: "null" }) },
              { "name": "expr_primary", "symbols": ["value_keyword"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "keyword", keyword: toStr(x) }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("qparam") ? { type: "qparam" } : qparam], "postprocess": (x) => (0, lexer_2.track)(x, { type: "parameter", name: toStr(x[0]) }) },
              { "name": "expr_primary", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default" }) },
              { "name": "ops_like", "symbols": ["ops_like_keywors"] },
              { "name": "ops_like", "symbols": ["ops_like_operators"] },
              { "name": "ops_like_keywors$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "ops_like_keywors$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "ops_like_keywors$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_like") ? { type: "kw_like" } : kw_like] },
              { "name": "ops_like_keywors$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_ilike") ? { type: "kw_ilike" } : kw_ilike] },
              { "name": "ops_like_keywors", "symbols": ["ops_like_keywors$ebnf$1", "ops_like_keywors$subexpression$1"] },
              { "name": "ops_like_operators$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_like") ? { type: "op_like" } : op_like], "postprocess": () => "LIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$1"] },
              { "name": "ops_like_operators$subexpression$2", "symbols": [lexer_1.lexerAny.has("op_ilike") ? { type: "op_ilike" } : op_ilike], "postprocess": () => "ILIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$2"] },
              { "name": "ops_like_operators$subexpression$3", "symbols": [lexer_1.lexerAny.has("op_not_like") ? { type: "op_not_like" } : op_not_like], "postprocess": () => "NOT LIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$3"] },
              { "name": "ops_like_operators$subexpression$4", "symbols": [lexer_1.lexerAny.has("op_not_ilike") ? { type: "op_not_ilike" } : op_not_ilike], "postprocess": () => "NOT ILIKE" },
              { "name": "ops_like_operators", "symbols": ["ops_like_operators$subexpression$4"] },
              { "name": "ops_in$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "ops_in$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "ops_in", "symbols": ["ops_in$ebnf$1", lexer_1.lexerAny.has("kw_in") ? { type: "kw_in" } : kw_in] },
              { "name": "ops_between$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "ops_between$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "ops_between", "symbols": ["ops_between$ebnf$1", "kw_between"] },
              { "name": "ops_member$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_member") ? { type: "op_member" } : op_member] },
              { "name": "ops_member$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_membertext") ? { type: "op_membertext" } : op_membertext] },
              { "name": "ops_member", "symbols": ["ops_member$subexpression$1"], "postprocess": (x) => {
                var _a;
                return (_a = unwrap(x)) === null || _a === void 0 ? void 0 : _a.value;
              } },
              { "name": "expr_list_item", "symbols": ["expr_or_select"], "postprocess": unwrap },
              { "name": "expr_list_item", "symbols": ["expr_star"], "postprocess": unwrap },
              { "name": "expr_list_raw$macrocall$2", "symbols": ["expr_list_item"] },
              { "name": "expr_list_raw$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "expr_list_raw$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_list_raw$macrocall$2"], "postprocess": last3 },
              { "name": "expr_list_raw$macrocall$1$ebnf$1", "symbols": ["expr_list_raw$macrocall$1$ebnf$1", "expr_list_raw$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_list_raw$macrocall$1", "symbols": ["expr_list_raw$macrocall$2", "expr_list_raw$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_list_raw", "symbols": ["expr_list_raw$macrocall$1"], "postprocess": ([x]) => x.map(unwrap) },
              { "name": "expr_list_raw_many$macrocall$2", "symbols": ["expr_list_item"] },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_list_raw_many$macrocall$2"], "postprocess": last3 },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1", "symbols": ["expr_list_raw_many$macrocall$1$ebnf$1$subexpression$1"] },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "expr_list_raw_many$macrocall$2"], "postprocess": last3 },
              { "name": "expr_list_raw_many$macrocall$1$ebnf$1", "symbols": ["expr_list_raw_many$macrocall$1$ebnf$1", "expr_list_raw_many$macrocall$1$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_list_raw_many$macrocall$1", "symbols": ["expr_list_raw_many$macrocall$2", "expr_list_raw_many$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "expr_list_raw_many", "symbols": ["expr_list_raw_many$macrocall$1"], "postprocess": ([x]) => x.map(unwrap) },
              { "name": "expr_or_select", "symbols": ["expr_nostar"], "postprocess": unwrap },
              { "name": "expr_or_select", "symbols": ["selection"], "postprocess": unwrap },
              { "name": "expr_list_many", "symbols": ["expr_list_raw_many"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "list",
                expressions: x[0]
              }) },
              { "name": "expr_case$ebnf$1", "symbols": ["expr_nostar"], "postprocess": id },
              { "name": "expr_case$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_case$ebnf$2", "symbols": [] },
              { "name": "expr_case$ebnf$2", "symbols": ["expr_case$ebnf$2", "expr_case_whens"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "expr_case$ebnf$3", "symbols": ["expr_case_else"], "postprocess": id },
              { "name": "expr_case$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "expr_case", "symbols": [lexer_1.lexerAny.has("kw_case") ? { type: "kw_case" } : kw_case, "expr_case$ebnf$1", "expr_case$ebnf$2", "expr_case$ebnf$3", lexer_1.lexerAny.has("kw_end") ? { type: "kw_end" } : kw_end], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "case",
                value: x[1],
                whens: x[2],
                else: x[3]
              }) },
              { "name": "expr_case_whens", "symbols": [lexer_1.lexerAny.has("kw_when") ? { type: "kw_when" } : kw_when, "expr_nostar", lexer_1.lexerAny.has("kw_then") ? { type: "kw_then" } : kw_then, "expr_nostar"], "postprocess": (x) => (0, lexer_2.track)(x, {
                when: x[1],
                value: x[3]
              }) },
              { "name": "expr_case_else", "symbols": [lexer_1.lexerAny.has("kw_else") ? { type: "kw_else" } : kw_else, "expr_nostar"], "postprocess": last3 },
              { "name": "expr_fn_name$subexpression$1$ebnf$1$subexpression$1", "symbols": ["word", lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot] },
              { "name": "expr_fn_name$subexpression$1$ebnf$1", "symbols": ["expr_fn_name$subexpression$1$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "expr_fn_name$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "expr_fn_name$subexpression$1", "symbols": ["expr_fn_name$subexpression$1$ebnf$1", "word_or_keyword"], "postprocess": (x) => (0, lexer_2.track)(x, {
                name: (0, lexer_2.unbox)(unwrap(x[1])),
                ...x[0] && { schema: toStr(x[0][0]) }
              }) },
              { "name": "expr_fn_name", "symbols": ["expr_fn_name$subexpression$1"] },
              { "name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_any") ? { type: "kw_any" } : kw_any] },
              { "name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_some") ? { type: "kw_some" } : kw_some] },
              { "name": "expr_fn_name$subexpression$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "expr_fn_name$subexpression$2", "symbols": ["expr_fn_name$subexpression$2$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                name: toStr(unwrap(x))
              }) },
              { "name": "expr_fn_name", "symbols": ["expr_fn_name$subexpression$2"] },
              { "name": "word_or_keyword", "symbols": ["word"] },
              { "name": "word_or_keyword", "symbols": ["value_keyword"], "postprocess": (x) => (0, lexer_2.box)(x, toStr(x)) },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_catalog") ? { type: "kw_current_catalog" } : kw_current_catalog] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_date") ? { type: "kw_current_date" } : kw_current_date] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_role") ? { type: "kw_current_role" } : kw_current_role] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_schema") ? { type: "kw_current_schema" } : kw_current_schema] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_timestamp") ? { type: "kw_current_timestamp" } : kw_current_timestamp] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_time") ? { type: "kw_current_time" } : kw_current_time] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtimestamp") ? { type: "kw_localtimestamp" } : kw_localtimestamp] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_localtime") ? { type: "kw_localtime" } : kw_localtime] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_session_user") ? { type: "kw_session_user" } : kw_session_user] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_user") ? { type: "kw_user" } : kw_user] },
              { "name": "value_keyword", "symbols": [lexer_1.lexerAny.has("kw_current_user") ? { type: "kw_current_user" } : kw_current_user] },
              { "name": "expr_special_calls", "symbols": ["spe_overlay"] },
              { "name": "expr_special_calls", "symbols": ["spe_substring"] },
              { "name": "spe_overlay$subexpression$1", "symbols": ["word"], "postprocess": kw("overlay") },
              { "name": "spe_overlay$subexpression$2", "symbols": [lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen, "expr_nostar"] },
              { "name": "spe_overlay$subexpression$3", "symbols": [lexer_1.lexerAny.has("kw_placing") ? { type: "kw_placing" } : kw_placing, "expr_nostar"] },
              { "name": "spe_overlay$subexpression$4", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "expr_nostar"] },
              { "name": "spe_overlay$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for, "expr_nostar"] },
              { "name": "spe_overlay$ebnf$1", "symbols": ["spe_overlay$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "spe_overlay$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "spe_overlay", "symbols": ["spe_overlay$subexpression$1", "spe_overlay$subexpression$2", "spe_overlay$subexpression$3", "spe_overlay$subexpression$4", "spe_overlay$ebnf$1", lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "overlay",
                value: x[1][1],
                placing: x[2][1],
                from: x[3][1],
                ...x[4] && { for: x[4][1] }
              }) },
              { "name": "spe_substring$subexpression$1", "symbols": ["word"], "postprocess": kw("substring") },
              { "name": "spe_substring$subexpression$2", "symbols": [lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen, "expr_nostar"] },
              { "name": "spe_substring$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "expr_nostar"] },
              { "name": "spe_substring$ebnf$1", "symbols": ["spe_substring$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "spe_substring$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "spe_substring$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_for") ? { type: "kw_for" } : kw_for, "expr_nostar"] },
              { "name": "spe_substring$ebnf$2", "symbols": ["spe_substring$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "spe_substring$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "spe_substring", "symbols": ["spe_substring$subexpression$1", "spe_substring$subexpression$2", "spe_substring$ebnf$1", "spe_substring$ebnf$2", lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "substring",
                value: x[1][1],
                ...x[2] && { from: x[2][1] },
                ...x[3] && { for: x[3][1] }
              }) },
              { "name": "various_binaries", "symbols": ["kw_at", "kw_time", "kw_zone"], "postprocess": () => "AT TIME ZONE" },
              { "name": "createtable_statement$ebnf$1", "symbols": ["createtable_modifiers"], "postprocess": id },
              { "name": "createtable_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "createtable_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createtable_statement$ebnf$3", "symbols": ["createtable_opts"], "postprocess": id },
              { "name": "createtable_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createtable_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "createtable_statement$ebnf$1", lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table, "createtable_statement$ebnf$2", "qname", "lparen", "createtable_declarationlist", "rparen", "createtable_statement$ebnf$3"], "postprocess": (x) => {
                const cols = x[6].filter((v) => "kind" in v);
                const constraints = x[6].filter((v) => !("kind" in v));
                return (0, lexer_2.track)(x, {
                  type: "create table",
                  ...!!x[3] ? { ifNotExists: true } : {},
                  name: x[4],
                  columns: cols,
                  ...unwrap(x[1]),
                  ...constraints.length ? { constraints } : {},
                  ...last3(x)
                });
              } },
              { "name": "createtable_modifiers", "symbols": ["kw_unlogged"], "postprocess": (x) => x[0] ? { unlogged: true } : {} },
              { "name": "createtable_modifiers", "symbols": ["m_locglob"] },
              { "name": "createtable_modifiers", "symbols": ["m_tmp"] },
              { "name": "createtable_modifiers", "symbols": ["m_locglob", "m_tmp"], "postprocess": ([a, b]) => ({ ...a, ...b }) },
              { "name": "m_locglob$subexpression$1", "symbols": ["kw_local"] },
              { "name": "m_locglob$subexpression$1", "symbols": ["kw_global"] },
              { "name": "m_locglob", "symbols": ["m_locglob$subexpression$1"], "postprocess": (x) => ({ locality: toStr(x) }) },
              { "name": "m_tmp$subexpression$1", "symbols": ["kw_temp"] },
              { "name": "m_tmp$subexpression$1", "symbols": ["kw_temporary"] },
              { "name": "m_tmp", "symbols": ["m_tmp$subexpression$1"], "postprocess": (x) => ({ temporary: true }) },
              { "name": "createtable_declarationlist$ebnf$1", "symbols": [] },
              { "name": "createtable_declarationlist$ebnf$1$subexpression$1", "symbols": ["comma", "createtable_declaration"], "postprocess": last3 },
              { "name": "createtable_declarationlist$ebnf$1", "symbols": ["createtable_declarationlist$ebnf$1", "createtable_declarationlist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_declarationlist", "symbols": ["createtable_declaration", "createtable_declarationlist$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "createtable_declaration$subexpression$1", "symbols": ["createtable_constraint"] },
              { "name": "createtable_declaration$subexpression$1", "symbols": ["createtable_column"] },
              { "name": "createtable_declaration$subexpression$1", "symbols": ["createtable_like"] },
              { "name": "createtable_declaration", "symbols": ["createtable_declaration$subexpression$1"], "postprocess": unwrap },
              { "name": "createtable_constraint$macrocall$2", "symbols": ["createtable_constraint_def"] },
              { "name": "createtable_constraint$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "word"] },
              { "name": "createtable_constraint$macrocall$1$ebnf$1", "symbols": ["createtable_constraint$macrocall$1$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "createtable_constraint$macrocall$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_constraint$macrocall$1", "symbols": ["createtable_constraint$macrocall$1$ebnf$1", "createtable_constraint$macrocall$2"], "postprocess": (x) => {
                const name = x[0] && asName(x[0][1]);
                if (!name) {
                  return (0, lexer_2.track)(x, unwrap(x[1]));
                }
                return (0, lexer_2.track)(x, {
                  constraintName: name,
                  ...unwrap(x[1])
                });
              } },
              { "name": "createtable_constraint", "symbols": ["createtable_constraint$macrocall$1"], "postprocess": unwrap },
              { "name": "createtable_constraint_def", "symbols": ["createtable_constraint_def_unique"] },
              { "name": "createtable_constraint_def", "symbols": ["createtable_constraint_def_check"] },
              { "name": "createtable_constraint_def", "symbols": ["createtable_constraint_foreignkey"] },
              { "name": "createtable_constraint_def_unique$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique] },
              { "name": "createtable_constraint_def_unique$subexpression$1", "symbols": ["kw_primary_key"] },
              { "name": "createtable_constraint_def_unique", "symbols": ["createtable_constraint_def_unique$subexpression$1", "lparen", "createtable_collist", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: toStr(x[0], " "),
                columns: x[2].map(asName)
              }) },
              { "name": "createtable_constraint_def_check", "symbols": [lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check, "expr_paren"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "check",
                expr: unwrap(x[1])
              }) },
              { "name": "createtable_constraint_foreignkey", "symbols": [lexer_1.lexerAny.has("kw_foreign") ? { type: "kw_foreign" } : kw_foreign, "kw_key", "collist_paren", "createtable_references"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "foreign key",
                  localColumns: x[2].map(asName),
                  ...x[3]
                });
              } },
              { "name": "createtable_references$ebnf$1", "symbols": [] },
              { "name": "createtable_references$ebnf$1", "symbols": ["createtable_references$ebnf$1", "createtable_constraint_foreignkey_onsometing"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_references", "symbols": [lexer_1.lexerAny.has("kw_references") ? { type: "kw_references" } : kw_references, "table_ref", "collist_paren", "createtable_references$ebnf$1"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  foreignTable: unwrap(x[1]),
                  foreignColumns: x[2].map(asName),
                  ...x[3].reduce((a, b) => ({ ...a, ...b }), {})
                });
              } },
              { "name": "createtable_constraint_foreignkey_onsometing", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "kw_delete", "createtable_constraint_on_action"], "postprocess": (x) => (0, lexer_2.track)(x, { onDelete: last3(x) }) },
              { "name": "createtable_constraint_foreignkey_onsometing", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "kw_update", "createtable_constraint_on_action"], "postprocess": (x) => (0, lexer_2.track)(x, { onUpdate: last3(x) }) },
              { "name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_full") ? { type: "kw_full" } : kw_full] },
              { "name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": ["kw_partial"] },
              { "name": "createtable_constraint_foreignkey_onsometing$subexpression$1", "symbols": ["kw_simple"] },
              { "name": "createtable_constraint_foreignkey_onsometing", "symbols": ["kw_match", "createtable_constraint_foreignkey_onsometing$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { match: toStr(last3(x)) }) },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "createtable_constraint_on_action$subexpression$1$subexpression$1", "symbols": ["kw_no", "kw_action"] },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["createtable_constraint_on_action$subexpression$1$subexpression$1"] },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "createtable_constraint_on_action$subexpression$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null] },
              { "name": "createtable_constraint_on_action$subexpression$1$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default] },
              { "name": "createtable_constraint_on_action$subexpression$1", "symbols": ["kw_set", "createtable_constraint_on_action$subexpression$1$subexpression$2"] },
              { "name": "createtable_constraint_on_action", "symbols": ["createtable_constraint_on_action$subexpression$1"], "postprocess": (x) => toStr(x, " ") },
              { "name": "createtable_collist$ebnf$1", "symbols": [] },
              { "name": "createtable_collist$ebnf$1$subexpression$1", "symbols": ["comma", "ident"], "postprocess": last3 },
              { "name": "createtable_collist$ebnf$1", "symbols": ["createtable_collist$ebnf$1", "createtable_collist$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_collist", "symbols": ["ident", "createtable_collist$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "createtable_column$ebnf$1", "symbols": ["createtable_collate"], "postprocess": id },
              { "name": "createtable_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_column$ebnf$2", "symbols": [] },
              { "name": "createtable_column$ebnf$2", "symbols": ["createtable_column$ebnf$2", "createtable_column_constraint"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_column", "symbols": ["word", "data_type", "createtable_column$ebnf$1", "createtable_column$ebnf$2"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  kind: "column",
                  name: asName(x[0]),
                  dataType: x[1],
                  ...x[2] ? { collate: x[2][1] } : {},
                  ...x[3] && x[3].length ? { constraints: x[3] } : {}
                });
              } },
              { "name": "createtable_like$ebnf$1", "symbols": [] },
              { "name": "createtable_like$ebnf$1", "symbols": ["createtable_like$ebnf$1", "createtable_like_opt"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_like", "symbols": [lexer_1.lexerAny.has("kw_like") ? { type: "kw_like" } : kw_like, "qname", "createtable_like$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                kind: "like table",
                like: x[1],
                options: x[2]
              }) },
              { "name": "createtable_like_opt$subexpression$1", "symbols": ["kw_including"] },
              { "name": "createtable_like_opt$subexpression$1", "symbols": ["kw_excluding"] },
              { "name": "createtable_like_opt", "symbols": ["createtable_like_opt$subexpression$1", "createtable_like_opt_val"], "postprocess": (x) => (0, lexer_2.track)(x, {
                verb: toStr(x[0]),
                option: toStr(x[1])
              }) },
              { "name": "createtable_like_opt_val", "symbols": ["word"], "postprocess": anyKw("defaults", "constraints", "indexes", "storage", "comments") },
              { "name": "createtable_like_opt_val", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all] },
              { "name": "createtable_column_constraint$macrocall$2", "symbols": ["createtable_column_constraint_def"] },
              { "name": "createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "word"] },
              { "name": "createtable_column_constraint$macrocall$1$ebnf$1", "symbols": ["createtable_column_constraint$macrocall$1$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "createtable_column_constraint$macrocall$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtable_column_constraint$macrocall$1", "symbols": ["createtable_column_constraint$macrocall$1$ebnf$1", "createtable_column_constraint$macrocall$2"], "postprocess": (x) => {
                const name = x[0] && asName(x[0][1]);
                if (!name) {
                  return (0, lexer_2.track)(x, unwrap(x[1]));
                }
                return (0, lexer_2.track)(x, {
                  constraintName: name,
                  ...unwrap(x[1])
                });
              } },
              { "name": "createtable_column_constraint", "symbols": ["createtable_column_constraint$macrocall$1"], "postprocess": unwrap },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique], "postprocess": (x) => (0, lexer_2.track)(x, { type: "unique" }) },
              { "name": "createtable_column_constraint_def", "symbols": ["kw_primary_key"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "primary key" }) },
              { "name": "createtable_column_constraint_def", "symbols": ["kw_not_null"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "not null" }) },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null], "postprocess": (x) => (0, lexer_2.track)(x, { type: "null" }) },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default", default: unwrap(x[1]) }) },
              { "name": "createtable_column_constraint_def", "symbols": [lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check, "expr_paren"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "check", expr: unwrap(x[1]) }) },
              { "name": "createtable_column_constraint_def", "symbols": ["createtable_references"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "reference", ...unwrap(x) }) },
              { "name": "createtable_column_constraint_def", "symbols": ["altercol_generated"] },
              { "name": "createtable_collate", "symbols": [lexer_1.lexerAny.has("kw_collate") ? { type: "kw_collate" } : kw_collate, "qualified_name"] },
              { "name": "createtable_opts$subexpression$1", "symbols": ["word"], "postprocess": kw("inherits") },
              { "name": "createtable_opts$macrocall$2", "symbols": ["qname"] },
              { "name": "createtable_opts$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createtable_opts$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createtable_opts$macrocall$2"], "postprocess": last3 },
              { "name": "createtable_opts$macrocall$1$ebnf$1", "symbols": ["createtable_opts$macrocall$1$ebnf$1", "createtable_opts$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtable_opts$macrocall$1", "symbols": ["createtable_opts$macrocall$2", "createtable_opts$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createtable_opts", "symbols": ["createtable_opts$subexpression$1", "lparen", "createtable_opts$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, { inherits: x[2] }) },
              { "name": "createindex_statement$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_unique") ? { type: "kw_unique" } : kw_unique], "postprocess": id },
              { "name": "createindex_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "createindex_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$3", "symbols": ["word"], "postprocess": id },
              { "name": "createindex_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$4$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using, "ident"], "postprocess": last3 },
              { "name": "createindex_statement$ebnf$4", "symbols": ["createindex_statement$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "createindex_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$5", "symbols": ["createindex_with"], "postprocess": id },
              { "name": "createindex_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$6", "symbols": ["createindex_tblspace"], "postprocess": id },
              { "name": "createindex_statement$ebnf$6", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement$ebnf$7", "symbols": ["createindex_predicate"], "postprocess": id },
              { "name": "createindex_statement$ebnf$7", "symbols": [], "postprocess": () => null },
              { "name": "createindex_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "createindex_statement$ebnf$1", "kw_index", "createindex_statement$ebnf$2", "createindex_statement$ebnf$3", lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "table_ref", "createindex_statement$ebnf$4", "lparen", "createindex_expressions", "rparen", "createindex_statement$ebnf$5", "createindex_statement$ebnf$6", "createindex_statement$ebnf$7"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create index",
                ...x[1] && { unique: true },
                ...x[3] && { ifNotExists: true },
                ...x[4] && { indexName: asName(x[4]) },
                table: x[6],
                ...x[7] && { using: asName(x[7]) },
                expressions: x[9],
                ...x[11] && { with: x[11] },
                ...x[12] && { tablespace: unwrap(x[12]) },
                ...x[13] && { where: unwrap(x[13]) }
              }) },
              { "name": "createindex_expressions$ebnf$1", "symbols": [] },
              { "name": "createindex_expressions$ebnf$1$subexpression$1", "symbols": ["comma", "createindex_expression"], "postprocess": last3 },
              { "name": "createindex_expressions$ebnf$1", "symbols": ["createindex_expressions$ebnf$1", "createindex_expressions$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createindex_expressions", "symbols": ["createindex_expression", "createindex_expressions$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "createindex_expression$subexpression$1", "symbols": ["expr_basic"] },
              { "name": "createindex_expression$subexpression$1", "symbols": ["expr_paren"] },
              { "name": "createindex_expression$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_collate") ? { type: "kw_collate" } : kw_collate, "qualified_name"], "postprocess": last3 },
              { "name": "createindex_expression$ebnf$1", "symbols": ["createindex_expression$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "createindex_expression$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression$ebnf$2", "symbols": ["qualified_name"], "postprocess": id },
              { "name": "createindex_expression$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression$ebnf$3$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_asc") ? { type: "kw_asc" } : kw_asc] },
              { "name": "createindex_expression$ebnf$3$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_desc") ? { type: "kw_desc" } : kw_desc] },
              { "name": "createindex_expression$ebnf$3", "symbols": ["createindex_expression$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "createindex_expression$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1", "symbols": ["kw_first"] },
              { "name": "createindex_expression$ebnf$4$subexpression$1$subexpression$1", "symbols": ["kw_last"] },
              { "name": "createindex_expression$ebnf$4$subexpression$1", "symbols": ["kw_nulls", "createindex_expression$ebnf$4$subexpression$1$subexpression$1"], "postprocess": last3 },
              { "name": "createindex_expression$ebnf$4", "symbols": ["createindex_expression$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "createindex_expression$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "createindex_expression", "symbols": ["createindex_expression$subexpression$1", "createindex_expression$ebnf$1", "createindex_expression$ebnf$2", "createindex_expression$ebnf$3", "createindex_expression$ebnf$4"], "postprocess": (x) => (0, lexer_2.track)(x, {
                expression: unwrap(x[0]),
                ...x[1] && { collate: unwrap(x[1]) },
                ...x[2] && { opclass: unwrap(x[2]) },
                ...x[3] && { order: unwrap(x[3]).value },
                ...x[4] && { nulls: unwrap(x[4]) }
              }) },
              { "name": "createindex_predicate", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr"], "postprocess": last3 },
              { "name": "createindex_with$macrocall$2", "symbols": ["createindex_with_item"] },
              { "name": "createindex_with$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createindex_with$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createindex_with$macrocall$2"], "postprocess": last3 },
              { "name": "createindex_with$macrocall$1$ebnf$1", "symbols": ["createindex_with$macrocall$1$ebnf$1", "createindex_with$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createindex_with$macrocall$1", "symbols": ["createindex_with$macrocall$2", "createindex_with$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createindex_with", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "lparen", "createindex_with$macrocall$1", "rparen"], "postprocess": get11(2) },
              { "name": "createindex_with_item$subexpression$1", "symbols": ["string"] },
              { "name": "createindex_with_item$subexpression$1", "symbols": ["int"] },
              { "name": "createindex_with_item", "symbols": ["ident", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "createindex_with_item$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { parameter: toStr(x[0]), value: unwrap(x[2]).toString() }) },
              { "name": "createindex_tblspace", "symbols": ["kw_tablespace", "ident"], "postprocess": last3 },
              { "name": "createextension_statement$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "createextension_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$2", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with], "postprocess": id },
              { "name": "createextension_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$3$subexpression$1", "symbols": ["kw_schema", "word"], "postprocess": last3 },
              { "name": "createextension_statement$ebnf$3", "symbols": ["createextension_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "createextension_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$4$subexpression$1", "symbols": ["kw_version", "string"], "postprocess": last3 },
              { "name": "createextension_statement$ebnf$4", "symbols": ["createextension_statement$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "createextension_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement$ebnf$5$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "string"], "postprocess": last3 },
              { "name": "createextension_statement$ebnf$5", "symbols": ["createextension_statement$ebnf$5$subexpression$1"], "postprocess": id },
              { "name": "createextension_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "createextension_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_extension", "createextension_statement$ebnf$1", "word", "createextension_statement$ebnf$2", "createextension_statement$ebnf$3", "createextension_statement$ebnf$4", "createextension_statement$ebnf$5"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create extension",
                ...!!x[2] ? { ifNotExists: true } : {},
                extension: asName(x[3]),
                ...!!x[5] ? { schema: asName(x[5]) } : {},
                ...!!x[6] ? { version: asLit(x[6]) } : {},
                ...!!x[7] ? { from: asLit(x[7]) } : {}
              }) },
              { "name": "simplestatements_all", "symbols": ["simplestatements_start_transaction"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_commit"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_rollback"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_tablespace"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_set"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_show"] },
              { "name": "simplestatements_all", "symbols": ["simplestatements_begin"] },
              { "name": "simplestatements_start_transaction$subexpression$1", "symbols": ["kw_start", "kw_transaction"] },
              { "name": "simplestatements_start_transaction", "symbols": ["simplestatements_start_transaction$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "start transaction" }) },
              { "name": "simplestatements_commit", "symbols": ["kw_commit"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "commit" }) },
              { "name": "simplestatements_rollback", "symbols": ["kw_rollback"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "rollback" }) },
              { "name": "simplestatements_tablespace", "symbols": ["kw_tablespace", "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "tablespace",
                tablespace: asName(x[1])
              }) },
              { "name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_simple"] },
              { "name": "simplestatements_set$subexpression$1", "symbols": ["simplestatements_set_timezone"] },
              { "name": "simplestatements_set", "symbols": ["kw_set", "simplestatements_set$subexpression$1"], "postprocess": last3 },
              { "name": "simplestatements_set_timezone", "symbols": ["kw_time", "kw_zone", "simplestatements_set_timezone_val"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set timezone", to: x[2] }) },
              { "name": "simplestatements_set_timezone_val$subexpression$1", "symbols": ["string"] },
              { "name": "simplestatements_set_timezone_val$subexpression$1", "symbols": ["int"] },
              { "name": "simplestatements_set_timezone_val", "symbols": ["simplestatements_set_timezone_val$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "value", value: unwrap(x[0]) }) },
              { "name": "simplestatements_set_timezone_val", "symbols": ["kw_local"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "local" }) },
              { "name": "simplestatements_set_timezone_val", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default" }) },
              { "name": "simplestatements_set_timezone_val", "symbols": ["kw_interval", "string", "kw_hour", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "kw_minute"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "interval", value: (0, lexer_2.unbox)(x[1]) }) },
              { "name": "simplestatements_set_simple$subexpression$1", "symbols": [lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq] },
              { "name": "simplestatements_set_simple$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to] },
              { "name": "simplestatements_set_simple", "symbols": ["ident", "simplestatements_set_simple$subexpression$1", "simplestatements_set_val"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "set",
                variable: asName(x[0]),
                set: (0, lexer_2.unbox)(x[2])
              }) },
              { "name": "simplestatements_set_val", "symbols": ["simplestatements_set_val_raw"], "postprocess": unwrap },
              { "name": "simplestatements_set_val", "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "default" }) },
              { "name": "simplestatements_set_val$ebnf$1$subexpression$1", "symbols": ["comma", "simplestatements_set_val_raw"] },
              { "name": "simplestatements_set_val$ebnf$1", "symbols": ["simplestatements_set_val$ebnf$1$subexpression$1"] },
              { "name": "simplestatements_set_val$ebnf$1$subexpression$2", "symbols": ["comma", "simplestatements_set_val_raw"] },
              { "name": "simplestatements_set_val$ebnf$1", "symbols": ["simplestatements_set_val$ebnf$1", "simplestatements_set_val$ebnf$1$subexpression$2"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "simplestatements_set_val", "symbols": ["simplestatements_set_val_raw", "simplestatements_set_val$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "list",
                values: [x[0], ...x[1] || []]
              }) },
              { "name": "simplestatements_set_val_raw$subexpression$1", "symbols": ["string"] },
              { "name": "simplestatements_set_val_raw$subexpression$1", "symbols": ["int"] },
              { "name": "simplestatements_set_val_raw", "symbols": ["simplestatements_set_val_raw$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "value", value: unwrap(x) }) },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word] },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on] },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_true") ? { type: "kw_true" } : kw_true] },
              { "name": "simplestatements_set_val_raw$subexpression$2", "symbols": [lexer_1.lexerAny.has("kw_false") ? { type: "kw_false" } : kw_false] },
              { "name": "simplestatements_set_val_raw", "symbols": ["simplestatements_set_val_raw$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "identifier", name: unwrap(x).value }) },
              { "name": "simplestatements_set_val_raw", "symbols": [lexer_1.lexerAny.has("quoted_word") ? { type: "quoted_word" } : quoted_word], "postprocess": (x) => (0, lexer_2.track)(x, { type: "identifier", doubleQuoted: true, name: unwrap(x).value }) },
              { "name": "simplestatements_show", "symbols": ["kw_show", "ident"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "show", variable: asName(x[1]) }) },
              { "name": "create_schema$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_schema"] },
              { "name": "create_schema$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "create_schema$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_schema", "symbols": ["create_schema$subexpression$1", "create_schema$ebnf$1", "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create schema",
                name: asName(x[2]),
                ...!!x[1] ? { ifNotExists: true } : {}
              }) },
              { "name": "raise_statement$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("debug", "log", "info", "notice", "warning", "exception") },
              { "name": "raise_statement$ebnf$1", "symbols": ["raise_statement$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "raise_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "raise_statement$ebnf$2$subexpression$1", "symbols": ["comma", "expr_list_raw"], "postprocess": last3 },
              { "name": "raise_statement$ebnf$2", "symbols": ["raise_statement$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "raise_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "raise_statement$ebnf$3", "symbols": ["raise_using"], "postprocess": id },
              { "name": "raise_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "raise_statement", "symbols": ["kw_raise", "raise_statement$ebnf$1", "string", "raise_statement$ebnf$2", "raise_statement$ebnf$3"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "raise",
                format: toStr(x[2]),
                ...x[1] && { level: toStr(x[1]) },
                ...x[3] && x[3].length && { formatExprs: x[3] },
                ...x[4] && x[4].length && { using: x[4] }
              }) },
              { "name": "raise_using$macrocall$2", "symbols": ["raise_using_one"] },
              { "name": "raise_using$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "raise_using$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "raise_using$macrocall$2"], "postprocess": last3 },
              { "name": "raise_using$macrocall$1$ebnf$1", "symbols": ["raise_using$macrocall$1$ebnf$1", "raise_using$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "raise_using$macrocall$1", "symbols": ["raise_using$macrocall$2", "raise_using$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "raise_using", "symbols": [lexer_1.lexerAny.has("kw_using") ? { type: "kw_using" } : kw_using, "raise_using$macrocall$1"], "postprocess": last3 },
              { "name": "raise_using_one", "symbols": ["raise_using_what", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: toStr(x[0]),
                value: x[2]
              }) },
              { "name": "raise_using_what", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table] },
              { "name": "raise_using_what", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("message", "detail", "hint", "errcode", "column", "constraint", "datatype", "schema") },
              { "name": "comment_statement", "symbols": ["kw_comment", lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "comment_what", lexer_1.lexerAny.has("kw_is") ? { type: "kw_is" } : kw_is, "string"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "comment",
                comment: (0, lexer_2.unbox)(last3(x)),
                on: unwrap(x[2])
              }) },
              { "name": "comment_what", "symbols": ["comment_what_col"] },
              { "name": "comment_what", "symbols": ["comment_what_nm"] },
              { "name": "comment_what_nm$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table] },
              { "name": "comment_what_nm$subexpression$1", "symbols": ["kw_materialized", "kw_view"] },
              { "name": "comment_what_nm$subexpression$1", "symbols": [lexer_1.lexerAny.has("word") ? { type: "word" } : word], "postprocess": anyKw("database", "index", "trigger", "type", "view") },
              { "name": "comment_what_nm", "symbols": ["comment_what_nm$subexpression$1", "qualified_name"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: toStr(x[0]),
                name: x[1]
              }) },
              { "name": "comment_what_col", "symbols": ["kw_column", "qcolumn"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "column",
                column: last3(x)
              }) },
              { "name": "simplestatements_begin$ebnf$1$subexpression$1", "symbols": ["kw_transaction"] },
              { "name": "simplestatements_begin$ebnf$1$subexpression$1", "symbols": ["kw_work"] },
              { "name": "simplestatements_begin$ebnf$1", "symbols": ["simplestatements_begin$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "simplestatements_begin$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "simplestatements_begin$ebnf$2", "symbols": [] },
              { "name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_isol"] },
              { "name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_writ"] },
              { "name": "simplestatements_begin$ebnf$2$subexpression$1", "symbols": ["simplestatements_begin_def"] },
              { "name": "simplestatements_begin$ebnf$2", "symbols": ["simplestatements_begin$ebnf$2", "simplestatements_begin$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              {
                "name": "simplestatements_begin",
                "symbols": ["kw_begin", "simplestatements_begin$ebnf$1", "simplestatements_begin$ebnf$2"],
                "postprocess": (x) => (0, lexer_2.track)(x, {
                  type: "begin",
                  ...x[2].reduce((a, b) => ({ ...unwrap(a), ...unwrap(b) }), {})
                })
              },
              { "name": "simplestatements_begin_isol$subexpression$1", "symbols": ["kw_isolation", "kw_level"] },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_serializable"] },
              { "name": "simplestatements_begin_isol$subexpression$2$subexpression$1", "symbols": ["word"], "postprocess": kw("repeatable") },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["simplestatements_begin_isol$subexpression$2$subexpression$1", "kw_read"] },
              { "name": "simplestatements_begin_isol$subexpression$2$subexpression$2", "symbols": ["word"], "postprocess": kw("committed") },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_read", "simplestatements_begin_isol$subexpression$2$subexpression$2"] },
              { "name": "simplestatements_begin_isol$subexpression$2$subexpression$3", "symbols": ["word"], "postprocess": kw("uncommitted") },
              { "name": "simplestatements_begin_isol$subexpression$2", "symbols": ["kw_read", "simplestatements_begin_isol$subexpression$2$subexpression$3"] },
              { "name": "simplestatements_begin_isol", "symbols": ["simplestatements_begin_isol$subexpression$1", "simplestatements_begin_isol$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                isolationLevel: toStr(x[1], " ")
              }) },
              { "name": "simplestatements_begin_writ$subexpression$1", "symbols": ["kw_read", "kw_write"] },
              { "name": "simplestatements_begin_writ$subexpression$1", "symbols": ["kw_read", lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only] },
              { "name": "simplestatements_begin_writ", "symbols": ["simplestatements_begin_writ$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                writeable: toStr(x, " ")
              }) },
              { "name": "simplestatements_begin_def$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "simplestatements_begin_def$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "simplestatements_begin_def", "symbols": ["simplestatements_begin_def$ebnf$1", lexer_1.lexerAny.has("kw_deferrable") ? { type: "kw_deferrable" } : kw_deferrable], "postprocess": (x) => (0, lexer_2.track)(x, {
                deferrable: !x[0]
              }) },
              { "name": "insert_statement$subexpression$1", "symbols": ["kw_insert", lexer_1.lexerAny.has("kw_into") ? { type: "kw_into" } : kw_into] },
              { "name": "insert_statement$ebnf$1", "symbols": ["collist_paren"], "postprocess": id },
              { "name": "insert_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$2$subexpression$1$subexpression$1", "symbols": ["kw_system"] },
              { "name": "insert_statement$ebnf$2$subexpression$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_user") ? { type: "kw_user" } : kw_user] },
              { "name": "insert_statement$ebnf$2$subexpression$1", "symbols": ["kw_overriding", "insert_statement$ebnf$2$subexpression$1$subexpression$1", "kw_value"], "postprocess": get11(1) },
              { "name": "insert_statement$ebnf$2", "symbols": ["insert_statement$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$3$subexpression$1", "symbols": ["selection"] },
              { "name": "insert_statement$ebnf$3$subexpression$1", "symbols": ["selection_paren"] },
              { "name": "insert_statement$ebnf$3", "symbols": ["insert_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$4$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, "kw_conflict", "insert_on_conflict"], "postprocess": last3 },
              { "name": "insert_statement$ebnf$4", "symbols": ["insert_statement$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement$ebnf$5$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning, "select_expr_list_aliased"], "postprocess": last3 },
              { "name": "insert_statement$ebnf$5", "symbols": ["insert_statement$ebnf$5$subexpression$1"], "postprocess": id },
              { "name": "insert_statement$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "insert_statement", "symbols": ["insert_statement$subexpression$1", "table_ref_aliased", "insert_statement$ebnf$1", "insert_statement$ebnf$2", "insert_statement$ebnf$3", "insert_statement$ebnf$4", "insert_statement$ebnf$5"], "postprocess": (x) => {
                const columns = x[2] && x[2].map(asName);
                const overriding = toStr(x[3]);
                const insert = unwrap(x[4]);
                const onConflict = x[5];
                const returning = x[6];
                return (0, lexer_2.track)(x, {
                  type: "insert",
                  into: unwrap(x[1]),
                  insert,
                  ...overriding && { overriding },
                  ...columns && { columns },
                  ...returning && { returning },
                  ...onConflict && { onConflict }
                });
              } },
              { "name": "insert_values$ebnf$1", "symbols": [] },
              { "name": "insert_values$ebnf$1$subexpression$1", "symbols": ["comma", "insert_value"], "postprocess": last3 },
              { "name": "insert_values$ebnf$1", "symbols": ["insert_values$ebnf$1", "insert_values$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "insert_values", "symbols": ["insert_value", "insert_values$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "insert_value", "symbols": ["lparen", "insert_expr_list_raw", "rparen"], "postprocess": get11(1) },
              { "name": "insert_expr_list_raw$ebnf$1", "symbols": [] },
              { "name": "insert_expr_list_raw$ebnf$1$subexpression$1", "symbols": ["comma", "expr_or_select"], "postprocess": last3 },
              { "name": "insert_expr_list_raw$ebnf$1", "symbols": ["insert_expr_list_raw$ebnf$1", "insert_expr_list_raw$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "insert_expr_list_raw", "symbols": ["expr_or_select", "insert_expr_list_raw$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "insert_on_conflict$ebnf$1", "symbols": ["insert_on_conflict_what"], "postprocess": id },
              { "name": "insert_on_conflict$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "insert_on_conflict", "symbols": ["insert_on_conflict$ebnf$1", "insert_on_conflict_do"], "postprocess": (x) => (0, lexer_2.track)(x, {
                ...x[0] ? { on: unwrap(x[0]) } : {},
                ...x[1]
              }) },
              { "name": "insert_on_conflict_what", "symbols": ["lparen", "expr_list_raw", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "on expr",
                exprs: x[1]
              }) },
              { "name": "insert_on_conflict_what", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "qname"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "on constraint",
                constraint: last3(x)
              }) },
              { "name": "insert_on_conflict_do", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do, "kw_nothing"], "postprocess": (x) => ({ do: "do nothing" }) },
              { "name": "insert_on_conflict_do$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do, "kw_update", "kw_set"] },
              { "name": "insert_on_conflict_do$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_where") ? { type: "kw_where" } : kw_where, "expr"], "postprocess": last3 },
              { "name": "insert_on_conflict_do$ebnf$1", "symbols": ["insert_on_conflict_do$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "insert_on_conflict_do$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "insert_on_conflict_do", "symbols": ["insert_on_conflict_do$subexpression$1", "update_set_list", "insert_on_conflict_do$ebnf$1"], "postprocess": (x) => ({
                do: { sets: x[1] },
                ...x[2] && { where: x[2] }
              }) },
              { "name": "update_statement$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from, "select_from_subject"], "postprocess": last3 },
              { "name": "update_statement$ebnf$1", "symbols": ["update_statement$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "update_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "update_statement$ebnf$2", "symbols": ["select_where"], "postprocess": id },
              { "name": "update_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "update_statement$ebnf$3$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning, "select_expr_list_aliased"], "postprocess": last3 },
              { "name": "update_statement$ebnf$3", "symbols": ["update_statement$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "update_statement$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "update_statement", "symbols": ["kw_update", "table_ref_aliased", "kw_set", "update_set_list", "update_statement$ebnf$1", "update_statement$ebnf$2", "update_statement$ebnf$3"], "postprocess": (x) => {
                const from = unwrap(x[4]);
                const where = unwrap(x[5]);
                const returning = x[6];
                return (0, lexer_2.track)(x, {
                  type: "update",
                  table: unwrap(x[1]),
                  sets: x[3],
                  ...where ? { where } : {},
                  ...from ? { from } : {},
                  ...returning ? { returning } : {}
                });
              } },
              { "name": "update_set_list$ebnf$1", "symbols": [] },
              { "name": "update_set_list$ebnf$1$subexpression$1", "symbols": ["comma", "update_set"], "postprocess": last3 },
              { "name": "update_set_list$ebnf$1", "symbols": ["update_set_list$ebnf$1", "update_set_list$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "update_set_list", "symbols": ["update_set", "update_set_list$ebnf$1"], "postprocess": ([head, tail]) => {
                const ret = [];
                for (const _t of [head, ...tail || []]) {
                  const t2 = unwrap(_t);
                  if (Array.isArray(t2)) {
                    ret.push(...t2);
                  } else {
                    ret.push(t2);
                  }
                }
                return ret;
              } },
              { "name": "update_set", "symbols": ["update_set_one"] },
              { "name": "update_set", "symbols": ["update_set_multiple"] },
              { "name": "update_set_one", "symbols": ["ident", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "expr"], "postprocess": (x) => (0, lexer_2.box)(x, {
                column: asName(x[0]),
                value: unwrap(x[2])
              }) },
              { "name": "update_set_multiple$subexpression$1", "symbols": ["lparen", "expr_list_raw", "rparen"], "postprocess": get11(1) },
              { "name": "update_set_multiple", "symbols": ["collist_paren", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "update_set_multiple$subexpression$1"], "postprocess": (x) => {
                const cols = x[0];
                const exprs = x[2];
                if (cols.length !== exprs.length) {
                  throw new Error("number of columns does not match number of values");
                }
                return (0, lexer_2.box)(x, cols.map((x2, i) => ({
                  column: asName(x2),
                  value: unwrap(exprs[i])
                })));
              } },
              { "name": "altertable_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "altertable_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_statement$ebnf$2", "symbols": [lexer_1.lexerAny.has("kw_only") ? { type: "kw_only" } : kw_only], "postprocess": id },
              { "name": "altertable_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_statement", "symbols": ["kw_alter", lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table, "altertable_statement$ebnf$1", "altertable_statement$ebnf$2", "table_ref", "altertable_actions"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "alter table",
                ...x[2] ? { ifExists: true } : {},
                ...x[3] ? { only: true } : {},
                table: unwrap(x[4]),
                changes: (0, lexer_2.unbox)(x[5]).map(unwrap)
              }) },
              { "name": "altertable_actions$ebnf$1", "symbols": [] },
              { "name": "altertable_actions$ebnf$1$subexpression$1", "symbols": ["comma", "altertable_action"], "postprocess": last3 },
              { "name": "altertable_actions$ebnf$1", "symbols": ["altertable_actions$ebnf$1", "altertable_actions$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "altertable_actions", "symbols": ["altertable_action", "altertable_actions$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "altertable_action", "symbols": ["altertable_rename_table"] },
              { "name": "altertable_action", "symbols": ["altertable_rename_column"] },
              { "name": "altertable_action", "symbols": ["altertable_rename_constraint"] },
              { "name": "altertable_action", "symbols": ["altertable_add_column"] },
              { "name": "altertable_action", "symbols": ["altertable_drop_column"] },
              { "name": "altertable_action", "symbols": ["altertable_alter_column"] },
              { "name": "altertable_action", "symbols": ["altertable_add_constraint"] },
              { "name": "altertable_action", "symbols": ["altertable_drop_constraint"] },
              { "name": "altertable_action", "symbols": ["altertable_owner"] },
              { "name": "altertable_rename_table", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename",
                to: asName(last3(x))
              }) },
              { "name": "altertable_rename_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_rename_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_rename_column", "symbols": ["kw_rename", "altertable_rename_column$ebnf$1", "ident", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename column",
                column: asName(x[2]),
                to: asName(last3(x))
              }) },
              { "name": "altertable_rename_constraint", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "ident", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename constraint",
                constraint: asName(x[2]),
                to: asName(last3(x))
              }) },
              { "name": "altertable_add_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_add_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_add_column$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "altertable_add_column$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_add_column", "symbols": ["kw_add", "altertable_add_column$ebnf$1", "altertable_add_column$ebnf$2", "createtable_column"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "add column",
                ...x[2] ? { ifNotExists: true } : {},
                column: unwrap(x[3])
              }) },
              { "name": "altertable_drop_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_drop_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_column$ebnf$2", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "altertable_drop_column$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_column$ebnf$3$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "altertable_drop_column$ebnf$3$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "altertable_drop_column$ebnf$3", "symbols": ["altertable_drop_column$ebnf$3$subexpression$1"], "postprocess": id },
              { "name": "altertable_drop_column$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_column", "symbols": ["kw_drop", "altertable_drop_column$ebnf$1", "altertable_drop_column$ebnf$2", "ident", "altertable_drop_column$ebnf$3"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop column",
                ...x[2] ? { ifExists: true } : {},
                column: asName(x[3]),
                ...x[4] ? { behaviour: toStr(x[4], " ") } : {}
              }) },
              { "name": "altertable_alter_column$ebnf$1", "symbols": ["kw_column"], "postprocess": id },
              { "name": "altertable_alter_column$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_alter_column", "symbols": ["kw_alter", "altertable_alter_column$ebnf$1", "ident", "altercol"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "alter column",
                column: asName(x[2]),
                alter: unwrap(x[3])
              }) },
              { "name": "altercol$ebnf$1$subexpression$1", "symbols": ["kw_set", "kw_data"] },
              { "name": "altercol$ebnf$1", "symbols": ["altercol$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "altercol$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altercol", "symbols": ["altercol$ebnf$1", "kw_type", "data_type"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set type", dataType: unwrap(last3(x)) }) },
              { "name": "altercol", "symbols": ["kw_set", lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default, "expr"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set default", default: unwrap(last3(x)) }) },
              { "name": "altercol", "symbols": ["kw_drop", lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop default" }) },
              { "name": "altercol$subexpression$1", "symbols": ["kw_set"] },
              { "name": "altercol$subexpression$1", "symbols": ["kw_drop"] },
              { "name": "altercol", "symbols": ["altercol$subexpression$1", "kw_not_null"], "postprocess": (x) => (0, lexer_2.track)(x, { type: toStr(x, " ") }) },
              { "name": "altercol", "symbols": ["altercol_generated_add"], "postprocess": unwrap },
              { "name": "altertable_add_constraint", "symbols": ["kw_add", "createtable_constraint"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "add constraint",
                constraint: unwrap(last3(x))
              }) },
              { "name": "altertable_drop_constraint$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "altertable_drop_constraint$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_constraint$ebnf$2$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "altertable_drop_constraint$ebnf$2$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "altertable_drop_constraint$ebnf$2", "symbols": ["altertable_drop_constraint$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "altertable_drop_constraint$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altertable_drop_constraint", "symbols": ["kw_drop", lexer_1.lexerAny.has("kw_constraint") ? { type: "kw_constraint" } : kw_constraint, "altertable_drop_constraint$ebnf$1", "ident", "altertable_drop_constraint$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop constraint",
                ...x[2] ? { ifExists: true } : {},
                constraint: asName(x[3]),
                ...x[4] ? { behaviour: toStr(x[4], " ") } : {}
              }) },
              { "name": "altertable_owner", "symbols": ["kw_owner", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "owner",
                to: asName(last3(x))
              }) },
              { "name": "altercol_generated_add", "symbols": ["kw_add", "altercol_generated"], "postprocess": last3 },
              { "name": "altercol_generated$ebnf$1$subexpression$1", "symbols": ["kw_always"] },
              { "name": "altercol_generated$ebnf$1$subexpression$1", "symbols": ["kw_by", lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default] },
              { "name": "altercol_generated$ebnf$1", "symbols": ["altercol_generated$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "altercol_generated$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altercol_generated$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "kw_identity"] },
              { "name": "altercol_generated$ebnf$2$subexpression$1", "symbols": ["lparen", "altercol_generated_seq", "rparen"], "postprocess": get11(1) },
              { "name": "altercol_generated$ebnf$2", "symbols": ["altercol_generated$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "altercol_generated$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "altercol_generated", "symbols": ["kw_generated", "altercol_generated$ebnf$1", "altercol_generated$subexpression$1", "altercol_generated$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "add generated",
                ...x[1] && { always: toStr(x[1], " ") },
                ...x[3] && { sequence: unwrap(x[3]) }
              }) },
              { "name": "altercol_generated_seq$ebnf$1$subexpression$1", "symbols": ["kw_sequence", "kw_name", "qualified_name"] },
              { "name": "altercol_generated_seq$ebnf$1", "symbols": ["altercol_generated_seq$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "altercol_generated_seq$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "altercol_generated_seq$ebnf$2", "symbols": [] },
              { "name": "altercol_generated_seq$ebnf$2", "symbols": ["altercol_generated_seq$ebnf$2", "create_sequence_option"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "altercol_generated_seq", "symbols": ["altercol_generated_seq$ebnf$1", "altercol_generated_seq$ebnf$2"], "postprocess": (x) => {
                const ret = {
                  ...x[0] && { name: unwrap(last3(x[0])) }
                };
                setSeqOpts(ret, x[1]);
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "alterindex_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "alterindex_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alterindex_statement", "symbols": ["kw_alter", "kw_index", "alterindex_statement$ebnf$1", "table_ref", "alterindex_action"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "alter index",
                ...x[2] ? { ifExists: true } : {},
                index: unwrap(x[3]),
                change: unwrap(x[4])
              }) },
              { "name": "alterindex_action", "symbols": ["alterindex_rename"] },
              { "name": "alterindex_action", "symbols": ["alterindex_set_tablespace"] },
              { "name": "alterindex_rename", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "rename",
                to: asName(last3(x))
              }) },
              { "name": "alterindex_set_tablespace", "symbols": ["kw_set", "kw_tablespace", "word"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "set tablespace",
                tablespace: asName(last3(x))
              }) },
              { "name": "delete_statement", "symbols": ["delete_delete"] },
              { "name": "delete_statement", "symbols": ["delete_truncate"] },
              { "name": "delete_delete$subexpression$1", "symbols": ["kw_delete", lexer_1.lexerAny.has("kw_from") ? { type: "kw_from" } : kw_from] },
              { "name": "delete_delete$ebnf$1", "symbols": ["select_where"], "postprocess": id },
              { "name": "delete_delete$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "delete_delete$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_returning") ? { type: "kw_returning" } : kw_returning, "select_expr_list_aliased"], "postprocess": last3 },
              { "name": "delete_delete$ebnf$2", "symbols": ["delete_delete$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "delete_delete$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "delete_delete", "symbols": ["delete_delete$subexpression$1", "table_ref_aliased", "delete_delete$ebnf$1", "delete_delete$ebnf$2"], "postprocess": (x) => {
                const where = x[2];
                const returning = x[3];
                return (0, lexer_2.track)(x, {
                  type: "delete",
                  from: unwrap(x[1]),
                  ...where ? { where } : {},
                  ...returning ? { returning } : {}
                });
              } },
              { "name": "delete_truncate$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table], "postprocess": id },
              { "name": "delete_truncate$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "delete_truncate$subexpression$1", "symbols": ["kw_truncate", "delete_truncate$subexpression$1$ebnf$1"] },
              { "name": "delete_truncate$macrocall$2", "symbols": ["table_ref"] },
              { "name": "delete_truncate$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "delete_truncate$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "delete_truncate$macrocall$2"], "postprocess": last3 },
              { "name": "delete_truncate$macrocall$1$ebnf$1", "symbols": ["delete_truncate$macrocall$1$ebnf$1", "delete_truncate$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "delete_truncate$macrocall$1", "symbols": ["delete_truncate$macrocall$2", "delete_truncate$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1", "symbols": ["kw_restart"] },
              { "name": "delete_truncate$ebnf$1$subexpression$1$subexpression$1", "symbols": ["kw_continue"] },
              { "name": "delete_truncate$ebnf$1$subexpression$1", "symbols": ["delete_truncate$ebnf$1$subexpression$1$subexpression$1", "kw_identity"] },
              { "name": "delete_truncate$ebnf$1", "symbols": ["delete_truncate$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "delete_truncate$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "delete_truncate$ebnf$2$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "delete_truncate$ebnf$2$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "delete_truncate$ebnf$2", "symbols": ["delete_truncate$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "delete_truncate$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "delete_truncate", "symbols": ["delete_truncate$subexpression$1", "delete_truncate$macrocall$1", "delete_truncate$ebnf$1", "delete_truncate$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "truncate table",
                tables: x[1],
                ...x[2] && { identity: toStr(x[2][0]) },
                ...x[3] && { cascade: toStr(x[3]) }
              }) },
              { "name": "create_sequence_statement$ebnf$1$subexpression$1", "symbols": ["kw_temp"] },
              { "name": "create_sequence_statement$ebnf$1$subexpression$1", "symbols": ["kw_temporary"] },
              { "name": "create_sequence_statement$ebnf$1", "symbols": ["create_sequence_statement$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "create_sequence_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_statement$ebnf$2", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "create_sequence_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_statement$ebnf$3", "symbols": [] },
              { "name": "create_sequence_statement$ebnf$3", "symbols": ["create_sequence_statement$ebnf$3", "create_sequence_option"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_sequence_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "create_sequence_statement$ebnf$1", "kw_sequence", "create_sequence_statement$ebnf$2", "qualified_name", "create_sequence_statement$ebnf$3"], "postprocess": (x) => {
                const ret = {
                  type: "create sequence",
                  ...x[1] && { temp: true },
                  ...x[3] && { ifNotExists: true },
                  name: unwrap(x[4]),
                  options: {}
                };
                setSeqOpts(ret.options, x[5]);
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "create_sequence_option", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "data_type"], "postprocess": (x) => (0, lexer_2.box)(x, ["as", x[1]]) },
              { "name": "create_sequence_option$ebnf$1", "symbols": ["kw_by"], "postprocess": id },
              { "name": "create_sequence_option$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_option", "symbols": ["kw_increment", "create_sequence_option$ebnf$1", "int"], "postprocess": (x) => (0, lexer_2.box)(x, ["incrementBy", x[2]]) },
              { "name": "create_sequence_option", "symbols": ["create_sequence_minvalue"], "postprocess": (x) => (0, lexer_2.box)(x, ["minValue", x[0]]) },
              { "name": "create_sequence_option", "symbols": ["create_sequence_maxvalue"], "postprocess": (x) => (0, lexer_2.box)(x, ["maxValue", x[0]]) },
              { "name": "create_sequence_option$ebnf$2", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with], "postprocess": id },
              { "name": "create_sequence_option$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_option", "symbols": ["kw_start", "create_sequence_option$ebnf$2", "int"], "postprocess": (x) => (0, lexer_2.box)(x, ["startWith", x[2]]) },
              { "name": "create_sequence_option", "symbols": ["kw_cache", "int"], "postprocess": (x) => (0, lexer_2.box)(x, ["cache", x[1]]) },
              { "name": "create_sequence_option$ebnf$3", "symbols": ["kw_no"], "postprocess": id },
              { "name": "create_sequence_option$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "create_sequence_option", "symbols": ["create_sequence_option$ebnf$3", "kw_cycle"], "postprocess": (x) => (0, lexer_2.box)(x, ["cycle", toStr(x, " ")]) },
              { "name": "create_sequence_option", "symbols": ["create_sequence_owned_by"], "postprocess": (x) => (0, lexer_2.box)(x, ["ownedBy", unwrap(x)]) },
              { "name": "create_sequence_minvalue", "symbols": ["kw_minvalue", "int"], "postprocess": last3 },
              { "name": "create_sequence_minvalue", "symbols": ["kw_no", "kw_minvalue"], "postprocess": (x) => (0, lexer_2.box)(x, "no minvalue") },
              { "name": "create_sequence_maxvalue", "symbols": ["kw_maxvalue", "int"], "postprocess": last3 },
              { "name": "create_sequence_maxvalue", "symbols": ["kw_no", "kw_maxvalue"], "postprocess": (x) => (0, lexer_2.box)(x, "no maxvalue") },
              { "name": "create_sequence_owned_by$subexpression$1", "symbols": ["kw_none"] },
              { "name": "create_sequence_owned_by$subexpression$1", "symbols": ["qcolumn"] },
              { "name": "create_sequence_owned_by", "symbols": ["kw_owned", "kw_by", "create_sequence_owned_by$subexpression$1"], "postprocess": (x) => (0, lexer_2.box)(x, unwrap(last3(x))) },
              { "name": "alter_sequence_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "alter_sequence_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alter_sequence_statement", "symbols": ["kw_alter", "kw_sequence", "alter_sequence_statement$ebnf$1", "qualified_name", "alter_sequence_statement_body"], "postprocess": (x) => {
                const ret = {
                  type: "alter sequence",
                  ...x[2] && { ifExists: true },
                  name: unwrap(x[3]),
                  change: x[4]
                };
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "alter_sequence_statement_body$ebnf$1", "symbols": ["alter_sequence_option"] },
              { "name": "alter_sequence_statement_body$ebnf$1", "symbols": ["alter_sequence_statement_body$ebnf$1", "alter_sequence_option"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "alter_sequence_statement_body", "symbols": ["alter_sequence_statement_body$ebnf$1"], "postprocess": (x) => {
                const ret = {
                  type: "set options"
                };
                setSeqOpts(ret, x[0]);
                return (0, lexer_2.track)(x, ret);
              } },
              { "name": "alter_sequence_statement_body$subexpression$1", "symbols": ["ident"] },
              { "name": "alter_sequence_statement_body$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_session_user") ? { type: "kw_session_user" } : kw_session_user] },
              { "name": "alter_sequence_statement_body$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_current_user") ? { type: "kw_current_user" } : kw_current_user] },
              { "name": "alter_sequence_statement_body", "symbols": ["kw_owner", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "alter_sequence_statement_body$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "owner to", owner: asName(last3(x)) }) },
              { "name": "alter_sequence_statement_body", "symbols": ["kw_rename", lexer_1.lexerAny.has("kw_to") ? { type: "kw_to" } : kw_to, "ident"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "rename", newName: asName(last3(x)) }) },
              { "name": "alter_sequence_statement_body", "symbols": ["kw_set", "kw_schema", "ident"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "set schema", newSchema: asName(last3(x)) }) },
              { "name": "alter_sequence_option", "symbols": ["create_sequence_option"], "postprocess": unwrap },
              { "name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with], "postprocess": id },
              { "name": "alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alter_sequence_option$ebnf$1$subexpression$1", "symbols": ["alter_sequence_option$ebnf$1$subexpression$1$ebnf$1", "int"], "postprocess": last3 },
              { "name": "alter_sequence_option$ebnf$1", "symbols": ["alter_sequence_option$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "alter_sequence_option$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "alter_sequence_option", "symbols": ["kw_restart", "alter_sequence_option$ebnf$1"], "postprocess": (x) => (0, lexer_2.box)(x, ["restart", typeof (0, lexer_2.unbox)(x[1]) === "number" ? (0, lexer_2.unbox)(x[1]) : true]) },
              { "name": "drop_statement$ebnf$1", "symbols": ["kw_ifexists"], "postprocess": id },
              { "name": "drop_statement$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_statement$macrocall$2", "symbols": ["qualified_name"] },
              { "name": "drop_statement$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "drop_statement$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "drop_statement$macrocall$2"], "postprocess": last3 },
              { "name": "drop_statement$macrocall$1$ebnf$1", "symbols": ["drop_statement$macrocall$1$ebnf$1", "drop_statement$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "drop_statement$macrocall$1", "symbols": ["drop_statement$macrocall$2", "drop_statement$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "drop_statement$ebnf$2$subexpression$1", "symbols": ["kw_cascade"] },
              { "name": "drop_statement$ebnf$2$subexpression$1", "symbols": ["kw_restrict"] },
              { "name": "drop_statement$ebnf$2", "symbols": ["drop_statement$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "drop_statement$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "drop_statement", "symbols": ["kw_drop", "drop_what", "drop_statement$ebnf$1", "drop_statement$macrocall$1", "drop_statement$ebnf$2"], "postprocess": (x, rej) => {
                const v = unwrap(x[1]);
                return (0, lexer_2.track)(x, {
                  ...v,
                  ...x[2] && { ifExists: true },
                  names: x[3],
                  ...x[4] && { cascade: toStr(x[4]) }
                });
              } },
              { "name": "drop_what", "symbols": [lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop table" }) },
              { "name": "drop_what", "symbols": ["kw_sequence"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop sequence" }) },
              { "name": "drop_what", "symbols": ["kw_type"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop type" }) },
              { "name": "drop_what", "symbols": ["kw_trigger"], "postprocess": (x) => (0, lexer_2.track)(x, { type: "drop trigger" }) },
              { "name": "drop_what$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_concurrently") ? { type: "kw_concurrently" } : kw_concurrently], "postprocess": id },
              { "name": "drop_what$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_what", "symbols": ["kw_index", "drop_what$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop index",
                ...x[1] && { concurrently: true }
              }) },
              { "name": "with_statement", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "with_statement_bindings", "with_statement_statement"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "with",
                bind: x[1],
                in: unwrap(x[2])
              }) },
              { "name": "with_recursive_statement$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "kw_recursive"] },
              { "name": "with_recursive_statement", "symbols": ["with_recursive_statement$subexpression$1", "ident", "collist_paren", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "lparen", "union_statement", "rparen", "with_statement_statement"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "with recursive",
                alias: asName(x[1]),
                columnNames: x[2].map(asName),
                bind: x[5],
                in: unwrap(x[7])
              }) },
              { "name": "with_statement_bindings$ebnf$1", "symbols": [] },
              { "name": "with_statement_bindings$ebnf$1$subexpression$1", "symbols": ["comma", "with_statement_binding"], "postprocess": last3 },
              { "name": "with_statement_bindings$ebnf$1", "symbols": ["with_statement_bindings$ebnf$1", "with_statement_bindings$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "with_statement_bindings", "symbols": ["with_statement_binding", "with_statement_bindings$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "with_statement_binding", "symbols": ["word", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "lparen", "with_statement_statement", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                alias: asName(x[0]),
                statement: unwrap(x[3])
              }) },
              { "name": "with_statement_statement", "symbols": ["selection"] },
              { "name": "with_statement_statement", "symbols": ["insert_statement"] },
              { "name": "with_statement_statement", "symbols": ["update_statement"] },
              { "name": "with_statement_statement", "symbols": ["delete_statement"] },
              { "name": "createtype_statement$subexpression$1", "symbols": ["createtype_enum"] },
              { "name": "createtype_statement$subexpression$1", "symbols": ["createtype_composite"] },
              { "name": "createtype_statement", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_type", "qualified_name", "createtype_statement$subexpression$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                name: x[2],
                ...unwrap(x[3])
              }) },
              { "name": "createtype_enum$macrocall$2", "symbols": ["enum_value"] },
              { "name": "createtype_enum$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createtype_enum$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createtype_enum$macrocall$2"], "postprocess": last3 },
              { "name": "createtype_enum$macrocall$1$ebnf$1", "symbols": ["createtype_enum$macrocall$1$ebnf$1", "createtype_enum$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtype_enum$macrocall$1", "symbols": ["createtype_enum$macrocall$2", "createtype_enum$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createtype_enum", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "kw_enum", "lparen", "createtype_enum$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create enum",
                values: x[3]
              }) },
              { "name": "enum_value", "symbols": ["string"], "postprocess": (x) => (0, lexer_2.track)(x, { value: toStr(x) }) },
              { "name": "createtype_composite$macrocall$2", "symbols": ["createtype_composite_attr"] },
              { "name": "createtype_composite$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "createtype_composite$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "createtype_composite$macrocall$2"], "postprocess": last3 },
              { "name": "createtype_composite$macrocall$1$ebnf$1", "symbols": ["createtype_composite$macrocall$1$ebnf$1", "createtype_composite$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "createtype_composite$macrocall$1", "symbols": ["createtype_composite$macrocall$2", "createtype_composite$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "createtype_composite", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "lparen", "createtype_composite$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "create composite type",
                attributes: x[2]
              }) },
              { "name": "createtype_composite_attr$ebnf$1", "symbols": ["createtable_collate"], "postprocess": id },
              { "name": "createtype_composite_attr$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "createtype_composite_attr", "symbols": ["word", "data_type", "createtype_composite_attr$ebnf$1"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  name: asName(x[0]),
                  dataType: x[1],
                  ...x[2] ? { collate: x[2][1] } : {}
                });
              } },
              { "name": "union_left", "symbols": ["select_statement"] },
              { "name": "union_left", "symbols": ["select_values"] },
              { "name": "union_left", "symbols": ["selection_paren"] },
              { "name": "union_right", "symbols": ["selection"] },
              { "name": "union_right", "symbols": ["selection_paren"] },
              { "name": "union_statement$subexpression$1$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all], "postprocess": id },
              { "name": "union_statement$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "union_statement$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_union") ? { type: "kw_union" } : kw_union, "union_statement$subexpression$1$ebnf$1"] },
              { "name": "union_statement", "symbols": ["union_left", "union_statement$subexpression$1", "union_right"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: toStr(x[1], " "),
                  left: unwrap(x[0]),
                  right: unwrap(x[2])
                });
              } },
              { "name": "prepare$ebnf$1$subexpression$1", "symbols": ["lparen", "data_type_list", "rparen"], "postprocess": get11(1) },
              { "name": "prepare$ebnf$1", "symbols": ["prepare$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "prepare$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "prepare", "symbols": ["kw_prepare", "ident", "prepare$ebnf$1", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "statement_noprep"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "prepare",
                name: asName(x[1]),
                ...x[2] && { args: x[2] },
                statement: unwrap(last3(x))
              }) },
              { "name": "deallocate$ebnf$1", "symbols": ["kw_prepare"], "postprocess": id },
              { "name": "deallocate$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "deallocate", "symbols": ["kw_deallocate", "deallocate$ebnf$1", "deallocate_target"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "deallocate",
                target: x[2]
              }) },
              { "name": "deallocate_target", "symbols": ["deallocate_all"], "postprocess": unwrap },
              { "name": "deallocate_target", "symbols": ["deallocate_name"], "postprocess": unwrap },
              { "name": "deallocate_name", "symbols": ["ident"], "postprocess": (x) => (0, lexer_2.track)(x, asName(x[0])) },
              { "name": "deallocate_all", "symbols": [lexer_1.lexerAny.has("kw_all") ? { type: "kw_all" } : kw_all], "postprocess": (x) => (0, lexer_2.track)(x, { option: "all" }) },
              { "name": "create_view_statements", "symbols": ["create_view"] },
              { "name": "create_view_statements", "symbols": ["create_materialized_view"] },
              { "name": "create_view$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or, "kw_replace"] },
              { "name": "create_view$ebnf$1", "symbols": ["create_view$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$2$subexpression$1", "symbols": ["kw_temp"] },
              { "name": "create_view$ebnf$2$subexpression$1", "symbols": ["kw_temporary"] },
              { "name": "create_view$ebnf$2", "symbols": ["create_view$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$3", "symbols": ["kw_recursive"], "postprocess": id },
              { "name": "create_view$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$2", "symbols": ["ident"] },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_view$ebnf$4$subexpression$1$macrocall$2"], "postprocess": last3 },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "symbols": ["create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1", "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_view$ebnf$4$subexpression$1$macrocall$1", "symbols": ["create_view$ebnf$4$subexpression$1$macrocall$2", "create_view$ebnf$4$subexpression$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_view$ebnf$4$subexpression$1", "symbols": ["lparen", "create_view$ebnf$4$subexpression$1$macrocall$1", "rparen"], "postprocess": get11(1) },
              { "name": "create_view$ebnf$4", "symbols": ["create_view$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$5", "symbols": ["create_view_opts"], "postprocess": id },
              { "name": "create_view$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "create_view$ebnf$6$subexpression$1$subexpression$1", "symbols": ["kw_local"] },
              { "name": "create_view$ebnf$6$subexpression$1$subexpression$1", "symbols": ["kw_cascaded"] },
              { "name": "create_view$ebnf$6$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "create_view$ebnf$6$subexpression$1$subexpression$1", lexer_1.lexerAny.has("kw_check") ? { type: "kw_check" } : kw_check, "kw_option"], "postprocess": get11(1) },
              { "name": "create_view$ebnf$6", "symbols": ["create_view$ebnf$6$subexpression$1"], "postprocess": id },
              { "name": "create_view$ebnf$6", "symbols": [], "postprocess": () => null },
              { "name": "create_view", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "create_view$ebnf$1", "create_view$ebnf$2", "create_view$ebnf$3", "kw_view", "qualified_name", "create_view$ebnf$4", "create_view$ebnf$5", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "selection", "create_view$ebnf$6"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "create view",
                  ...x[1] && { orReplace: true },
                  ...x[2] && { temp: true },
                  ...x[3] && { recursive: true },
                  name: x[5],
                  ...x[6] && { columnNames: x[6].map(asName) },
                  ...x[7] && { parameters: fromEntries(x[7]) },
                  query: x[9],
                  ...x[10] && { checkOption: toStr(x[10]) }
                });
              } },
              { "name": "create_view_opt", "symbols": ["ident", lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "ident"], "postprocess": ([a, _, b]) => [toStr(a), toStr(b)] },
              { "name": "create_view_opts$macrocall$2", "symbols": ["create_view_opt"] },
              { "name": "create_view_opts$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_view_opts$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_view_opts$macrocall$2"], "postprocess": last3 },
              { "name": "create_view_opts$macrocall$1$ebnf$1", "symbols": ["create_view_opts$macrocall$1$ebnf$1", "create_view_opts$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_view_opts$macrocall$1", "symbols": ["create_view_opts$macrocall$2", "create_view_opts$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_view_opts", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "create_view_opts$macrocall$1"], "postprocess": last3 },
              { "name": "create_materialized_view$ebnf$1", "symbols": ["kw_ifnotexists"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$2", "symbols": ["ident"] },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_materialized_view$ebnf$2$subexpression$1$macrocall$2"], "postprocess": last3 },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "symbols": ["create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_materialized_view$ebnf$2$subexpression$1$macrocall$1", "symbols": ["create_materialized_view$ebnf$2$subexpression$1$macrocall$2", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_materialized_view$ebnf$2$subexpression$1", "symbols": ["lparen", "create_materialized_view$ebnf$2$subexpression$1$macrocall$1", "rparen"], "postprocess": get11(1) },
              { "name": "create_materialized_view$ebnf$2", "symbols": ["create_materialized_view$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$3", "symbols": ["create_view_opts"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$3", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$4$subexpression$1", "symbols": ["kw_tablespace", "ident"], "postprocess": last3 },
              { "name": "create_materialized_view$ebnf$4", "symbols": ["create_materialized_view$ebnf$4$subexpression$1"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$4", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "symbols": ["kw_no"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view$ebnf$5$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "create_materialized_view$ebnf$5$subexpression$1$ebnf$1", "kw_data"] },
              { "name": "create_materialized_view$ebnf$5", "symbols": ["create_materialized_view$ebnf$5$subexpression$1"], "postprocess": id },
              { "name": "create_materialized_view$ebnf$5", "symbols": [], "postprocess": () => null },
              { "name": "create_materialized_view", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "kw_materialized", "kw_view", "create_materialized_view$ebnf$1", "qualified_name", "create_materialized_view$ebnf$2", "create_materialized_view$ebnf$3", "create_materialized_view$ebnf$4", lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "selection", "create_materialized_view$ebnf$5"], "postprocess": (x) => {
                return (0, lexer_2.track)(x, {
                  type: "create materialized view",
                  ...x[3] && { ifNotExists: true },
                  name: x[4],
                  ...x[5] && { columnNames: x[6].map(asName) },
                  ...x[6] && { parameters: fromEntries(x[6]) },
                  ...x[7] && { tablespace: asName(x[7]) },
                  query: x[9],
                  ...x[10] && { withData: toStr(x[10][1]) !== "no" }
                });
              } },
              { "name": "refresh_view_statements$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_concurrently") ? { type: "kw_concurrently" } : kw_concurrently], "postprocess": id },
              { "name": "refresh_view_statements$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "symbols": ["kw_no"], "postprocess": id },
              { "name": "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "refresh_view_statements$ebnf$2$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_with") ? { type: "kw_with" } : kw_with, "refresh_view_statements$ebnf$2$subexpression$1$ebnf$1", "kw_data"] },
              { "name": "refresh_view_statements$ebnf$2", "symbols": ["refresh_view_statements$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "refresh_view_statements$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "refresh_view_statements", "symbols": ["kw_refresh", "kw_materialized", "kw_view", "refresh_view_statements$ebnf$1", "qname", "refresh_view_statements$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "refresh materialized view",
                ...!!x[3] ? { concurrently: true } : {},
                name: x[4],
                ...!!x[5] ? { withData: toStr(x[5][1]) !== "no" } : {}
              }) },
              { "name": "functions_statements", "symbols": ["create_func"] },
              { "name": "functions_statements", "symbols": ["do_stm"] },
              { "name": "functions_statements", "symbols": ["drop_func"] },
              { "name": "create_func$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("kw_or") ? { type: "kw_or" } : kw_or, "kw_replace"] },
              { "name": "create_func$ebnf$1", "symbols": ["create_func$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "create_func$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$2", "symbols": ["func_argdef"] },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "create_func$subexpression$1$ebnf$1$macrocall$2"], "postprocess": last3 },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1", "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_func$subexpression$1$ebnf$1$macrocall$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$2", "create_func$subexpression$1$ebnf$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "create_func$subexpression$1$ebnf$1", "symbols": ["create_func$subexpression$1$ebnf$1$macrocall$1"], "postprocess": id },
              { "name": "create_func$subexpression$1$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "create_func$subexpression$1", "symbols": ["lparen", "create_func$subexpression$1$ebnf$1", "rparen"], "postprocess": get11(1) },
              { "name": "create_func$ebnf$2", "symbols": ["func_spec"] },
              { "name": "create_func$ebnf$2", "symbols": ["create_func$ebnf$2", "func_spec"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "create_func", "symbols": [lexer_1.lexerAny.has("kw_create") ? { type: "kw_create" } : kw_create, "create_func$ebnf$1", "kw_function", "qname", "create_func$subexpression$1", "create_func$ebnf$2"], "postprocess": (x, rej) => {
                var _a;
                const specs = {};
                for (const s of x[5]) {
                  for (const k in s) {
                    if (k[0] !== "_" && k in specs) {
                      throw new Error("conflicting or redundant options " + k);
                    }
                  }
                  Object.assign(specs, s);
                }
                return (0, lexer_2.track)(x, {
                  type: "create function",
                  ...x[1] && { orReplace: true },
                  name: x[3],
                  arguments: (_a = x[4]) !== null && _a !== void 0 ? _a : [],
                  ...specs
                });
              } },
              { "name": "func_argdef$ebnf$1", "symbols": ["func_argopts"], "postprocess": id },
              { "name": "func_argdef$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "func_argdef$ebnf$2", "symbols": ["func_argdefault"], "postprocess": id },
              { "name": "func_argdef$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "func_argdef", "symbols": ["func_argdef$ebnf$1", "data_type", "func_argdef$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                default: x[2],
                type: x[1],
                ...x[0]
              }) },
              {
                "name": "func_argdefault",
                "symbols": [lexer_1.lexerAny.has("kw_default") ? { type: "kw_default" } : kw_default, "expr"],
                "postprocess": (x) => x[1]
              },
              { "name": "func_argdefault", "symbols": [lexer_1.lexerAny.has("op_eq") ? { type: "op_eq" } : op_eq, "expr"], "postprocess": (x) => x[1] },
              { "name": "func_argopts$ebnf$1", "symbols": ["word"], "postprocess": id },
              { "name": "func_argopts$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "func_argopts", "symbols": ["func_argmod", "func_argopts$ebnf$1"], "postprocess": (x) => (0, lexer_2.track)(x, {
                mode: toStr(x[0]),
                ...x[1] && { name: asName(x[1]) }
              }) },
              { "name": "func_argopts", "symbols": ["word"], "postprocess": (x, rej) => {
                const name = asName(x);
                if (name === "out" || name === "inout" || name === "variadic") {
                  return rej;
                }
                return (0, lexer_2.track)(x, { name });
              } },
              { "name": "func_argmod", "symbols": [lexer_1.lexerAny.has("kw_in") ? { type: "kw_in" } : kw_in] },
              { "name": "func_argmod", "symbols": ["kw_out"] },
              { "name": "func_argmod", "symbols": ["kw_inout"] },
              { "name": "func_argmod", "symbols": ["kw_variadic"] },
              { "name": "func_spec", "symbols": ["kw_language", "word"], "postprocess": (x) => (0, lexer_2.track)(x, { language: asName(last3(x)) }) },
              { "name": "func_spec", "symbols": ["func_purity"], "postprocess": (x) => (0, lexer_2.track)(x, { purity: toStr(x) }) },
              { "name": "func_spec$subexpression$1", "symbols": [lexer_1.lexerAny.has("codeblock") ? { type: "codeblock" } : codeblock] },
              { "name": "func_spec$subexpression$1", "symbols": ["string"] },
              { "name": "func_spec", "symbols": [lexer_1.lexerAny.has("kw_as") ? { type: "kw_as" } : kw_as, "func_spec$subexpression$1"], "postprocess": (x) => ({ code: toStr(last3(x)) }) },
              { "name": "func_spec$ebnf$1", "symbols": [lexer_1.lexerAny.has("kw_not") ? { type: "kw_not" } : kw_not], "postprocess": id },
              { "name": "func_spec$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "func_spec$subexpression$2", "symbols": ["word"], "postprocess": kw("leakproof") },
              { "name": "func_spec", "symbols": ["func_spec$ebnf$1", "func_spec$subexpression$2"], "postprocess": (x) => (0, lexer_2.track)(x, { leakproof: !x[0] }) },
              { "name": "func_spec", "symbols": ["func_returns"], "postprocess": (x) => (0, lexer_2.track)(x, { returns: unwrap(x) }) },
              { "name": "func_spec$subexpression$3", "symbols": ["word"], "postprocess": kw("called") },
              { "name": "func_spec", "symbols": ["func_spec$subexpression$3", "oninp"], "postprocess": () => ({ onNullInput: "call" }) },
              { "name": "func_spec$subexpression$4", "symbols": ["word"], "postprocess": kw("returns") },
              { "name": "func_spec", "symbols": ["func_spec$subexpression$4", lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null, "oninp"], "postprocess": () => ({ onNullInput: "null" }) },
              { "name": "func_spec$subexpression$5", "symbols": ["word"], "postprocess": kw("strict") },
              { "name": "func_spec", "symbols": ["func_spec$subexpression$5"], "postprocess": () => ({ onNullInput: "strict" }) },
              { "name": "func_purity", "symbols": ["word"], "postprocess": kw("immutable") },
              { "name": "func_purity", "symbols": ["word"], "postprocess": kw("stable") },
              { "name": "func_purity", "symbols": ["word"], "postprocess": kw("volatile") },
              { "name": "oninp$subexpression$1", "symbols": ["word"], "postprocess": kw("input") },
              { "name": "oninp", "symbols": [lexer_1.lexerAny.has("kw_on") ? { type: "kw_on" } : kw_on, lexer_1.lexerAny.has("kw_null") ? { type: "kw_null" } : kw_null, "oninp$subexpression$1"] },
              { "name": "func_returns", "symbols": ["kw_returns", "data_type"], "postprocess": last3 },
              { "name": "func_returns$macrocall$2", "symbols": ["func_ret_table_col"] },
              { "name": "func_returns$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "func_returns$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "func_returns$macrocall$2"], "postprocess": last3 },
              { "name": "func_returns$macrocall$1$ebnf$1", "symbols": ["func_returns$macrocall$1$ebnf$1", "func_returns$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "func_returns$macrocall$1", "symbols": ["func_returns$macrocall$2", "func_returns$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "func_returns", "symbols": ["kw_returns", lexer_1.lexerAny.has("kw_table") ? { type: "kw_table" } : kw_table, "lparen", "func_returns$macrocall$1", "rparen"], "postprocess": (x) => (0, lexer_2.track)(x, {
                kind: "table",
                columns: x[3]
              }) },
              { "name": "func_ret_table_col", "symbols": ["word", "data_type"], "postprocess": (x) => (0, lexer_2.track)(x, { name: asName(x[0]), type: x[1] }) },
              { "name": "do_stm$ebnf$1$subexpression$1", "symbols": ["kw_language", "word"], "postprocess": last3 },
              { "name": "do_stm$ebnf$1", "symbols": ["do_stm$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "do_stm$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "do_stm", "symbols": [lexer_1.lexerAny.has("kw_do") ? { type: "kw_do" } : kw_do, "do_stm$ebnf$1", lexer_1.lexerAny.has("codeblock") ? { type: "codeblock" } : codeblock], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "do",
                ...x[1] && { language: asName(x[1]) },
                code: x[2].value
              }) },
              { "name": "drop_func$ebnf$1$subexpression$1", "symbols": ["kw_if", "kw_exists"] },
              { "name": "drop_func$ebnf$1", "symbols": ["drop_func$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "drop_func$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_func$ebnf$2", "symbols": ["drop_func_overload"], "postprocess": id },
              { "name": "drop_func$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "drop_func", "symbols": ["kw_drop", "kw_function", "drop_func$ebnf$1", "qname", "drop_func$ebnf$2"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: "drop function",
                ...x[2] && { ifExists: true },
                name: x[3],
                ...x[4] && { arguments: x[4] }
              }) },
              { "name": "drop_func_overload$macrocall$2", "symbols": ["drop_func_overload_col"] },
              { "name": "drop_func_overload$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "drop_func_overload$macrocall$1$ebnf$1$subexpression$1", "symbols": [lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "drop_func_overload$macrocall$2"], "postprocess": last3 },
              { "name": "drop_func_overload$macrocall$1$ebnf$1", "symbols": ["drop_func_overload$macrocall$1$ebnf$1", "drop_func_overload$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "drop_func_overload$macrocall$1", "symbols": ["drop_func_overload$macrocall$2", "drop_func_overload$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "drop_func_overload", "symbols": ["lparen", "drop_func_overload$macrocall$1", "rparen"], "postprocess": get11(1) },
              { "name": "drop_func_overload_col$ebnf$1", "symbols": ["word"], "postprocess": id },
              { "name": "drop_func_overload_col$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "drop_func_overload_col", "symbols": ["drop_func_overload_col$ebnf$1", "qname"], "postprocess": (x) => (0, lexer_2.track)(x, {
                type: x[1],
                ...x[0] && { name: asName(x[0]) }
              }) },
              { "name": "main$ebnf$1", "symbols": [] },
              { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2", "symbols": [] },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["statement_separator"] },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2$subexpression$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "statement"] },
              { "name": "main$ebnf$2", "symbols": ["main$ebnf$2", "main$ebnf$2$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$3", "symbols": [] },
              { "name": "main$ebnf$3", "symbols": ["main$ebnf$3", "statement_separator"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main", "symbols": ["main$ebnf$1", "statement", "main$ebnf$2", "main$ebnf$3"], "postprocess": ([_, head, _tail]) => {
                const tail = _tail;
                const ret = [unwrap(head), ...tail.map((x) => unwrap(x[1]))];
                return ret.length === 1 ? ret[0] : ret;
              } },
              { "name": "statement_separator", "symbols": [lexer_1.lexerAny.has("semicolon") ? { type: "semicolon" } : semicolon] },
              { "name": "statement", "symbols": ["statement_noprep"] },
              { "name": "statement", "symbols": ["prepare"] },
              { "name": "statement", "symbols": ["deallocate"] },
              { "name": "statement_noprep", "symbols": ["selection"] },
              { "name": "statement_noprep", "symbols": ["createtable_statement"] },
              { "name": "statement_noprep", "symbols": ["createextension_statement"] },
              { "name": "statement_noprep", "symbols": ["createindex_statement"] },
              { "name": "statement_noprep", "symbols": ["simplestatements_all"] },
              { "name": "statement_noprep", "symbols": ["insert_statement"] },
              { "name": "statement_noprep", "symbols": ["update_statement"] },
              { "name": "statement_noprep", "symbols": ["altertable_statement"] },
              { "name": "statement_noprep", "symbols": ["alterindex_statement"] },
              { "name": "statement_noprep", "symbols": ["delete_statement"] },
              { "name": "statement_noprep", "symbols": ["create_sequence_statement"] },
              { "name": "statement_noprep", "symbols": ["alter_sequence_statement"] },
              { "name": "statement_noprep", "symbols": ["drop_statement"] },
              { "name": "statement_noprep", "symbols": ["createtype_statement"] },
              { "name": "statement_noprep", "symbols": ["create_view_statements"] },
              { "name": "statement_noprep", "symbols": ["refresh_view_statements"] },
              { "name": "statement_noprep", "symbols": ["create_schema"] },
              { "name": "statement_noprep", "symbols": ["raise_statement"] },
              { "name": "statement_noprep", "symbols": ["comment_statement"] },
              { "name": "statement_noprep", "symbols": ["functions_statements"] },
              { "name": "selection", "symbols": ["select_statement"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["select_values"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["with_statement"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["with_recursive_statement"], "postprocess": unwrap },
              { "name": "selection", "symbols": ["union_statement"], "postprocess": unwrap },
              { "name": "selection_paren", "symbols": ["lparen", "selection", "rparen"], "postprocess": get11(1) }
            ],
            ParserStart: "main"
          };
          exports2.default = grammar;
        },
        /* 11 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const array_lexer_1 = __webpack_require__(12);
          const get11 = (i) => (x) => x[i];
          const last3 = (x) => x && x[x.length - 1];
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: array_lexer_1.lexerAny,
            ParserRules: [
              { "name": "main$ebnf$1", "symbols": ["elements"], "postprocess": id },
              { "name": "main$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "main", "symbols": [array_lexer_1.lexerAny.has("start_list") ? { type: "start_list" } : start_list, "main$ebnf$1", array_lexer_1.lexerAny.has("end_list") ? { type: "end_list" } : end_list], "postprocess": (x) => x[1] || [] },
              { "name": "elements$ebnf$1", "symbols": [] },
              { "name": "elements$ebnf$1$subexpression$1", "symbols": [array_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "elt"], "postprocess": last3 },
              { "name": "elements$ebnf$1", "symbols": ["elements$ebnf$1", "elements$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "elements", "symbols": ["elt", "elements$ebnf$1"], "postprocess": ([head, tail]) => {
                return [head, ...tail || []];
              } },
              { "name": "elt", "symbols": [array_lexer_1.lexerAny.has("value") ? { type: "value" } : value], "postprocess": (x) => x[0].value },
              { "name": "elt", "symbols": ["main"], "postprocess": (x) => x[0] }
            ],
            ParserStart: "main"
          };
          exports2.default = grammar;
        },
        /* 12 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            valueString: {
              match: /"(?:\\["\\]|[^\n"\\])*"/,
              value: (x) => JSON.parse(x),
              type: (x) => "value"
            },
            valueRaw: {
              match: /[^\s,\{\}"](?:[^,\{\}"]*[^\s,\{\}"])?/,
              type: () => "value"
            },
            comma: ",",
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            start_list: "{",
            end_list: "}"
          });
          exports2.lexer.next = ((next) => () => {
            let tok;
            while ((tok = next.call(exports2.lexer)) && tok.type === "space") {
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
        },
        /* 13 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const geometric_lexer_1 = __webpack_require__(14);
          const get11 = (i) => (x) => x[i];
          const last3 = (x) => x && x[x.length - 1];
          function unwrap(e) {
            if (Array.isArray(e) && e.length === 1) {
              e = unwrap(e[0]);
            }
            if (Array.isArray(e) && !e.length) {
              return null;
            }
            return e;
          }
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: geometric_lexer_1.lexerAny,
            ParserRules: [
              { "name": "number$subexpression$1", "symbols": ["float"] },
              { "name": "number$subexpression$1", "symbols": ["int"] },
              { "name": "number", "symbols": ["number$subexpression$1"], "postprocess": unwrap },
              { "name": "float", "symbols": [geometric_lexer_1.lexerAny.has("float") ? { type: "float" } : float], "postprocess": (args) => parseFloat(unwrap(args)) },
              { "name": "int", "symbols": [geometric_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": (arg) => parseInt(unwrap(arg), 10) },
              { "name": "comma", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma], "postprocess": id },
              { "name": "point$macrocall$2", "symbols": ["point_content"] },
              { "name": "point$macrocall$1$subexpression$1", "symbols": ["point$macrocall$2"] },
              { "name": "point$macrocall$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen, "point$macrocall$2", geometric_lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen], "postprocess": get11(1) },
              { "name": "point$macrocall$1", "symbols": ["point$macrocall$1$subexpression$1"], "postprocess": unwrap },
              { "name": "point", "symbols": ["point$macrocall$1"], "postprocess": unwrap },
              { "name": "point_content", "symbols": ["number", "comma", "number"], "postprocess": (x) => ({ x: x[0], y: x[2] }) },
              { "name": "line", "symbols": [geometric_lexer_1.lexerAny.has("lcurl") ? { type: "lcurl" } : lcurl, "number", "comma", "number", "comma", "number", geometric_lexer_1.lexerAny.has("rcurl") ? { type: "rcurl" } : rcurl], "postprocess": (x) => ({
                a: x[1],
                b: x[3],
                c: x[5]
              }) },
              { "name": "box", "symbols": ["closed_path"], "postprocess": ([x], rej) => {
                if (x.length !== 2) {
                  return rej;
                }
                return x;
              } },
              { "name": "lseg", "symbols": ["path"], "postprocess": ([x], rej) => {
                if (x.path.length !== 2) {
                  return rej;
                }
                return x.path;
              } },
              { "name": "path", "symbols": ["open_path"], "postprocess": ([path]) => ({ closed: false, path }) },
              { "name": "path", "symbols": ["closed_path"], "postprocess": ([path]) => ({ closed: true, path }) },
              { "name": "open_path$macrocall$2", "symbols": [geometric_lexer_1.lexerAny.has("lbracket") ? { type: "lbracket" } : lbracket] },
              { "name": "open_path$macrocall$3", "symbols": [geometric_lexer_1.lexerAny.has("rbracket") ? { type: "rbracket" } : rbracket] },
              { "name": "open_path$macrocall$1$macrocall$2", "symbols": ["point"] },
              { "name": "open_path$macrocall$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "open_path$macrocall$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "open_path$macrocall$1$macrocall$2"], "postprocess": last3 },
              { "name": "open_path$macrocall$1$macrocall$1$ebnf$1", "symbols": ["open_path$macrocall$1$macrocall$1$ebnf$1", "open_path$macrocall$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "open_path$macrocall$1$macrocall$1", "symbols": ["open_path$macrocall$1$macrocall$2", "open_path$macrocall$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "open_path$macrocall$1", "symbols": ["open_path$macrocall$2", "open_path$macrocall$1$macrocall$1", "open_path$macrocall$3"], "postprocess": get11(1) },
              { "name": "open_path", "symbols": ["open_path$macrocall$1"], "postprocess": last3 },
              { "name": "closed_path$subexpression$1$macrocall$2", "symbols": [geometric_lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen] },
              { "name": "closed_path$subexpression$1$macrocall$3", "symbols": [geometric_lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen] },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$2", "symbols": ["point"] },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1", "symbols": [] },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "closed_path$subexpression$1$macrocall$1$macrocall$2"], "postprocess": last3 },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1", "symbols": ["closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1", "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "closed_path$subexpression$1$macrocall$1$macrocall$1", "symbols": ["closed_path$subexpression$1$macrocall$1$macrocall$2", "closed_path$subexpression$1$macrocall$1$macrocall$1$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "closed_path$subexpression$1$macrocall$1", "symbols": ["closed_path$subexpression$1$macrocall$2", "closed_path$subexpression$1$macrocall$1$macrocall$1", "closed_path$subexpression$1$macrocall$3"], "postprocess": get11(1) },
              { "name": "closed_path$subexpression$1", "symbols": ["closed_path$subexpression$1$macrocall$1"], "postprocess": last3 },
              { "name": "closed_path$subexpression$1$macrocall$5", "symbols": ["point"] },
              { "name": "closed_path$subexpression$1$macrocall$4$ebnf$1", "symbols": [] },
              { "name": "closed_path$subexpression$1$macrocall$4$ebnf$1$subexpression$1", "symbols": [geometric_lexer_1.lexerAny.has("comma") ? { type: "comma" } : comma, "closed_path$subexpression$1$macrocall$5"], "postprocess": last3 },
              { "name": "closed_path$subexpression$1$macrocall$4$ebnf$1", "symbols": ["closed_path$subexpression$1$macrocall$4$ebnf$1", "closed_path$subexpression$1$macrocall$4$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "closed_path$subexpression$1$macrocall$4", "symbols": ["closed_path$subexpression$1$macrocall$5", "closed_path$subexpression$1$macrocall$4$ebnf$1"], "postprocess": ([head, tail]) => {
                return [unwrap(head), ...tail.map(unwrap) || []];
              } },
              { "name": "closed_path$subexpression$1", "symbols": ["closed_path$subexpression$1$macrocall$4"], "postprocess": last3 },
              { "name": "closed_path", "symbols": ["closed_path$subexpression$1"], "postprocess": get11(0) },
              { "name": "polygon", "symbols": ["closed_path"], "postprocess": get11(0) },
              { "name": "circle_body", "symbols": ["point", "comma", "number"], "postprocess": (x) => ({ c: x[0], r: x[2] }) },
              { "name": "circle$subexpression$1$macrocall$2", "symbols": [geometric_lexer_1.lexerAny.has("lcomp") ? { type: "lcomp" } : lcomp] },
              { "name": "circle$subexpression$1$macrocall$3", "symbols": [geometric_lexer_1.lexerAny.has("rcomp") ? { type: "rcomp" } : rcomp] },
              { "name": "circle$subexpression$1$macrocall$1", "symbols": ["circle$subexpression$1$macrocall$2", "circle_body", "circle$subexpression$1$macrocall$3"], "postprocess": get11(1) },
              { "name": "circle$subexpression$1", "symbols": ["circle$subexpression$1$macrocall$1"] },
              { "name": "circle$subexpression$1$macrocall$5", "symbols": [geometric_lexer_1.lexerAny.has("lparen") ? { type: "lparen" } : lparen] },
              { "name": "circle$subexpression$1$macrocall$6", "symbols": [geometric_lexer_1.lexerAny.has("rparen") ? { type: "rparen" } : rparen] },
              { "name": "circle$subexpression$1$macrocall$4", "symbols": ["circle$subexpression$1$macrocall$5", "circle_body", "circle$subexpression$1$macrocall$6"], "postprocess": get11(1) },
              { "name": "circle$subexpression$1", "symbols": ["circle$subexpression$1$macrocall$4"] },
              { "name": "circle$subexpression$1", "symbols": ["circle_body"] },
              { "name": "circle", "symbols": ["circle$subexpression$1"], "postprocess": unwrap }
            ],
            ParserStart: "number"
          };
          exports2.default = grammar;
        },
        /* 14 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            comma: ",",
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            int: /\-?\d+(?![\.\d])/,
            float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
            lcurl: "{",
            rcurl: "}",
            lparen: "(",
            rparen: ")",
            lbracket: "[",
            rbracket: "]",
            lcomp: "<",
            rcomp: ">"
          });
          exports2.lexer.next = ((next) => () => {
            let tok;
            while ((tok = next.call(exports2.lexer)) && tok.type === "space") {
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
        },
        /* 15 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const interval_lexer_1 = __webpack_require__(16);
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: interval_lexer_1.lexerAny,
            ParserRules: [
              { "name": "main$ebnf$1", "symbols": ["elt"] },
              { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "elt"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main", "symbols": ["main$ebnf$1"], "postprocess": ([elts]) => {
                const s = /* @__PURE__ */ new Set();
                for (const e of elts) {
                  const k = typeof e[1] === "number" ? e[0] : "time";
                  if (s.has(k)) {
                    return "invalid";
                  }
                  s.add(k);
                }
                return elts;
              } },
              { "name": "elt", "symbols": ["time"] },
              { "name": "elt", "symbols": ["num", "unit"], "postprocess": ([[n], u]) => {
                u = u[0].type;
                return [u, n];
              } },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("years") ? { type: "years" } : years] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("months") ? { type: "months" } : months] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("days") ? { type: "days" } : days] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("hours") ? { type: "hours" } : hours] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("minutes") ? { type: "minutes" } : minutes] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("seconds") ? { type: "seconds" } : seconds] },
              { "name": "unit", "symbols": [interval_lexer_1.lexerAny.has("milliseconds") ? { type: "milliseconds" } : milliseconds] },
              { "name": "num", "symbols": ["int"] },
              { "name": "num", "symbols": ["float"] },
              { "name": "uint", "symbols": [interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": ([x]) => parseInt(x, 10) },
              { "name": "int$ebnf$1$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("neg") ? { type: "neg" } : neg] },
              { "name": "int$ebnf$1", "symbols": ["int$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "int$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "int", "symbols": ["int$ebnf$1", interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": ([neg3, x]) => parseInt(x, 10) * (neg3 ? -1 : 1) },
              { "name": "float$ebnf$1$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("neg") ? { type: "neg" } : neg] },
              { "name": "float$ebnf$1", "symbols": ["float$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "float$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "float$ebnf$2", "symbols": [interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": id },
              { "name": "float$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "float", "symbols": ["float$ebnf$1", "float$ebnf$2", interval_lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot, interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int], "postprocess": ([neg3, ...v]) => parseFloat(v.map((v2) => v2 ? v2.text : "0").join("")) * (neg3 ? -1 : 1) },
              { "name": "time$ebnf$1$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("colon") ? { type: "colon" } : colon, "uint"] },
              { "name": "time$ebnf$1", "symbols": ["time$ebnf$1$subexpression$1"], "postprocess": id },
              { "name": "time$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "time$ebnf$2$subexpression$1", "symbols": [interval_lexer_1.lexerAny.has("dot") ? { type: "dot" } : dot, interval_lexer_1.lexerAny.has("int") ? { type: "int" } : int] },
              { "name": "time$ebnf$2", "symbols": ["time$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "time$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "time", "symbols": ["uint", interval_lexer_1.lexerAny.has("colon") ? { type: "colon" } : colon, "uint", "time$ebnf$1", "time$ebnf$2"], "postprocess": ([a, _, b, c, d]) => {
                c = c && c[1];
                d = d && d[1];
                const ret = typeof c === "number" ? [
                  ["hours", a],
                  ["minutes", b],
                  ["seconds", c]
                ] : [
                  ["minutes", a],
                  ["seconds", b]
                ];
                if (d) {
                  ret.push(["milliseconds", parseFloat("0." + d) * 1e3]);
                }
                return ret;
              } }
            ],
            ParserStart: "main"
          };
          exports2.default = grammar;
        },
        /* 16 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            int: /\d+/,
            neg: "-",
            dot: ".",
            years: /(?:y|yrs?|years?)\b/,
            months: /(?:mon(?:th)?s?)\b/,
            days: /(?:d|days?)\b/,
            hours: /(?:h|hrs?|hours?)\b/,
            minutes: /(?:m|mins?|minutes?)\b/,
            seconds: /(?:s|secs?|seconds?)\b/,
            milliseconds: /(?:ms|milliseconds?)\b/,
            space: { match: /[\s\t\n\v\f\r]+/, lineBreaks: true },
            colon: ":"
          });
          exports2.lexer.next = ((next) => () => {
            let tok;
            while ((tok = next.call(exports2.lexer)) && tok.type === "space") {
            }
            return tok;
          })(exports2.lexer.next);
          exports2.lexerAny = exports2.lexer;
        },
        /* 17 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          function id(d) {
            return d[0];
          }
          const interval_iso_lexer_1 = __webpack_require__(18);
          ;
          ;
          ;
          ;
          const grammar = {
            Lexer: interval_iso_lexer_1.lexerAny,
            ParserRules: [
              { "name": "num", "symbols": [interval_iso_lexer_1.lexerAny.has("int") ? { type: "int" } : int] },
              { "name": "num", "symbols": [interval_iso_lexer_1.lexerAny.has("float") ? { type: "float" } : float] },
              { "name": "main$ebnf$1", "symbols": [] },
              { "name": "main$ebnf$1", "symbols": ["main$ebnf$1", "long"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["short"] },
              { "name": "main$ebnf$2$subexpression$1$ebnf$1", "symbols": ["main$ebnf$2$subexpression$1$ebnf$1", "short"], "postprocess": (d) => d[0].concat([d[1]]) },
              { "name": "main$ebnf$2$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("T") ? { type: "T" } : T, "main$ebnf$2$subexpression$1$ebnf$1"] },
              { "name": "main$ebnf$2", "symbols": ["main$ebnf$2$subexpression$1"], "postprocess": id },
              { "name": "main$ebnf$2", "symbols": [], "postprocess": () => null },
              { "name": "main", "symbols": [interval_iso_lexer_1.lexerAny.has("P") ? { type: "P" } : P, "main$ebnf$1", "main$ebnf$2"], "postprocess": ([_, a, b], rej) => {
                b = !b ? [] : b[1];
                {
                }
                if (!a.length && !b.length) {
                  return rej;
                }
                return !a.length ? b : !b.length ? a : [...a, ...b];
              } },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("Y") ? { type: "Y" } : Y] },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("M") ? { type: "M" } : M] },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("W") ? { type: "W" } : W] },
              { "name": "long$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("D") ? { type: "D" } : D] },
              { "name": "long", "symbols": ["num", "long$subexpression$1"], "postprocess": ([n, u]) => {
                n = parseFloat(n[0].value);
                u = u[0].type;
                switch (u) {
                  case "Y":
                    return ["years", n];
                  case "M":
                    return ["months", n];
                  case "W":
                    return ["days", n * 7];
                  case "D":
                    return ["days", n];
                  default:
                    throw new Error("Unexpected unit " + u);
                }
              } },
              { "name": "short$ebnf$1", "symbols": [interval_iso_lexer_1.lexerAny.has("T") ? { type: "T" } : T], "postprocess": id },
              { "name": "short$ebnf$1", "symbols": [], "postprocess": () => null },
              { "name": "short$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("H") ? { type: "H" } : H] },
              { "name": "short$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("M") ? { type: "M" } : M] },
              { "name": "short$subexpression$1", "symbols": [interval_iso_lexer_1.lexerAny.has("S") ? { type: "S" } : S] },
              { "name": "short", "symbols": ["short$ebnf$1", "num", "short$subexpression$1"], "postprocess": ([_, n, u]) => {
                n = parseFloat(n[0].value);
                u = u[0].type;
                switch (u) {
                  case "H":
                    return ["hours", n];
                  case "M":
                    return ["minutes", n];
                  case "S":
                    return ["seconds", n];
                  default:
                    throw new Error("Unexpected unit " + u);
                }
              } }
            ],
            ParserStart: "num"
          };
          exports2.default = grammar;
        },
        /* 18 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.lexerAny = exports2.lexer = void 0;
          const moo_1 = __webpack_require__(0);
          exports2.lexer = (0, moo_1.compile)({
            int: /\-?\d+(?![\.\d])/,
            float: /\-?(?:(?:\d*\.\d+)|(?:\d+\.\d*))/,
            P: "P",
            Y: "Y",
            M: "M",
            W: "W",
            D: "D",
            H: "H",
            S: "S",
            T: "T"
          });
          exports2.lexerAny = exports2.lexer;
        },
        /* 19 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.toSql = void 0;
          const ast_mapper_1 = __webpack_require__(2);
          const ast_visitor_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(6);
          const pg_escape_1 = __webpack_require__(20);
          const keywords_1 = __webpack_require__(3);
          const kwSet = new Set(keywords_1.sqlKeywords.map((x) => x.toLowerCase()));
          let ret = [];
          function name(nm) {
            return ident(nm.name);
          }
          function ident(nm, forceDoubleQuote) {
            if (!forceDoubleQuote) {
              const low = nm.toLowerCase();
              if (low === nm && !kwSet.has(low) && /^[a-z][a-z0-9_]*$/.test(low)) {
                return nm;
              }
            }
            return '"' + nm + '"';
          }
          function list(elems, act, addParen) {
            if (addParen) {
              ret.push("(");
            }
            let first3 = true;
            for (const e of elems) {
              if (!first3) {
                ret.push(", ");
              }
              first3 = false;
              act(e);
            }
            if (addParen) {
              ret.push(")");
            }
          }
          function addConstraint(c, m) {
            switch (c.type) {
              case "foreign key":
                ret.push(" foreign key (", ...c.localColumns.map(name).join(", "), ")");
              case "reference":
                ret.push(" REFERENCES ");
                m.tableRef(c.foreignTable);
                ret.push("(", ...c.foreignColumns.map(name).join(", "), ") ");
                if (c.match) {
                  ret.push(" MATCH ", c.match.toUpperCase());
                }
                if (c.onDelete) {
                  ret.push(" ON DELETE ", c.onDelete);
                }
                if (c.onUpdate) {
                  ret.push(" ON UPDATE ", c.onUpdate);
                }
                break;
              case "primary key":
              case "unique":
                ret.push(" ", c.type, " ");
                if ("columns" in c) {
                  ret.push("(", ...c.columns.map(name).join(", "), ") ");
                }
                break;
              case "check":
                ret.push(" check ");
                m.expr(c.expr);
                break;
              case "not null":
              case "null":
                ret.push(" ", c.type, " ");
                break;
              case "default":
                ret.push(" default ");
                m.expr(c.default);
                break;
              case "add generated":
                ret.push(" GENERATED ");
                visitGenerated(m, c);
                break;
              default:
                throw utils_1.NotSupported.never(c);
            }
            ret.push(" ");
          }
          function visitQualifiedName(cs, forceDoubleQuote) {
            if (cs.schema) {
              ret.push(ident(cs.schema), ".");
            }
            ret.push(ident(cs.name, forceDoubleQuote), " ");
          }
          function visitQualifiedNameAliased(cs) {
            visitQualifiedName(cs);
            if (cs.alias) {
              ret.push(" AS ", ident(cs.alias), " ");
            }
          }
          function visitOrderBy(m, orderBy) {
            ret.push(" ORDER BY ");
            list(orderBy, (e) => {
              m.expr(e.by);
              if (e.order) {
                ret.push(" ", e.order, " ");
              }
              if (e.nulls) {
                ret.push(" NULLS ", e.nulls, " ");
              }
            }, false);
          }
          function visitSetVal(set3) {
            switch (set3.type) {
              case "default":
                ret.push("DEFAULT ");
                break;
              case "identifier":
                ret.push(set3.name);
                break;
              case "list":
                let first3 = true;
                for (const v of set3.values) {
                  if (!first3) {
                    ret.push(", ");
                  }
                  first3 = false;
                  visitSetVal(v);
                }
                break;
              case "value":
                ret.push(typeof set3.value === "number" ? set3.value.toString() : (0, pg_escape_1.literal)(set3.value));
                break;
              default:
                throw utils_1.NotSupported.never(set3);
            }
          }
          function visitGenerated(m, alter) {
            if (alter.always) {
              ret.push(alter.always.toUpperCase(), " ");
            }
            ret.push("AS IDENTITY ");
            if (alter.sequence) {
              ret.push("(");
              if (alter.sequence.name) {
                ret.push("SEQUENCE NAME ");
                visitQualifiedName(alter.sequence.name);
                ret.push(" ");
              }
              visitSeqOpts(m, alter.sequence);
              ret.push(") ");
            }
          }
          function visitSeqOpts(m, cs) {
            if (cs.as) {
              ret.push("AS ");
              m.dataType(cs.as);
              ret.push(" ");
            }
            if (typeof cs.incrementBy === "number") {
              ret.push("INCREMENT BY ", cs.incrementBy.toString(), " ");
            }
            if (cs.minValue === "no minvalue") {
              ret.push("NO MINVALUE ");
            }
            if (typeof cs.minValue === "number") {
              ret.push("MINVALUE ", cs.minValue.toString(), " ");
            }
            if (cs.maxValue === "no maxvalue") {
              ret.push("NO MAXVALUE ");
            }
            if (typeof cs.maxValue === "number") {
              ret.push("MAXVALUE ", cs.maxValue.toString(), " ");
            }
            if (typeof cs.startWith === "number") {
              ret.push("START WITH ", cs.startWith.toString(), " ");
            }
            if (typeof cs.cache === "number") {
              ret.push("CACHE ", cs.cache.toString(), " ");
            }
            if (cs.cycle) {
              ret.push(cs.cycle, " ");
            }
            if (cs.ownedBy === "none") {
              ret.push("OWNED BY NONE ");
            } else if (cs.ownedBy) {
              ret.push("OWNED BY ");
              visitQColumn(cs.ownedBy);
            }
            if ("restart" in cs) {
              if (cs.restart === true) {
                ret.push("RESTART ");
              } else if (cs.restart) {
                ret.push("RESTART WITH ", cs.restart.toString(), " ");
              }
            }
          }
          function visitQColumn(col) {
            if (col.schema) {
              ret.push(ident(col.schema), ".");
            }
            ret.push(ident(col.table), ".", ident(col.column), " ");
          }
          function join3(m, j, tbl) {
            if (!j) {
              tbl();
              return;
            }
            ret.push(j.type, " ");
            tbl();
            if (j.on) {
              ret.push("ON ");
              m.expr(j.on);
            }
            if (j.using) {
              ret.push("USING (");
              list(j.using, (x) => ret.push(name(x)), false);
              ret.push(") ");
            }
            ret.push(" ");
          }
          function visitOp(v) {
            if (v.opSchema) {
              ret.push(" operator(", ident(v.opSchema), ".", v.op, ") ");
            } else {
              ret.push(" ", v.op, " ");
            }
          }
          const visitor = (0, ast_visitor_1.astVisitor)((m) => ({
            addColumn: (...args) => {
              ret.push(" ADD COLUMN ");
              if (args[0].ifNotExists) {
                ret.push("IF NOT EXISTS ");
              }
              m.super().addColumn(...args);
            },
            createExtension: (e) => {
              ret.push("CREATE EXTENSION ");
              if (e.ifNotExists) {
                ret.push(" IF NOT EXISTS ");
              }
              ret.push(name(e.extension));
              if (!e.from && !e.version && !e.schema) {
                return;
              }
              ret.push(" WITH");
              if (e.schema) {
                ret.push(" SCHEMA ", name(e.schema));
              }
              if (e.version) {
                ret.push(" VERSION ", (0, pg_escape_1.literal)(e.version.value));
              }
              if (e.from) {
                ret.push(" FROM ", (0, pg_escape_1.literal)(e.from.value));
              }
            },
            tablespace: (t2) => {
              ret.push("TABLESPACE ", name(t2.tablespace));
            },
            addConstraint: (c) => {
              ret.push(" ADD ");
              const cname = c.constraint.constraintName;
              if (cname) {
                ret.push(" CONSTRAINT ", name(cname), " ");
              }
              addConstraint(c.constraint, m);
            },
            alterColumn: (c, t2) => {
              ret.push(" ALTER COLUMN ", name(c.column), " ");
              m.super().alterColumn(c, t2);
            },
            setColumnDefault: (a, t2, c) => {
              ret.push(" SET DEFAULT ");
              m.expr(a.default);
              if (a.updateExisting) {
                throw new Error("Not implemented: updateExisting on set column default");
              }
            },
            createEnum: (t2) => {
              ret.push("CREATE TYPE ");
              visitQualifiedName(t2.name);
              ret.push(" AS ENUM ");
              list(t2.values, (x) => ret.push((0, pg_escape_1.literal)(x.value)), true);
              ret.push(" ");
            },
            createCompositeType: (c) => {
              ret.push("CREATE TYPE ");
              visitQualifiedName(c.name);
              ret.push(" AS ");
              list(c.attributes, (x) => {
                ret.push(name(x.name), " ");
                m.dataType(x.dataType);
                if (x.collate) {
                  ret.push("COLLATE ");
                  visitQualifiedName(x.collate);
                }
              }, true);
              ret.push(" ");
            },
            setTableOwner: (o) => {
              ret.push(" OWNER TO ", name(o.to));
            },
            alterColumnSimple: (c) => ret.push(c.type),
            alterColumnAddGenerated: (alter) => {
              ret.push(" ADD GENERATED ");
              visitGenerated(m, alter);
            },
            setColumnType: (t2) => {
              ret.push(" SET DATA TYPE ");
              m.dataType(t2.dataType);
              ret.push(" ");
            },
            alterTable: (t2) => {
              ret.push("ALTER TABLE ");
              if (t2.ifExists) {
                ret.push(" IF EXISTS ");
              }
              if (t2.only) {
                ret.push(" ONLY ");
              }
              visitQualifiedNameAliased(t2.table);
              list(t2.changes, (change) => m.tableAlteration(change, t2.table), false);
            },
            alterIndex: (t2) => {
              ret.push("ALTER INDEX ");
              if (t2.ifExists) {
                ret.push(" IF EXISTS ");
              }
              visitQualifiedNameAliased(t2.index);
              switch (t2.change.type) {
                case "rename":
                  ret.push(" RENAME TO ");
                  visitQualifiedName(t2.change.to);
                  ret.push(" ");
                  break;
                case "set tablespace":
                  ret.push(" SET TABLESPACE ");
                  visitQualifiedName(t2.change.tablespace);
                  ret.push(" ");
                  break;
                default:
                  throw utils_1.NotSupported.never(t2.change, "Alter index type not supported: ");
              }
            },
            tableAlteration: (change, table) => {
              switch (change.type) {
                case "add column":
                  return m.addColumn(change, table);
                case "add constraint":
                  return m.addConstraint(change, table);
                case "alter column":
                  return m.alterColumn(change, table);
                case "rename":
                  return m.renameTable(change, table);
                case "rename column":
                  return m.renameColumn(change, table);
                case "rename constraint":
                  return m.renameConstraint(change, table);
                case "drop column":
                  return m.dropColumn(change, table);
                case "drop constraint":
                  return m.dropConstraint(change, table);
                case "owner":
                  return m.setTableOwner(change, table);
                default:
                  throw utils_1.NotSupported.never(change);
              }
            },
            array: (v) => {
              ret.push(v.type === "array" ? "ARRAY[" : "(");
              list(v.expressions, (e) => m.expr(e), false);
              ret.push(v.type === "array" ? "]" : ")");
            },
            arrayIndex: (v) => {
              m.expr(v.array);
              ret.push("[");
              m.expr(v.index);
              ret.push("] ");
            },
            expr: (e) => {
              if (e.type === "ref") {
                m.ref(e);
                return;
              }
              if (e.type === "list") {
                m.super().expr(e);
                return;
              }
              ret.push("(");
              m.super().expr(e);
              ret.push(")");
            },
            callOverlay: (o) => {
              ret.push("OVERLAY(");
              m.expr(o.value);
              ret.push(" PLACING ");
              m.expr(o.placing);
              ret.push(" FROM ");
              m.expr(o.from);
              if (o.for) {
                ret.push(" FOR ");
                m.expr(o.for);
              }
              ret.push(")");
            },
            callSubstring: (s) => {
              ret.push("SUBSTRING(");
              m.expr(s.value);
              if (s.from) {
                ret.push(" FROM ");
                m.expr(s.from);
              }
              if (s.for) {
                ret.push(" FOR ");
                m.expr(s.for);
              }
              ret.push(")");
            },
            binary: (v) => {
              m.expr(v.left);
              visitOp(v);
              m.expr(v.right);
            },
            call: (v) => {
              visitQualifiedName(v.function);
              ret.push("(");
              if (v.distinct) {
                ret.push(v.distinct, " ");
              }
              list(v.args, (e) => m.expr(e), false);
              if (v.orderBy) {
                visitOrderBy(m, v.orderBy);
              }
              ret.push(") ");
              if (v.filter) {
                ret.push("filter (where ");
                m.expr(v.filter);
                ret.push(") ");
              }
              if (v.over) {
                ret.push("over (");
                if (v.over.partitionBy) {
                  ret.push("PARTITION BY ");
                  list(v.over.partitionBy, (x) => m.expr(x), false);
                  ret.push(" ");
                }
                if (v.over.orderBy) {
                  visitOrderBy(m, v.over.orderBy);
                  ret.push(" ");
                }
                ret.push(") ");
              }
            },
            case: (c) => {
              ret.push("CASE ");
              if (c.value) {
                m.expr(c.value);
              }
              for (const e of c.whens) {
                ret.push(" WHEN ");
                m.expr(e.when);
                ret.push(" THEN ");
                m.expr(e.value);
              }
              if (c.else) {
                ret.push(" ELSE ");
                m.expr(c.else);
              }
              ret.push(" END ");
            },
            cast: (c) => {
              m.expr(c.operand);
              ret.push("::");
              m.dataType(c.to);
            },
            constant: (c) => {
              switch (c.type) {
                case "boolean":
                  ret.push(c.value ? "true" : "false");
                  break;
                case "integer":
                  ret.push(c.value.toString(10));
                  break;
                case "numeric":
                  ret.push(c.value.toString());
                  if (Number.isInteger(c.value)) {
                    ret.push(".");
                  }
                  break;
                case "null":
                  ret.push("null");
                  break;
                case "constant":
                  break;
                case "string":
                  ret.push((0, pg_escape_1.literal)(c.value));
                  break;
                default:
                  throw utils_1.NotSupported.never(c);
              }
            },
            valueKeyword: (v) => {
              ret.push(v.keyword, " ");
            },
            comment: (c) => {
              ret.push("COMMENT ON ", c.on.type.toUpperCase(), " ");
              switch (c.on.type) {
                case "column":
                  visitQColumn(c.on.column);
                  break;
                default:
                  visitQualifiedName(c.on.name);
                  break;
              }
              ret.push(" IS ", (0, pg_escape_1.literal)(c.comment), " ");
            },
            extract: (v) => {
              ret.push("EXTRACT (", v.field.name.toUpperCase(), " FROM ");
              m.expr(v.from);
              ret.push(") ");
            },
            createColumn: (c) => {
              var _a;
              ret.push(name(c.name), " ");
              m.dataType(c.dataType);
              ret.push(" ");
              if (c.collate) {
                ret.push("COLLATE ");
                visitQualifiedName(c.collate);
              }
              for (const cst of (_a = c.constraints) !== null && _a !== void 0 ? _a : []) {
                m.constraint(cst);
              }
            },
            begin: (beg) => {
              ret.push("BEGIN ");
              if (beg.isolationLevel) {
                ret.push("ISOLATION LEVEL ", beg.isolationLevel.toUpperCase(), " ");
              }
              if (beg.writeable) {
                ret.push(beg.writeable.toUpperCase(), " ");
              }
              if (typeof beg.deferrable === "boolean") {
                if (!beg.deferrable) {
                  ret.push("NOT ");
                }
                ret.push("DEFERRABLE ");
              }
            },
            alterSequence: (cs) => {
              ret.push("ALTER SEQUENCE ");
              if (cs.ifExists) {
                ret.push("IF EXISTS ");
              }
              visitQualifiedName(cs.name);
              switch (cs.change.type) {
                case "set options":
                  visitSeqOpts(m, cs.change);
                  break;
                case "rename":
                  ret.push("RENAME TO ", name(cs.change.newName), " ");
                  break;
                case "set schema":
                  ret.push("SET SCHEMA ", name(cs.change.newSchema), " ");
                  break;
                case "owner to":
                  const own = cs.change.owner;
                  ret.push("OWNER TO ", name(cs.change.owner), " ");
                  break;
                default:
                  throw utils_1.NotSupported.never(cs.change);
              }
            },
            createSequence: (cs) => {
              ret.push("CREATE ");
              if (cs.temp) {
                ret.push("TEMPORARY ");
              }
              ret.push("SEQUENCE ");
              if (cs.ifNotExists) {
                ret.push("IF NOT EXISTS ");
              }
              visitQualifiedName(cs.name);
              visitSeqOpts(m, cs.options);
            },
            drop: (val) => {
              ret.push(val.type.toUpperCase(), " ");
              if (val.concurrently) {
                ret.push("CONCURRENTLY ");
              }
              if (val.ifExists) {
                ret.push("IF EXISTS ");
              }
              list(val.names, (x) => m.tableRef(x), false);
              if (val.cascade) {
                ret.push(val.cascade.toUpperCase(), " ");
              }
            },
            constraint: (cst) => {
              if (cst.constraintName) {
                ret.push(" CONSTRAINT ", name(cst.constraintName), " ");
              }
              addConstraint(cst, m);
            },
            do: (d) => {
              ret.push("DO");
              if (d.language) {
                ret.push(" LANGUAGE ", d.language.name);
              }
              ret.push(" $$", d.code, "$$");
            },
            createFunction: (c) => {
              var _a;
              ret.push(c.orReplace ? "CREATE OR REPLACE FUNCTION " : "CREATE FUNCTION ");
              visitQualifiedName(c.name);
              list(c.arguments, (a) => {
                if (a.mode) {
                  ret.push(a.mode, " ");
                }
                if (a.name) {
                  ret.push(name(a.name), " ");
                }
                m.dataType(a.type);
                if (a.default) {
                  ret.push(" = ");
                  m.expr(a.default);
                }
              }, true);
              if (c.returns) {
                switch (c.returns.kind) {
                  case "table":
                    ret.push(" RETURNS TABLE ");
                    list(c.returns.columns, (t2) => {
                      ret.push(name(t2.name), " ");
                      m.dataType(t2.type);
                    }, true);
                    break;
                  case void 0:
                  case null:
                  case "array":
                    ret.push(" RETURNS ");
                    m.dataType(c.returns);
                    break;
                  default:
                    throw utils_1.NotSupported.never(c.returns);
                }
              }
              ret.push(" AS $$", (_a = c.code) !== null && _a !== void 0 ? _a : "", "$$");
              if (c.language) {
                ret.push("LANGUAGE ", c.language.name, " ");
              }
              if (c.purity) {
                ret.push(c.purity.toUpperCase(), " ");
              }
              if (typeof c.leakproof === "boolean") {
                ret.push(c.leakproof ? "LEAKPROOF " : "NOT LEAKPROOF ");
              }
              switch (c.onNullInput) {
                case "call":
                  ret.push("CALLED ON NULL INPUT ");
                  break;
                case "null":
                  ret.push("RETURNS NULL ON NULL INPUT ");
                  break;
                case "strict":
                  ret.push("STRICT ");
                  break;
                case null:
                case void 0:
                  break;
                default:
                  throw utils_1.NotSupported.never(c.onNullInput);
              }
            },
            dropFunction: (d) => {
              ret.push("DROP FUNCTION ");
              if (d.ifExists) {
                ret.push("IF EXISTS ");
              }
              visitQualifiedName(d.name);
              if (d.arguments) {
                list(d.arguments, (a) => {
                  if (a.name) {
                    visitQualifiedName(a.name);
                    ret.push(" ");
                  }
                  m.dataType(a.type);
                }, true);
              }
              ret.push(" ");
            },
            with: (w) => {
              ret.push("WITH ");
              list(w.bind, (b) => {
                ret.push(name(b.alias), " AS (");
                m.statement(b.statement);
                ret.push(") ");
              }, false);
              m.statement(w.in);
            },
            withRecursive: (val) => {
              ret.push("WITH RECURSIVE ", name(val.alias), "(", ...val.columnNames.map(name).join(", "), ") AS (");
              m.union(val.bind);
              ret.push(") ");
              m.statement(val.in);
            },
            setGlobal: (g) => {
              ret.push("SET ", name(g.variable), " = ");
              visitSetVal(g.set);
            },
            setTimezone: (g) => {
              ret.push("SET TIME ZONE ");
              switch (g.to.type) {
                case "default":
                case "local":
                  ret.push(g.to.type.toUpperCase(), " ");
                  break;
                case "value":
                  ret.push(typeof g.to.value === "string" ? (0, pg_escape_1.literal)(g.to.value) : g.to.value.toString(10));
                  break;
                case "interval":
                  ret.push("INTERVAL ", (0, pg_escape_1.literal)(g.to.value), " HOUR TO MINUTE");
                  break;
                default:
                  throw utils_1.NotSupported.never(g.to);
              }
            },
            dataType: (d) => {
              var _a, _b;
              if ((d === null || d === void 0 ? void 0 : d.kind) === "array") {
                m.dataType(d.arrayOf);
                ret.push("[]");
                return;
              }
              if (!(d === null || d === void 0 ? void 0 : d.name)) {
                ret.push("unkown");
                return;
              }
              let appendConfig = true;
              if (d.schema) {
                visitQualifiedName(d, d.doubleQuoted);
              } else {
                if (d.doubleQuoted) {
                  visitQualifiedName(d, true);
                } else {
                  switch (d.name) {
                    case "double precision":
                    case "character varying":
                    case "bit varying":
                      ret.push(d.name, " ");
                      break;
                    case "time without time zone":
                    case "timestamp without time zone":
                    case "time with time zone":
                    case "timestamp with time zone":
                      const parts = d.name.split(" ");
                      ret.push(parts.shift());
                      if ((_a = d.config) === null || _a === void 0 ? void 0 : _a.length) {
                        list(d.config, (v) => ret.push(v.toString(10)), true);
                      }
                      ret.push(" ");
                      ret.push(parts.join(" "), " ");
                      appendConfig = false;
                      break;
                    default:
                      visitQualifiedName(d);
                      break;
                  }
                }
              }
              if (appendConfig && ((_b = d.config) === null || _b === void 0 ? void 0 : _b.length)) {
                list(d.config, (v) => ret.push(v.toString(10)), true);
              }
            },
            createIndex: (c) => {
              ret.push(c.unique ? "CREATE UNIQUE INDEX " : "CREATE INDEX ");
              if (c.ifNotExists) {
                ret.push(" IF NOT EXISTS ");
              }
              if (c.indexName) {
                ret.push(name(c.indexName), " ");
              }
              ret.push("ON ");
              m.tableRef(c.table);
              if (c.using) {
                ret.push("USING ", name(c.using), " ");
              }
              list(c.expressions, (e) => {
                m.expr(e.expression);
                ret.push(" ");
                if (e.collate) {
                  ret.push("COLLATE ");
                  visitQualifiedName(e.collate);
                }
                if (e.opclass) {
                  visitQualifiedName(e.opclass);
                }
                if (e.order) {
                  ret.push(e.order, " ");
                }
                if (e.nulls) {
                  ret.push("nulls ", e.nulls, " ");
                }
              }, true);
              if (c.with) {
                ret.push("WITH ");
                list(c.with, (w) => {
                  ret.push(w.parameter, " = ", (0, pg_escape_1.literal)(w.value));
                }, true);
              }
              if (c.tablespace) {
                ret.push("TABLESPACE ", ident(c.tablespace));
              }
              if (c.where) {
                ret.push(" WHERE ");
                m.expr(c.where);
              }
              ret.push(" ");
            },
            createTable: (t2) => {
              var _a;
              ret.push("CREATE ");
              if (t2.locality) {
                ret.push(t2.locality.toUpperCase(), " ");
              }
              if (t2.temporary) {
                ret.push("TEMPORARY ");
              }
              if (t2.unlogged) {
                ret.push("UNLOGGED ");
              }
              ret.push(t2.ifNotExists ? "TABLE IF NOT EXISTS " : "TABLE ");
              m.tableRef(t2.name);
              ret.push("(");
              list(t2.columns, (c) => {
                switch (c.kind) {
                  case "column":
                    return m.createColumn(c);
                  case "like table":
                    return m.likeTable(c);
                  default:
                    throw utils_1.NotSupported.never(c);
                }
              }, false);
              if (t2.constraints) {
                ret.push(", ");
                list(t2.constraints, (c) => {
                  const cname = c.constraintName;
                  if (cname) {
                    ret.push("CONSTRAINT ", name(cname), " ");
                  }
                  addConstraint(c, m);
                }, false);
              }
              ret.push(") ");
              if ((_a = t2.inherits) === null || _a === void 0 ? void 0 : _a.length) {
                ret.push(" INHERITS ");
                list(t2.inherits, (i) => visitQualifiedName(i), true);
              }
            },
            likeTable: (l) => {
              ret.push(" LIKE ");
              m.tableRef(l.like);
              ret.push(" ");
              for (const { verb, option } of l.options) {
                ret.push(verb.toUpperCase(), " ", option.toUpperCase(), " ");
              }
            },
            createSchema: (s) => {
              ret.push(s.ifNotExists ? "CREATE SCHEMA IF NOT EXISTS " : "CREATE SCHEMA ");
              ret.push(name(s.name));
            },
            truncateTable: (t2) => {
              ret.push("TRUNCATE TABLE ");
              let first3 = true;
              for (const tbl of t2.tables) {
                if (!first3) {
                  ret.push(", ");
                }
                first3 = false;
                m.tableRef(tbl);
              }
              if (t2.identity) {
                switch (t2.identity) {
                  case "restart":
                    ret.push(" RESTART IDENTITY ");
                    break;
                  case "continue":
                    ret.push(" CONTINUE IDENTITY ");
                    break;
                }
              }
              if (t2.cascade) {
                ret.push(" ", t2.cascade, " ");
              }
            },
            delete: (t2) => {
              ret.push("DELETE FROM ");
              m.tableRef(t2.from);
              if (t2.where) {
                ret.push(" WHERE ");
                m.expr(t2.where);
              }
              if (t2.returning) {
                ret.push(" RETURNING ");
                list(t2.returning, (r) => m.selectionColumn(r), false);
              }
              ret.push(" ");
            },
            dropColumn: (t2) => {
              ret.push(" DROP COLUMN ");
              if (t2.ifExists) {
                ret.push(" IF EXISTS ");
              }
              ret.push(name(t2.column));
              if (t2.behaviour) {
                ret.push(" ", t2.behaviour);
              }
              ret.push(" ");
            },
            dropConstraint: (t2) => {
              ret.push(" DROP CONSTRAINT ");
              if (t2.ifExists) {
                ret.push(" IF EXISTS ");
              }
              ret.push(name(t2.constraint));
              if (t2.behaviour) {
                ret.push(" ", t2.behaviour.toUpperCase(), " ");
              }
            },
            from: (t2) => m.super().from(t2),
            fromCall: (s) => {
              join3(m, s.join, () => {
                var _a, _b;
                m.call(s);
                if (s.withOrdinality) {
                  ret.push(" WITH ORDINALITY");
                }
                if (s.alias) {
                  ret.push(" AS ", name(s.alias), " ");
                  const len = (_b = (_a = s.alias.columns) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
                  if (len > 0) {
                    ret.push("(");
                    for (let ix = 0; ix < len; ++ix) {
                      if (ix !== 0) {
                        ret.push(", ");
                      }
                      ret.push(name(s.alias.columns[ix]));
                    }
                    ret.push(")");
                  }
                }
              });
              ret.push(" ");
            },
            fromStatement: (s) => {
              join3(m, s.join, () => {
                ret.push("(");
                m.select(s.statement);
                ret.push(") ");
                if (s.alias) {
                  ret.push(" AS ", ident(s.alias));
                  if (s.columnNames) {
                    list(s.columnNames, (c) => ret.push(name(c)), true);
                  }
                  ret.push(" ");
                }
              });
              ret.push(" ");
            },
            values: (s) => {
              ret.push("VALUES ");
              list(s.values, (vlist) => {
                list(vlist, (e) => {
                  m.expr(e);
                }, true);
              }, false);
            },
            fromTable: (s) => {
              join3(m, s.join, () => {
                m.tableRef(s.name);
                if (s.name.columnNames) {
                  if (!s.name.alias) {
                    throw new Error("Cannot specify aliased column names without an alias");
                  }
                  list(s.name.columnNames, (c) => ret.push(name(c)), true);
                }
              });
            },
            join: (j) => {
              throw new Error("Should not happen \u{1F480}");
            },
            insert: (i) => {
              ret.push("INSERT INTO ");
              m.tableRef(i.into);
              if (i.columns) {
                ret.push("(", i.columns.map(name).join(", "), ")");
              }
              ret.push(" ");
              if (i.overriding) {
                ret.push("OVERRIDING ", i.overriding.toUpperCase(), " VALUE ");
              }
              m.select(i.insert);
              ret.push(" ");
              if (i.onConflict) {
                ret.push("ON CONFLICT ");
                const on = i.onConflict.on;
                switch (on === null || on === void 0 ? void 0 : on.type) {
                  case "on expr":
                    list(on.exprs, (e) => m.expr(e), true);
                    break;
                  case "on constraint":
                    ret.push("ON CONSTRAINT ");
                    visitQualifiedName(on.constraint);
                  case null:
                  case void 0:
                    break;
                  default:
                    throw utils_1.NotSupported.never(on);
                }
                if (i.onConflict.do === "do nothing") {
                  ret.push(" DO NOTHING");
                } else {
                  ret.push(" DO UPDATE SET ");
                  list(i.onConflict.do.sets, (s) => m.set(s), false);
                  if (i.onConflict.where) {
                    ret.push(" WHERE ");
                    m.expr(i.onConflict.where);
                  }
                }
                ret.push(" ");
              }
              if (i.returning) {
                ret.push(" RETURNING ");
                list(i.returning, (r) => m.selectionColumn(r), false);
              }
            },
            raise: (r) => {
              var _a, _b;
              ret.push("RAISE ");
              if (r.level) {
                ret.push(r.level.toUpperCase(), " ");
              }
              ret.push((0, pg_escape_1.literal)(r.format), " ");
              if ((_a = r.formatExprs) === null || _a === void 0 ? void 0 : _a.length) {
                ret.push(", ");
                list(r.formatExprs, (e) => m.expr(e), false);
              }
              if ((_b = r.using) === null || _b === void 0 ? void 0 : _b.length) {
                ret.push(" USING ");
                list(r.using, ({ type, value: value2 }) => {
                  ret.push(type.toUpperCase(), "=");
                  m.expr(value2);
                }, false);
              }
              ret.push(" ");
            },
            default: () => {
              ret.push(" DEFAULT ");
            },
            member: (e) => {
              m.expr(e.operand);
              ret.push(e.op);
              ret.push(typeof e.member === "number" ? e.member.toString(10) : (0, pg_escape_1.literal)(e.member));
            },
            ref: (r) => {
              if (r.table) {
                visitQualifiedName(r.table);
                ret.push(".");
              }
              ret.push(r.name === "*" ? "*" : ident(r.name));
            },
            parameter: (p) => {
              ret.push(p.name);
            },
            renameColumn: (r) => {
              ret.push(" RENAME COLUMN ", name(r.column), " TO ", name(r.to));
            },
            renameConstraint: (r) => {
              ret.push(" RENAME CONSTRAINT ", name(r.constraint), " TO ", name(r.to));
            },
            renameTable: (r) => {
              ret.push(" RENAME TO ", name(r.to));
            },
            createView: (c) => {
              ret.push("CREATE ");
              if (c.orReplace) {
                ret.push("OR REPLACE ");
              }
              if (c.temp) {
                ret.push("TEMP ");
              }
              if (c.recursive) {
                ret.push("RECURSIVE ");
              }
              ret.push("VIEW ");
              m.tableRef(c.name);
              if (c.columnNames) {
                list(c.columnNames, (c2) => ret.push(name(c2)), true);
              }
              const opts = c.parameters && Object.entries(c.parameters);
              if (opts === null || opts === void 0 ? void 0 : opts.length) {
                ret.push(" WITH ");
                list(opts, ([k, v]) => ret.push(k, "=", v), false);
              }
              ret.push(" AS ");
              m.select(c.query);
              if (c.checkOption) {
                ret.push(" WITH ", c.checkOption.toUpperCase(), " CHECK OPTION");
              }
            },
            createMaterializedView: (c) => {
              ret.push("CREATE MATERIALIZED VIEW ");
              if (c.ifNotExists) {
                ret.push("IF NOT EXISTS ");
              }
              m.tableRef(c.name);
              if (c.columnNames) {
                list(c.columnNames, (c2) => ret.push(name(c2)), true);
              }
              const opts = c.parameters && Object.entries(c.parameters);
              if (opts === null || opts === void 0 ? void 0 : opts.length) {
                ret.push(" WITH ");
                list(opts, ([k, v]) => ret.push(k, "=", v), false);
              }
              if (c.tablespace) {
                ret.push(" TABLESPACE ", name(c.tablespace));
              }
              ret.push(" AS ");
              m.select(c.query);
              if (typeof c.withData === "boolean") {
                ret.push(c.withData ? " WITH DATA" : " WITH NO DATA");
              }
            },
            refreshMaterializedView: (val) => {
              ret.push("REFRESH MATERIALIZED VIEW ");
              if (val.concurrently) {
                ret.push("CONCURRENTLY ");
              }
              m.tableRef(val.name);
              if (typeof val.withData === "boolean") {
                ret.push(val.withData ? " WITH DATA" : " WITH NO DATA");
              }
            },
            select: (s) => m.super().select(s),
            selection: (s) => {
              ret.push("SELECT ");
              if (s.distinct) {
                if (typeof s.distinct === "string") {
                  ret.push(s.distinct.toUpperCase());
                } else {
                  ret.push(" DISTINCT ON ");
                  list(s.distinct, (v) => m.expr(v), true);
                }
                ret.push(" ");
              }
              if (s.columns) {
                list(s.columns, (c) => m.selectionColumn(c), false);
              }
              ret.push(" ");
              if (s.from) {
                ret.push("FROM ");
                const tblCnt = s.from.length;
                for (let i = 0; i < tblCnt; i++) {
                  const f = s.from[i];
                  if (i > 0 && !f.join) {
                    ret.push(",");
                  }
                  m.from(f);
                }
                ret.push(" ");
              }
              if (s.where) {
                ret.push("WHERE ");
                m.expr(s.where);
                ret.push(" ");
              }
              if (s.groupBy) {
                ret.push("GROUP BY ");
                list(s.groupBy, (e) => m.expr(e), false);
                ret.push(" ");
                if (s.having) {
                  ret.push(" HAVING ");
                  m.expr(s.having);
                  ret.push(" ");
                }
              }
              if (s.orderBy) {
                visitOrderBy(m, s.orderBy);
                ret.push(" ");
              }
              if (s.limit) {
                if (s.limit.offset) {
                  ret.push(`OFFSET `);
                  m.expr(s.limit.offset);
                }
                if (s.limit.limit) {
                  ret.push(`LIMIT `);
                  m.expr(s.limit.limit);
                }
              }
              if (s.for) {
                ret.push("FOR ", s.for.type.toUpperCase());
                if (s.skip) {
                  ret.push(" ", s.skip.type.toUpperCase());
                }
              }
            },
            show: (s) => {
              ret.push("SHOW ", name(s.variable));
            },
            prepare: (s) => {
              var _a;
              ret.push("PREPARE ", name(s.name));
              if ((_a = s.args) === null || _a === void 0 ? void 0 : _a.length) {
                list(s.args, (a) => m.dataType(a), true);
              }
              ret.push(" AS ");
              m.statement(s.statement);
            },
            deallocate: (s) => {
              ret.push("DEALLOCATE ");
              if ("name" in s.target) {
                ret.push(s.target.name);
                return;
              }
              ret.push("ALL");
            },
            arraySelect: (s) => {
              ret.push("array(");
              m.select(s.select);
              ret.push(")");
            },
            union: (s) => {
              ret.push("(");
              m.statement(s.left);
              ret.push(") ", s.type.toUpperCase(), " ");
              if (s.right.type === "union" || s.right.type === "union all") {
                m.union(s.right);
              } else {
                ret.push("(");
                m.statement(s.right);
                ret.push(")");
              }
            },
            selectionColumn: (c) => {
              m.expr(c.expr);
              if (c.alias) {
                ret.push(" AS ", name(c.alias));
              }
              ret.push(" ");
            },
            set: (s) => {
              ret.push(name(s.column), " = ");
              m.expr(s.value);
              ret.push(" ");
            },
            statement: (s) => m.super().statement(s),
            tableRef: (r) => {
              visitQualifiedName(r);
              if (r.alias) {
                ret.push(" AS ", ident(r.alias));
              }
              ret.push(" ");
            },
            ternary: (t2) => {
              m.expr(t2.value);
              ret.push(" ", t2.op, " ");
              m.expr(t2.lo);
              ret.push(" AND ");
              m.expr(t2.hi);
              ret.push(" ");
            },
            transaction: (t2) => {
              ret.push(t2.type);
            },
            unary: (t2) => {
              switch (t2.op) {
                case "+":
                case "-":
                  visitOp(t2);
                  m.expr(t2.operand);
                  break;
                case "NOT":
                  ret.push(t2.op);
                  ret.push(" ");
                  m.expr(t2.operand);
                  break;
                default:
                  m.expr(t2.operand);
                  ret.push(" ");
                  ret.push(t2.op);
              }
            },
            update: (u) => {
              ret.push("UPDATE ");
              m.tableRef(u.table);
              ret.push(" SET ");
              list(u.sets, (s) => m.set(s), false);
              ret.push(" ");
              if (u.from) {
                ret.push("FROM ");
                m.from(u.from);
                ret.push(" ");
              }
              if (u.where) {
                ret.push("WHERE ");
                m.expr(u.where);
                ret.push(" ");
              }
              if (u.returning) {
                ret.push(" RETURNING ");
                list(u.returning, (r) => m.selectionColumn(r), false);
                ret.push(" ");
              }
            }
          }));
          exports2.toSql = {};
          const proto = ast_mapper_1.AstDefaultMapper.prototype;
          for (const k of Object.getOwnPropertyNames(proto)) {
            const orig = proto[k];
            if (k === "constructor" || k === "super" || typeof orig !== "function") {
              continue;
            }
            exports2.toSql[k] = function(...args) {
              try {
                visitor[k].apply(visitor, args);
                return ret.join("").trim();
              } finally {
                ret = [];
              }
            };
          }
        },
        /* 20 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.literal = void 0;
          function literal(val) {
            if (null == val)
              return "NULL";
            if (Array.isArray(val)) {
              var vals = val.map(literal);
              return "(" + vals.join(", ") + ")";
            }
            var backslash = ~val.indexOf("\\");
            var prefix = backslash ? "E" : "";
            val = val.replace(/'/g, "''");
            val = val.replace(/\\/g, "\\\\");
            return prefix + "'" + val + "'";
          }
          exports2.literal = literal;
          ;
        },
        /* 21 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.locationOf = void 0;
          function locationOf(node) {
            const n = node._location;
            if (!n) {
              throw new Error("This statement has not been parsed using location tracking (which has a small performance hit). ");
            }
            return n;
          }
          exports2.locationOf = locationOf;
          ;
          ;
        }
        /******/
      ])
    );
  }
});

// ../node_modules/pg-mem/node_modules/object-hash/index.js
var require_object_hash = __commonJS({
  "../node_modules/pg-mem/node_modules/object-hash/index.js"(exports, module2) {
    "use strict";
    var crypto = require("crypto");
    exports = module2.exports = objectHash;
    function objectHash(object, options) {
      options = applyDefaults(object, options);
      return hash2(object, options);
    }
    exports.sha1 = function(object) {
      return objectHash(object);
    };
    exports.keys = function(object) {
      return objectHash(object, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
    };
    exports.MD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex" });
    };
    exports.keysMD5 = function(object) {
      return objectHash(object, { algorithm: "md5", encoding: "hex", excludeValues: true });
    };
    var hashes = crypto.getHashes ? crypto.getHashes().slice() : ["sha1", "md5"];
    hashes.push("passthrough");
    var encodings = ["buffer", "hex", "binary", "base64"];
    function applyDefaults(object, sourceOptions) {
      sourceOptions = sourceOptions || {};
      var options = {};
      options.algorithm = sourceOptions.algorithm || "sha1";
      options.encoding = sourceOptions.encoding || "hex";
      options.excludeValues = sourceOptions.excludeValues ? true : false;
      options.algorithm = options.algorithm.toLowerCase();
      options.encoding = options.encoding.toLowerCase();
      options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true;
      options.respectType = sourceOptions.respectType === false ? false : true;
      options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
      options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
      options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true;
      options.unorderedSets = sourceOptions.unorderedSets === false ? false : true;
      options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true;
      options.replacer = sourceOptions.replacer || void 0;
      options.excludeKeys = sourceOptions.excludeKeys || void 0;
      if (typeof object === "undefined") {
        throw new Error("Object argument required.");
      }
      for (var i = 0; i < hashes.length; ++i) {
        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
          options.algorithm = hashes[i];
        }
      }
      if (hashes.indexOf(options.algorithm) === -1) {
        throw new Error('Algorithm "' + options.algorithm + '"  not supported. supported values: ' + hashes.join(", "));
      }
      if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options.encoding + '"  not supported. supported values: ' + encodings.join(", "));
      }
      return options;
    }
    function isNativeFunction(f) {
      if (typeof f !== "function") {
        return false;
      }
      var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
      return exp.exec(Function.prototype.toString.call(f)) != null;
    }
    function hash2(object, options) {
      var hashingStream;
      if (options.algorithm !== "passthrough") {
        hashingStream = crypto.createHash(options.algorithm);
      } else {
        hashingStream = new PassThrough();
      }
      if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update;
        hashingStream.end = hashingStream.update;
      }
      var hasher = typeHasher(options, hashingStream);
      hasher.dispatch(object);
      if (!hashingStream.update) {
        hashingStream.end("");
      }
      if (hashingStream.digest) {
        return hashingStream.digest(options.encoding === "buffer" ? void 0 : options.encoding);
      }
      var buf = hashingStream.read();
      if (options.encoding === "buffer") {
        return buf;
      }
      return buf.toString(options.encoding);
    }
    exports.writeToStream = function(object, options, stream) {
      if (typeof stream === "undefined") {
        stream = options;
        options = {};
      }
      options = applyDefaults(object, options);
      return typeHasher(options, stream).dispatch(object);
    };
    function typeHasher(options, writeTo, context) {
      context = context || [];
      var write = function(str) {
        if (writeTo.update) {
          return writeTo.update(str, "utf8");
        } else {
          return writeTo.write(str, "utf8");
        }
      };
      return {
        dispatch: function(value2) {
          if (options.replacer) {
            value2 = options.replacer(value2);
          }
          var type = typeof value2;
          if (value2 === null) {
            type = "null";
          }
          return this["_" + type](value2);
        },
        _object: function(object) {
          var pattern = /\[object (.*)\]/i;
          var objString = Object.prototype.toString.call(object);
          var objType = pattern.exec(objString);
          if (!objType) {
            objType = "unknown:[" + objString + "]";
          } else {
            objType = objType[1];
          }
          objType = objType.toLowerCase();
          var objectNumber = null;
          if ((objectNumber = context.indexOf(object)) >= 0) {
            return this.dispatch("[CIRCULAR:" + objectNumber + "]");
          } else {
            context.push(object);
          }
          if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
            write("buffer:");
            return write(object);
          }
          if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
            if (this["_" + objType]) {
              this["_" + objType](object);
            } else if (options.ignoreUnknown) {
              return write("[" + objType + "]");
            } else {
              throw new Error('Unknown object type "' + objType + '"');
            }
          } else {
            var keys2 = Object.keys(object);
            if (options.unorderedObjects) {
              keys2 = keys2.sort();
            }
            if (options.respectType !== false && !isNativeFunction(object)) {
              keys2.splice(0, 0, "prototype", "__proto__", "constructor");
            }
            if (options.excludeKeys) {
              keys2 = keys2.filter(function(key) {
                return !options.excludeKeys(key);
              });
            }
            write("object:" + keys2.length + ":");
            var self = this;
            return keys2.forEach(function(key) {
              self.dispatch(key);
              write(":");
              if (!options.excludeValues) {
                self.dispatch(object[key]);
              }
              write(",");
            });
          }
        },
        _array: function(arr, unordered) {
          unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false;
          var self = this;
          write("array:" + arr.length + ":");
          if (!unordered || arr.length <= 1) {
            return arr.forEach(function(entry) {
              return self.dispatch(entry);
            });
          }
          var contextAdditions = [];
          var entries3 = arr.map(function(entry) {
            var strm = new PassThrough();
            var localContext = context.slice();
            var hasher = typeHasher(options, strm, localContext);
            hasher.dispatch(entry);
            contextAdditions = contextAdditions.concat(localContext.slice(context.length));
            return strm.read().toString();
          });
          context = context.concat(contextAdditions);
          entries3.sort();
          return this._array(entries3, false);
        },
        _date: function(date) {
          return write("date:" + date.toJSON());
        },
        _symbol: function(sym) {
          return write("symbol:" + sym.toString());
        },
        _error: function(err) {
          return write("error:" + err.toString());
        },
        _boolean: function(bool) {
          return write("bool:" + bool.toString());
        },
        _string: function(string2) {
          write("string:" + string2.length + ":");
          write(string2.toString());
        },
        _function: function(fn) {
          write("fn:");
          if (isNativeFunction(fn)) {
            this.dispatch("[native]");
          } else {
            this.dispatch(fn.toString());
          }
          if (options.respectFunctionNames !== false) {
            this.dispatch("function-name:" + String(fn.name));
          }
          if (options.respectFunctionProperties) {
            this._object(fn);
          }
        },
        _number: function(number) {
          return write("number:" + number.toString());
        },
        _xml: function(xml) {
          return write("xml:" + xml.toString());
        },
        _null: function() {
          return write("Null");
        },
        _undefined: function() {
          return write("Undefined");
        },
        _regexp: function(regex) {
          return write("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
          write("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
          write("uint8clampedarray:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
          write("uint8array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
          write("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
          write("uint16array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
          write("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
          write("uint32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
          write("float32array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
          write("float64array:");
          return this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
          write("arraybuffer:");
          return this.dispatch(new Uint8Array(arr));
        },
        _url: function(url) {
          return write("url:" + url.toString(), "utf8");
        },
        _map: function(map2) {
          write("map:");
          var arr = Array.from(map2);
          return this._array(arr, options.unorderedSets !== false);
        },
        _set: function(set3) {
          write("set:");
          var arr = Array.from(set3);
          return this._array(arr, options.unorderedSets !== false);
        },
        _file: function(file) {
          write("file:");
          return this.dispatch([file.name, file.size, file.type, file.lastModfied]);
        },
        _blob: function() {
          if (options.ignoreUnknown) {
            return write("[blob]");
          }
          throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
          return write("domwindow");
        },
        _bigint: function(number) {
          return write("bigint:" + number.toString());
        },
        /* Node.js standard native objects */
        _process: function() {
          return write("process");
        },
        _timer: function() {
          return write("timer");
        },
        _pipe: function() {
          return write("pipe");
        },
        _tcp: function() {
          return write("tcp");
        },
        _udp: function() {
          return write("udp");
        },
        _tty: function() {
          return write("tty");
        },
        _statwatcher: function() {
          return write("statwatcher");
        },
        _securecontext: function() {
          return write("securecontext");
        },
        _connection: function() {
          return write("connection");
        },
        _zlib: function() {
          return write("zlib");
        },
        _context: function() {
          return write("context");
        },
        _nodescript: function() {
          return write("nodescript");
        },
        _httpparser: function() {
          return write("httpparser");
        },
        _dataview: function() {
          return write("dataview");
        },
        _signal: function() {
          return write("signal");
        },
        _fsevent: function() {
          return write("fsevent");
        },
        _tlswrap: function() {
          return write("tlswrap");
        }
      };
    }
    function PassThrough() {
      return {
        buf: "",
        write: function(b) {
          this.buf += b;
        },
        end: function(b) {
          this.buf += b;
        },
        read: function() {
          return this.buf;
        }
      };
    }
  }
});

// ../node_modules/immutable/dist/immutable.es.js
var immutable_es_exports = {};
__export(immutable_es_exports, {
  Collection: () => Collection,
  Iterable: () => Iterable,
  List: () => List,
  Map: () => Map2,
  OrderedMap: () => OrderedMap,
  OrderedSet: () => OrderedSet,
  PairSorting: () => PairSorting,
  Range: () => Range,
  Record: () => Record,
  Repeat: () => Repeat,
  Seq: () => Seq,
  Set: () => Set2,
  Stack: () => Stack,
  default: () => immutable_es_default,
  fromJS: () => fromJS,
  get: () => get,
  getIn: () => getIn$1,
  has: () => has,
  hasIn: () => hasIn$1,
  hash: () => hash,
  is: () => is,
  isAssociative: () => isAssociative,
  isCollection: () => isCollection,
  isImmutable: () => isImmutable,
  isIndexed: () => isIndexed,
  isKeyed: () => isKeyed,
  isList: () => isList,
  isMap: () => isMap2,
  isOrdered: () => isOrdered,
  isOrderedMap: () => isOrderedMap,
  isOrderedSet: () => isOrderedSet,
  isPlainObject: () => isPlainObject3,
  isRecord: () => isRecord,
  isSeq: () => isSeq,
  isSet: () => isSet2,
  isStack: () => isStack,
  isValueObject: () => isValueObject,
  merge: () => merge,
  mergeDeep: () => mergeDeep$1,
  mergeDeepWith: () => mergeDeepWith$1,
  mergeWith: () => mergeWith,
  remove: () => remove,
  removeIn: () => removeIn,
  set: () => set,
  setIn: () => setIn$1,
  update: () => update$1,
  updateIn: () => updateIn$1,
  version: () => version
});
function MakeRef() {
  return { value: false };
}
function SetRef(ref) {
  if (ref) {
    ref.value = true;
  }
}
function OwnerID() {
}
function ensureSize(iter) {
  if (iter.size === void 0) {
    iter.size = iter.__iterate(returnTrue);
  }
  return iter.size;
}
function wrapIndex(iter, index) {
  if (typeof index !== "number") {
    var uint32Index = index >>> 0;
    if ("" + uint32Index !== index || uint32Index === 4294967295) {
      return NaN;
    }
    index = uint32Index;
  }
  return index < 0 ? ensureSize(iter) + index : index;
}
function returnTrue() {
  return true;
}
function wholeSlice(begin, end, size) {
  return (begin === 0 && !isNeg(begin) || size !== void 0 && begin <= -size) && (end === void 0 || size !== void 0 && end >= size);
}
function resolveBegin(begin, size) {
  return resolveIndex(begin, size, 0);
}
function resolveEnd(end, size) {
  return resolveIndex(end, size, size);
}
function resolveIndex(index, size, defaultIndex) {
  return index === void 0 ? defaultIndex : isNeg(index) ? size === Infinity ? size : Math.max(0, size + index) | 0 : size === void 0 || size === index ? index : Math.min(size, index) | 0;
}
function isNeg(value2) {
  return value2 < 0 || value2 === 0 && 1 / value2 === -Infinity;
}
function isCollection(maybeCollection) {
  return Boolean(maybeCollection && maybeCollection[IS_COLLECTION_SYMBOL]);
}
function isKeyed(maybeKeyed) {
  return Boolean(maybeKeyed && maybeKeyed[IS_KEYED_SYMBOL]);
}
function isIndexed(maybeIndexed) {
  return Boolean(maybeIndexed && maybeIndexed[IS_INDEXED_SYMBOL]);
}
function isAssociative(maybeAssociative) {
  return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
}
function isSeq(maybeSeq) {
  return Boolean(maybeSeq && maybeSeq[IS_SEQ_SYMBOL]);
}
function isRecord(maybeRecord) {
  return Boolean(maybeRecord && maybeRecord[IS_RECORD_SYMBOL]);
}
function isImmutable(maybeImmutable) {
  return isCollection(maybeImmutable) || isRecord(maybeImmutable);
}
function isOrdered(maybeOrdered) {
  return Boolean(maybeOrdered && maybeOrdered[IS_ORDERED_SYMBOL]);
}
function iteratorValue(type, k, v, iteratorResult) {
  var value2 = type === 0 ? k : type === 1 ? v : [k, v];
  iteratorResult ? iteratorResult.value = value2 : iteratorResult = {
    value: value2,
    done: false
  };
  return iteratorResult;
}
function iteratorDone() {
  return { value: void 0, done: true };
}
function hasIterator(maybeIterable) {
  if (Array.isArray(maybeIterable)) {
    return true;
  }
  return !!getIteratorFn(maybeIterable);
}
function isIterator(maybeIterator) {
  return maybeIterator && typeof maybeIterator.next === "function";
}
function getIterator(iterable) {
  var iteratorFn = getIteratorFn(iterable);
  return iteratorFn && iteratorFn.call(iterable);
}
function getIteratorFn(iterable) {
  var iteratorFn = iterable && (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL] || iterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === "function") {
    return iteratorFn;
  }
}
function isEntriesIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.entries;
}
function isKeysIterable(maybeIterable) {
  var iteratorFn = getIteratorFn(maybeIterable);
  return iteratorFn && iteratorFn === maybeIterable.keys;
}
function isArrayLike(value2) {
  if (Array.isArray(value2) || typeof value2 === "string") {
    return true;
  }
  return value2 && typeof value2 === "object" && Number.isInteger(value2.length) && value2.length >= 0 && (value2.length === 0 ? (
    // Only {length: 0} is considered Array-like.
    Object.keys(value2).length === 1
  ) : (
    // An object is only Array-like if it has a property where the last value
    // in the array-like may be found (which could be undefined).
    value2.hasOwnProperty(value2.length - 1)
  ));
}
function emptySequence() {
  return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
}
function keyedSeqFromValue(value2) {
  var seq = maybeIndexedSeqFromValue(value2);
  if (seq) {
    return seq.fromEntrySeq();
  }
  if (typeof value2 === "object") {
    return new ObjectSeq(value2);
  }
  throw new TypeError(
    "Expected Array or collection object of [k, v] entries, or keyed object: " + value2
  );
}
function indexedSeqFromValue(value2) {
  var seq = maybeIndexedSeqFromValue(value2);
  if (seq) {
    return seq;
  }
  throw new TypeError(
    "Expected Array or collection object of values: " + value2
  );
}
function seqFromValue(value2) {
  var seq = maybeIndexedSeqFromValue(value2);
  if (seq) {
    return isEntriesIterable(value2) ? seq.fromEntrySeq() : isKeysIterable(value2) ? seq.toSetSeq() : seq;
  }
  if (typeof value2 === "object") {
    return new ObjectSeq(value2);
  }
  throw new TypeError(
    "Expected Array or collection object of values, or keyed object: " + value2
  );
}
function maybeIndexedSeqFromValue(value2) {
  return isArrayLike(value2) ? new ArraySeq(value2) : hasIterator(value2) ? new CollectionSeq(value2) : void 0;
}
function isMap2(maybeMap) {
  return Boolean(maybeMap && maybeMap[IS_MAP_SYMBOL]);
}
function isOrderedMap(maybeOrderedMap) {
  return isMap2(maybeOrderedMap) && isOrdered(maybeOrderedMap);
}
function isValueObject(maybeValue) {
  return Boolean(
    maybeValue && typeof maybeValue.equals === "function" && typeof maybeValue.hashCode === "function"
  );
}
function is(valueA, valueB) {
  if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
    return true;
  }
  if (!valueA || !valueB) {
    return false;
  }
  if (typeof valueA.valueOf === "function" && typeof valueB.valueOf === "function") {
    valueA = valueA.valueOf();
    valueB = valueB.valueOf();
    if (valueA === valueB || valueA !== valueA && valueB !== valueB) {
      return true;
    }
    if (!valueA || !valueB) {
      return false;
    }
  }
  return !!(isValueObject(valueA) && isValueObject(valueB) && valueA.equals(valueB));
}
function smi(i32) {
  return i32 >>> 1 & 1073741824 | i32 & 3221225471;
}
function hash(o) {
  if (o == null) {
    return hashNullish(o);
  }
  if (typeof o.hashCode === "function") {
    return smi(o.hashCode(o));
  }
  var v = valueOf(o);
  if (v == null) {
    return hashNullish(v);
  }
  switch (typeof v) {
    case "boolean":
      return v ? 1108378657 : 1108378656;
    case "number":
      return hashNumber(v);
    case "string":
      return v.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(v) : hashString(v);
    case "object":
    case "function":
      return hashJSObj(v);
    case "symbol":
      return hashSymbol(v);
    default:
      if (typeof v.toString === "function") {
        return hashString(v.toString());
      }
      throw new Error("Value type " + typeof v + " cannot be hashed.");
  }
}
function hashNullish(nullish) {
  return nullish === null ? 1108378658 : (
    /* undefined */
    1108378659
  );
}
function hashNumber(n) {
  if (n !== n || n === Infinity) {
    return 0;
  }
  var hash2 = n | 0;
  if (hash2 !== n) {
    hash2 ^= n * 4294967295;
  }
  while (n > 4294967295) {
    n /= 4294967295;
    hash2 ^= n;
  }
  return smi(hash2);
}
function cachedHashString(string2) {
  var hashed = stringHashCache[string2];
  if (hashed === void 0) {
    hashed = hashString(string2);
    if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
      STRING_HASH_CACHE_SIZE = 0;
      stringHashCache = {};
    }
    STRING_HASH_CACHE_SIZE++;
    stringHashCache[string2] = hashed;
  }
  return hashed;
}
function hashString(string2) {
  var hashed = 0;
  for (var ii = 0; ii < string2.length; ii++) {
    hashed = 31 * hashed + string2.charCodeAt(ii) | 0;
  }
  return smi(hashed);
}
function hashSymbol(sym) {
  var hashed = symbolMap[sym];
  if (hashed !== void 0) {
    return hashed;
  }
  hashed = nextHash();
  symbolMap[sym] = hashed;
  return hashed;
}
function hashJSObj(obj) {
  var hashed;
  if (usingWeakMap) {
    hashed = weakMap.get(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = obj[UID_HASH_KEY];
  if (hashed !== void 0) {
    return hashed;
  }
  if (!canDefineProperty) {
    hashed = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
    if (hashed !== void 0) {
      return hashed;
    }
    hashed = getIENodeHash(obj);
    if (hashed !== void 0) {
      return hashed;
    }
  }
  hashed = nextHash();
  if (usingWeakMap) {
    weakMap.set(obj, hashed);
  } else if (isExtensible !== void 0 && isExtensible(obj) === false) {
    throw new Error("Non-extensible objects are not allowed as keys.");
  } else if (canDefineProperty) {
    Object.defineProperty(obj, UID_HASH_KEY, {
      enumerable: false,
      configurable: false,
      writable: false,
      value: hashed
    });
  } else if (obj.propertyIsEnumerable !== void 0 && obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
    obj.propertyIsEnumerable = function() {
      return this.constructor.prototype.propertyIsEnumerable.apply(
        this,
        arguments
      );
    };
    obj.propertyIsEnumerable[UID_HASH_KEY] = hashed;
  } else if (obj.nodeType !== void 0) {
    obj[UID_HASH_KEY] = hashed;
  } else {
    throw new Error("Unable to set a non-enumerable property on object.");
  }
  return hashed;
}
function getIENodeHash(node) {
  if (node && node.nodeType > 0) {
    switch (node.nodeType) {
      case 1:
        return node.uniqueID;
      case 9:
        return node.documentElement && node.documentElement.uniqueID;
    }
  }
}
function valueOf(obj) {
  return obj.valueOf !== defaultValueOf && typeof obj.valueOf === "function" ? obj.valueOf(obj) : obj;
}
function nextHash() {
  var nextHash2 = ++_objHashUID;
  if (_objHashUID & 1073741824) {
    _objHashUID = 0;
  }
  return nextHash2;
}
function flipFactory(collection) {
  var flipSequence = makeSequence(collection);
  flipSequence._iter = collection;
  flipSequence.size = collection.size;
  flipSequence.flip = function() {
    return collection;
  };
  flipSequence.reverse = function() {
    var reversedSequence = collection.reverse.apply(this);
    reversedSequence.flip = function() {
      return collection.reverse();
    };
    return reversedSequence;
  };
  flipSequence.has = function(key) {
    return collection.includes(key);
  };
  flipSequence.includes = function(key) {
    return collection.has(key);
  };
  flipSequence.cacheResult = cacheResultThrough;
  flipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(function(v, k) {
      return fn(k, v, this$1$1) !== false;
    }, reverse3);
  };
  flipSequence.__iteratorUncached = function(type, reverse3) {
    if (type === ITERATE_ENTRIES) {
      var iterator = collection.__iterator(type, reverse3);
      return new Iterator(function() {
        var step = iterator.next();
        if (!step.done) {
          var k = step.value[0];
          step.value[0] = step.value[1];
          step.value[1] = k;
        }
        return step;
      });
    }
    return collection.__iterator(
      type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
      reverse3
    );
  };
  return flipSequence;
}
function mapFactory(collection, mapper, context) {
  var mappedSequence = makeSequence(collection);
  mappedSequence.size = collection.size;
  mappedSequence.has = function(key) {
    return collection.has(key);
  };
  mappedSequence.get = function(key, notSetValue) {
    var v = collection.get(key, NOT_SET);
    return v === NOT_SET ? notSetValue : mapper.call(context, v, key, collection);
  };
  mappedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    return collection.__iterate(
      function(v, k, c) {
        return fn(mapper.call(context, v, k, c), k, this$1$1) !== false;
      },
      reverse3
    );
  };
  mappedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var key = entry[0];
      return iteratorValue(
        type,
        key,
        mapper.call(context, entry[1], key, collection),
        step
      );
    });
  };
  return mappedSequence;
}
function reverseFactory(collection, useKeys) {
  var this$1$1 = this;
  var reversedSequence = makeSequence(collection);
  reversedSequence._iter = collection;
  reversedSequence.size = collection.size;
  reversedSequence.reverse = function() {
    return collection;
  };
  if (collection.flip) {
    reversedSequence.flip = function() {
      var flipSequence = flipFactory(collection);
      flipSequence.reverse = function() {
        return collection.flip();
      };
      return flipSequence;
    };
  }
  reversedSequence.get = function(key, notSetValue) {
    return collection.get(useKeys ? key : -1 - key, notSetValue);
  };
  reversedSequence.has = function(key) {
    return collection.has(useKeys ? key : -1 - key);
  };
  reversedSequence.includes = function(value2) {
    return collection.includes(value2);
  };
  reversedSequence.cacheResult = cacheResultThrough;
  reversedSequence.__iterate = function(fn, reverse3) {
    var this$1$12 = this;
    var i = 0;
    reverse3 && ensureSize(collection);
    return collection.__iterate(
      function(v, k) {
        return fn(v, useKeys ? k : reverse3 ? this$1$12.size - ++i : i++, this$1$12);
      },
      !reverse3
    );
  };
  reversedSequence.__iterator = function(type, reverse3) {
    var i = 0;
    reverse3 && ensureSize(collection);
    var iterator = collection.__iterator(ITERATE_ENTRIES, !reverse3);
    return new Iterator(function() {
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      return iteratorValue(
        type,
        useKeys ? entry[0] : reverse3 ? this$1$1.size - ++i : i++,
        entry[1],
        step
      );
    });
  };
  return reversedSequence;
}
function filterFactory(collection, predicate, context, useKeys) {
  var filterSequence = makeSequence(collection);
  if (useKeys) {
    filterSequence.has = function(key) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && !!predicate.call(context, v, key, collection);
    };
    filterSequence.get = function(key, notSetValue) {
      var v = collection.get(key, NOT_SET);
      return v !== NOT_SET && predicate.call(context, v, key, collection) ? v : notSetValue;
    };
  }
  filterSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (predicate.call(context, v, k, c)) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    }, reverse3);
    return iterations;
  };
  filterSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterations = 0;
    return new Iterator(function() {
      while (true) {
        var step = iterator.next();
        if (step.done) {
          return step;
        }
        var entry = step.value;
        var key = entry[0];
        var value2 = entry[1];
        if (predicate.call(context, value2, key, collection)) {
          return iteratorValue(type, useKeys ? key : iterations++, value2, step);
        }
      }
    });
  };
  return filterSequence;
}
function countByFactory(collection, grouper, context) {
  var groups = Map2().asMutable();
  collection.__iterate(function(v, k) {
    groups.update(grouper.call(context, v, k, collection), 0, function(a) {
      return a + 1;
    });
  });
  return groups.asImmutable();
}
function groupByFactory(collection, grouper, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = (isOrdered(collection) ? OrderedMap() : Map2()).asMutable();
  collection.__iterate(function(v, k) {
    groups.update(
      grouper.call(context, v, k, collection),
      function(a) {
        return a = a || [], a.push(isKeyedIter ? [k, v] : v), a;
      }
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  }).asImmutable();
}
function partitionFactory(collection, predicate, context) {
  var isKeyedIter = isKeyed(collection);
  var groups = [[], []];
  collection.__iterate(function(v, k) {
    groups[predicate.call(context, v, k, collection) ? 1 : 0].push(
      isKeyedIter ? [k, v] : v
    );
  });
  var coerce = collectionClass(collection);
  return groups.map(function(arr) {
    return reify(collection, coerce(arr));
  });
}
function sliceFactory(collection, begin, end, useKeys) {
  var originalSize = collection.size;
  if (wholeSlice(begin, end, originalSize)) {
    return collection;
  }
  var resolvedBegin = resolveBegin(begin, originalSize);
  var resolvedEnd = resolveEnd(end, originalSize);
  if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
    return sliceFactory(collection.toSeq().cacheResult(), begin, end, useKeys);
  }
  var resolvedSize = resolvedEnd - resolvedBegin;
  var sliceSize;
  if (resolvedSize === resolvedSize) {
    sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
  }
  var sliceSeq = makeSequence(collection);
  sliceSeq.size = sliceSize === 0 ? sliceSize : collection.size && sliceSize || void 0;
  if (!useKeys && isSeq(collection) && sliceSize >= 0) {
    sliceSeq.get = function(index, notSetValue) {
      index = wrapIndex(this, index);
      return index >= 0 && index < sliceSize ? collection.get(index + resolvedBegin, notSetValue) : notSetValue;
    };
  }
  sliceSeq.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (sliceSize === 0) {
      return 0;
    }
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var skipped = 0;
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k) {
      if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1) !== false && iterations !== sliceSize;
      }
    });
    return iterations;
  };
  sliceSeq.__iteratorUncached = function(type, reverse3) {
    if (sliceSize !== 0 && reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    if (sliceSize === 0) {
      return new Iterator(iteratorDone);
    }
    var iterator = collection.__iterator(type, reverse3);
    var skipped = 0;
    var iterations = 0;
    return new Iterator(function() {
      while (skipped++ < resolvedBegin) {
        iterator.next();
      }
      if (++iterations > sliceSize) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (useKeys || type === ITERATE_VALUES || step.done) {
        return step;
      }
      if (type === ITERATE_KEYS) {
        return iteratorValue(type, iterations - 1, void 0, step);
      }
      return iteratorValue(type, iterations - 1, step.value[1], step);
    });
  };
  return sliceSeq;
}
function takeWhileFactory(collection, predicate, context) {
  var takeSequence = makeSequence(collection);
  takeSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    collection.__iterate(
      function(v, k, c) {
        return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$1$1);
      }
    );
    return iterations;
  };
  takeSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var iterating = true;
    return new Iterator(function() {
      if (!iterating) {
        return iteratorDone();
      }
      var step = iterator.next();
      if (step.done) {
        return step;
      }
      var entry = step.value;
      var k = entry[0];
      var v = entry[1];
      if (!predicate.call(context, v, k, this$1$1)) {
        iterating = false;
        return iteratorDone();
      }
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return takeSequence;
}
function skipWhileFactory(collection, predicate, context, useKeys) {
  var skipSequence = makeSequence(collection);
  skipSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var isSkipping = true;
    var iterations = 0;
    collection.__iterate(function(v, k, c) {
      if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
        iterations++;
        return fn(v, useKeys ? k : iterations - 1, this$1$1);
      }
    });
    return iterations;
  };
  skipSequence.__iteratorUncached = function(type, reverse3) {
    var this$1$1 = this;
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(ITERATE_ENTRIES, reverse3);
    var skipping = true;
    var iterations = 0;
    return new Iterator(function() {
      var step;
      var k;
      var v;
      do {
        step = iterator.next();
        if (step.done) {
          if (useKeys || type === ITERATE_VALUES) {
            return step;
          }
          if (type === ITERATE_KEYS) {
            return iteratorValue(type, iterations++, void 0, step);
          }
          return iteratorValue(type, iterations++, step.value[1], step);
        }
        var entry = step.value;
        k = entry[0];
        v = entry[1];
        skipping && (skipping = predicate.call(context, v, k, this$1$1));
      } while (skipping);
      return type === ITERATE_ENTRIES ? step : iteratorValue(type, k, v, step);
    });
  };
  return skipSequence;
}
function concatFactory(collection, values2) {
  var isKeyedCollection = isKeyed(collection);
  var iters = [collection].concat(values2).map(function(v) {
    if (!isCollection(v)) {
      v = isKeyedCollection ? keyedSeqFromValue(v) : indexedSeqFromValue(Array.isArray(v) ? v : [v]);
    } else if (isKeyedCollection) {
      v = KeyedCollection(v);
    }
    return v;
  }).filter(function(v) {
    return v.size !== 0;
  });
  if (iters.length === 0) {
    return collection;
  }
  if (iters.length === 1) {
    var singleton = iters[0];
    if (singleton === collection || isKeyedCollection && isKeyed(singleton) || isIndexed(collection) && isIndexed(singleton)) {
      return singleton;
    }
  }
  var concatSeq = new ArraySeq(iters);
  if (isKeyedCollection) {
    concatSeq = concatSeq.toKeyedSeq();
  } else if (!isIndexed(collection)) {
    concatSeq = concatSeq.toSetSeq();
  }
  concatSeq = concatSeq.flatten(true);
  concatSeq.size = iters.reduce(function(sum, seq) {
    if (sum !== void 0) {
      var size = seq.size;
      if (size !== void 0) {
        return sum + size;
      }
    }
  }, 0);
  return concatSeq;
}
function flattenFactory(collection, depth, useKeys) {
  var flatSequence = makeSequence(collection);
  flatSequence.__iterateUncached = function(fn, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterate(fn, reverse3);
    }
    var iterations = 0;
    var stopped = false;
    function flatDeep(iter, currentDepth) {
      iter.__iterate(function(v, k) {
        if ((!depth || currentDepth < depth) && isCollection(v)) {
          flatDeep(v, currentDepth + 1);
        } else {
          iterations++;
          if (fn(v, useKeys ? k : iterations - 1, flatSequence) === false) {
            stopped = true;
          }
        }
        return !stopped;
      }, reverse3);
    }
    flatDeep(collection, 0);
    return iterations;
  };
  flatSequence.__iteratorUncached = function(type, reverse3) {
    if (reverse3) {
      return this.cacheResult().__iterator(type, reverse3);
    }
    var iterator = collection.__iterator(type, reverse3);
    var stack = [];
    var iterations = 0;
    return new Iterator(function() {
      while (iterator) {
        var step = iterator.next();
        if (step.done !== false) {
          iterator = stack.pop();
          continue;
        }
        var v = step.value;
        if (type === ITERATE_ENTRIES) {
          v = v[1];
        }
        if ((!depth || stack.length < depth) && isCollection(v)) {
          stack.push(iterator);
          iterator = v.__iterator(type, reverse3);
        } else {
          return useKeys ? step : iteratorValue(type, iterations++, v, step);
        }
      }
      return iteratorDone();
    });
  };
  return flatSequence;
}
function flatMapFactory(collection, mapper, context) {
  var coerce = collectionClass(collection);
  return collection.toSeq().map(function(v, k) {
    return coerce(mapper.call(context, v, k, collection));
  }).flatten(true);
}
function interposeFactory(collection, separator) {
  var interposedSequence = makeSequence(collection);
  interposedSequence.size = collection.size && collection.size * 2 - 1;
  interposedSequence.__iterateUncached = function(fn, reverse3) {
    var this$1$1 = this;
    var iterations = 0;
    collection.__iterate(
      function(v) {
        return (!iterations || fn(separator, iterations++, this$1$1) !== false) && fn(v, iterations++, this$1$1) !== false;
      },
      reverse3
    );
    return iterations;
  };
  interposedSequence.__iteratorUncached = function(type, reverse3) {
    var iterator = collection.__iterator(ITERATE_VALUES, reverse3);
    var iterations = 0;
    var step;
    return new Iterator(function() {
      if (!step || iterations % 2) {
        step = iterator.next();
        if (step.done) {
          return step;
        }
      }
      return iterations % 2 ? iteratorValue(type, iterations++, separator) : iteratorValue(type, iterations++, step.value, step);
    });
  };
  return interposedSequence;
}
function sortFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  var isKeyedCollection = isKeyed(collection);
  var index = 0;
  var entries3 = collection.toSeq().map(function(v, k) {
    return [k, v, index++, mapper ? mapper(v, k, collection) : v];
  }).valueSeq().toArray();
  entries3.sort(function(a, b) {
    return comparator(a[3], b[3]) || a[2] - b[2];
  }).forEach(
    isKeyedCollection ? function(v, i) {
      entries3[i].length = 2;
    } : function(v, i) {
      entries3[i] = v[1];
    }
  );
  return isKeyedCollection ? KeyedSeq(entries3) : isIndexed(collection) ? IndexedSeq(entries3) : SetSeq(entries3);
}
function maxFactory(collection, comparator, mapper) {
  if (!comparator) {
    comparator = defaultComparator;
  }
  if (mapper) {
    var entry = collection.toSeq().map(function(v, k) {
      return [v, mapper(v, k, collection)];
    }).reduce(function(a, b) {
      return maxCompare(comparator, a[1], b[1]) ? b : a;
    });
    return entry && entry[0];
  }
  return collection.reduce(function(a, b) {
    return maxCompare(comparator, a, b) ? b : a;
  });
}
function maxCompare(comparator, a, b) {
  var comp = comparator(b, a);
  return comp === 0 && b !== a && (b === void 0 || b === null || b !== b) || comp > 0;
}
function zipWithFactory(keyIter, zipper, iters, zipAll2) {
  var zipSequence = makeSequence(keyIter);
  var sizes = new ArraySeq(iters).map(function(i) {
    return i.size;
  });
  zipSequence.size = zipAll2 ? sizes.max() : sizes.min();
  zipSequence.__iterate = function(fn, reverse3) {
    var iterator = this.__iterator(ITERATE_VALUES, reverse3);
    var step;
    var iterations = 0;
    while (!(step = iterator.next()).done) {
      if (fn(step.value, iterations++, this) === false) {
        break;
      }
    }
    return iterations;
  };
  zipSequence.__iteratorUncached = function(type, reverse3) {
    var iterators = iters.map(
      function(i) {
        return i = Collection(i), getIterator(reverse3 ? i.reverse() : i);
      }
    );
    var iterations = 0;
    var isDone = false;
    return new Iterator(function() {
      var steps;
      if (!isDone) {
        steps = iterators.map(function(i) {
          return i.next();
        });
        isDone = zipAll2 ? steps.every(function(s) {
          return s.done;
        }) : steps.some(function(s) {
          return s.done;
        });
      }
      if (isDone) {
        return iteratorDone();
      }
      return iteratorValue(
        type,
        iterations++,
        zipper.apply(
          null,
          steps.map(function(s) {
            return s.value;
          })
        )
      );
    });
  };
  return zipSequence;
}
function reify(iter, seq) {
  return iter === seq ? iter : isSeq(iter) ? seq : iter.constructor(seq);
}
function validateEntry(entry) {
  if (entry !== Object(entry)) {
    throw new TypeError("Expected [K, V] tuple: " + entry);
  }
}
function collectionClass(collection) {
  return isKeyed(collection) ? KeyedCollection : isIndexed(collection) ? IndexedCollection : SetCollection;
}
function makeSequence(collection) {
  return Object.create(
    (isKeyed(collection) ? KeyedSeq : isIndexed(collection) ? IndexedSeq : SetSeq).prototype
  );
}
function cacheResultThrough() {
  if (this._iter.cacheResult) {
    this._iter.cacheResult();
    this.size = this._iter.size;
    return this;
  }
  return Seq.prototype.cacheResult.call(this);
}
function defaultComparator(a, b) {
  if (a === void 0 && b === void 0) {
    return 0;
  }
  if (a === void 0) {
    return 1;
  }
  if (b === void 0) {
    return -1;
  }
  return a > b ? 1 : a < b ? -1 : 0;
}
function arrCopy(arr, offset) {
  offset = offset || 0;
  var len = Math.max(0, arr.length - offset);
  var newArr = new Array(len);
  for (var ii = 0; ii < len; ii++) {
    newArr[ii] = arr[ii + offset];
  }
  return newArr;
}
function invariant(condition, error) {
  if (!condition) {
    throw new Error(error);
  }
}
function assertNotInfinite(size) {
  invariant(
    size !== Infinity,
    "Cannot perform this action with an infinite size."
  );
}
function coerceKeyPath(keyPath) {
  if (isArrayLike(keyPath) && typeof keyPath !== "string") {
    return keyPath;
  }
  if (isOrdered(keyPath)) {
    return keyPath.toArray();
  }
  throw new TypeError(
    "Invalid keyPath: expected Ordered Collection or Array: " + keyPath
  );
}
function isPlainObject3(value2) {
  if (!value2 || typeof value2 !== "object" || toString2.call(value2) !== "[object Object]") {
    return false;
  }
  var proto = Object.getPrototypeOf(value2);
  if (proto === null) {
    return true;
  }
  var parentProto = proto;
  var nextProto = Object.getPrototypeOf(proto);
  while (nextProto !== null) {
    parentProto = nextProto;
    nextProto = Object.getPrototypeOf(parentProto);
  }
  return parentProto === proto;
}
function isDataStructure(value2) {
  return typeof value2 === "object" && (isImmutable(value2) || Array.isArray(value2) || isPlainObject3(value2));
}
function quoteString(value2) {
  try {
    return typeof value2 === "string" ? JSON.stringify(value2) : String(value2);
  } catch (_ignoreError) {
    return JSON.stringify(value2);
  }
}
function has(collection, key) {
  return isImmutable(collection) ? collection.has(key) : isDataStructure(collection) && hasOwnProperty.call(collection, key);
}
function get(collection, key, notSetValue) {
  return isImmutable(collection) ? collection.get(key, notSetValue) : !has(collection, key) ? notSetValue : typeof collection.get === "function" ? collection.get(key) : collection[key];
}
function shallowCopy(from) {
  if (Array.isArray(from)) {
    return arrCopy(from);
  }
  var to = {};
  for (var key in from) {
    if (hasOwnProperty.call(from, key)) {
      to[key] = from[key];
    }
  }
  return to;
}
function remove(collection, key) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.remove) {
      throw new TypeError(
        "Cannot update immutable value without .remove() method: " + collection
      );
    }
    return collection.remove(key);
  }
  if (!hasOwnProperty.call(collection, key)) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  if (Array.isArray(collectionCopy)) {
    collectionCopy.splice(key, 1);
  } else {
    delete collectionCopy[key];
  }
  return collectionCopy;
}
function set(collection, key, value2) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot update non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    if (!collection.set) {
      throw new TypeError(
        "Cannot update immutable value without .set() method: " + collection
      );
    }
    return collection.set(key, value2);
  }
  if (hasOwnProperty.call(collection, key) && value2 === collection[key]) {
    return collection;
  }
  var collectionCopy = shallowCopy(collection);
  collectionCopy[key] = value2;
  return collectionCopy;
}
function updateIn$1(collection, keyPath, notSetValue, updater) {
  if (!updater) {
    updater = notSetValue;
    notSetValue = void 0;
  }
  var updatedValue = updateInDeeply(
    isImmutable(collection),
    collection,
    coerceKeyPath(keyPath),
    0,
    notSetValue,
    updater
  );
  return updatedValue === NOT_SET ? notSetValue : updatedValue;
}
function updateInDeeply(inImmutable, existing, keyPath, i, notSetValue, updater) {
  var wasNotSet = existing === NOT_SET;
  if (i === keyPath.length) {
    var existingValue = wasNotSet ? notSetValue : existing;
    var newValue = updater(existingValue);
    return newValue === existingValue ? existing : newValue;
  }
  if (!wasNotSet && !isDataStructure(existing)) {
    throw new TypeError(
      "Cannot update within non-data-structure value in path [" + keyPath.slice(0, i).map(quoteString) + "]: " + existing
    );
  }
  var key = keyPath[i];
  var nextExisting = wasNotSet ? NOT_SET : get(existing, key, NOT_SET);
  var nextUpdated = updateInDeeply(
    nextExisting === NOT_SET ? inImmutable : isImmutable(nextExisting),
    nextExisting,
    keyPath,
    i + 1,
    notSetValue,
    updater
  );
  return nextUpdated === nextExisting ? existing : nextUpdated === NOT_SET ? remove(existing, key) : set(
    wasNotSet ? inImmutable ? emptyMap() : {} : existing,
    key,
    nextUpdated
  );
}
function setIn$1(collection, keyPath, value2) {
  return updateIn$1(collection, keyPath, NOT_SET, function() {
    return value2;
  });
}
function setIn(keyPath, v) {
  return setIn$1(this, keyPath, v);
}
function removeIn(collection, keyPath) {
  return updateIn$1(collection, keyPath, function() {
    return NOT_SET;
  });
}
function deleteIn(keyPath) {
  return removeIn(this, keyPath);
}
function update$1(collection, key, notSetValue, updater) {
  return updateIn$1(collection, [key], notSetValue, updater);
}
function update(key, notSetValue, updater) {
  return arguments.length === 1 ? key(this) : update$1(this, key, notSetValue, updater);
}
function updateIn(keyPath, notSetValue, updater) {
  return updateIn$1(this, keyPath, notSetValue, updater);
}
function merge$1() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeIntoKeyedWith(this, iters);
}
function mergeWith$1(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  if (typeof merger !== "function") {
    throw new TypeError("Invalid merger function: " + merger);
  }
  return mergeIntoKeyedWith(this, iters, merger);
}
function mergeIntoKeyedWith(collection, collections, merger) {
  var iters = [];
  for (var ii = 0; ii < collections.length; ii++) {
    var collection$1 = KeyedCollection(collections[ii]);
    if (collection$1.size !== 0) {
      iters.push(collection$1);
    }
  }
  if (iters.length === 0) {
    return collection;
  }
  if (collection.toSeq().size === 0 && !collection.__ownerID && iters.length === 1) {
    return collection.constructor(iters[0]);
  }
  return collection.withMutations(function(collection2) {
    var mergeIntoCollection = merger ? function(value2, key) {
      update$1(
        collection2,
        key,
        NOT_SET,
        function(oldVal) {
          return oldVal === NOT_SET ? value2 : merger(oldVal, value2, key);
        }
      );
    } : function(value2, key) {
      collection2.set(key, value2);
    };
    for (var ii2 = 0; ii2 < iters.length; ii2++) {
      iters[ii2].forEach(mergeIntoCollection);
    }
  });
}
function merge(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0)
    sources[len] = arguments[len + 1];
  return mergeWithSources(collection, sources);
}
function mergeWith(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0)
    sources[len] = arguments[len + 2];
  return mergeWithSources(collection, sources, merger);
}
function mergeDeep$1(collection) {
  var sources = [], len = arguments.length - 1;
  while (len-- > 0)
    sources[len] = arguments[len + 1];
  return mergeDeepWithSources(collection, sources);
}
function mergeDeepWith$1(merger, collection) {
  var sources = [], len = arguments.length - 2;
  while (len-- > 0)
    sources[len] = arguments[len + 2];
  return mergeDeepWithSources(collection, sources, merger);
}
function mergeDeepWithSources(collection, sources, merger) {
  return mergeWithSources(collection, sources, deepMergerWith(merger));
}
function mergeWithSources(collection, sources, merger) {
  if (!isDataStructure(collection)) {
    throw new TypeError(
      "Cannot merge into non-data-structure value: " + collection
    );
  }
  if (isImmutable(collection)) {
    return typeof merger === "function" && collection.mergeWith ? collection.mergeWith.apply(collection, [merger].concat(sources)) : collection.merge ? collection.merge.apply(collection, sources) : collection.concat.apply(collection, sources);
  }
  var isArray3 = Array.isArray(collection);
  var merged = collection;
  var Collection3 = isArray3 ? IndexedCollection : KeyedCollection;
  var mergeItem = isArray3 ? function(value2) {
    if (merged === collection) {
      merged = shallowCopy(merged);
    }
    merged.push(value2);
  } : function(value2, key) {
    var hasVal = hasOwnProperty.call(merged, key);
    var nextVal = hasVal && merger ? merger(merged[key], value2, key) : value2;
    if (!hasVal || nextVal !== merged[key]) {
      if (merged === collection) {
        merged = shallowCopy(merged);
      }
      merged[key] = nextVal;
    }
  };
  for (var i = 0; i < sources.length; i++) {
    Collection3(sources[i]).forEach(mergeItem);
  }
  return merged;
}
function deepMergerWith(merger) {
  function deepMerger(oldValue, newValue, key) {
    return isDataStructure(oldValue) && isDataStructure(newValue) && areMergeable(oldValue, newValue) ? mergeWithSources(oldValue, [newValue], deepMerger) : merger ? merger(oldValue, newValue, key) : newValue;
  }
  return deepMerger;
}
function areMergeable(oldDataStructure, newDataStructure) {
  var oldSeq = Seq(oldDataStructure);
  var newSeq = Seq(newDataStructure);
  return isIndexed(oldSeq) === isIndexed(newSeq) && isKeyed(oldSeq) === isKeyed(newSeq);
}
function mergeDeep() {
  var iters = [], len = arguments.length;
  while (len--)
    iters[len] = arguments[len];
  return mergeDeepWithSources(this, iters);
}
function mergeDeepWith(merger) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return mergeDeepWithSources(this, iters, merger);
}
function mergeIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(this, keyPath, emptyMap(), function(m) {
    return mergeWithSources(m, iters);
  });
}
function mergeDeepIn(keyPath) {
  var iters = [], len = arguments.length - 1;
  while (len-- > 0)
    iters[len] = arguments[len + 1];
  return updateIn$1(
    this,
    keyPath,
    emptyMap(),
    function(m) {
      return mergeDeepWithSources(m, iters);
    }
  );
}
function withMutations(fn) {
  var mutable = this.asMutable();
  fn(mutable);
  return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
}
function asMutable() {
  return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
}
function asImmutable() {
  return this.__ensureOwner();
}
function wasAltered() {
  return this.__altered;
}
function mapIteratorValue(type, entry) {
  return iteratorValue(type, entry[0], entry[1]);
}
function mapIteratorFrame(node, prev) {
  return {
    node,
    index: 0,
    __prev: prev
  };
}
function makeMap(size, root, ownerID, hash2) {
  var map2 = Object.create(MapPrototype);
  map2.size = size;
  map2._root = root;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
function emptyMap() {
  return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
}
function updateMap(map2, k, v) {
  var newRoot;
  var newSize;
  if (!map2._root) {
    if (v === NOT_SET) {
      return map2;
    }
    newSize = 1;
    newRoot = new ArrayMapNode(map2.__ownerID, [[k, v]]);
  } else {
    var didChangeSize = MakeRef();
    var didAlter = MakeRef();
    newRoot = updateNode(
      map2._root,
      map2.__ownerID,
      0,
      void 0,
      k,
      v,
      didChangeSize,
      didAlter
    );
    if (!didAlter.value) {
      return map2;
    }
    newSize = map2.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
  }
  if (map2.__ownerID) {
    map2.size = newSize;
    map2._root = newRoot;
    map2.__hash = void 0;
    map2.__altered = true;
    return map2;
  }
  return newRoot ? makeMap(newSize, newRoot) : emptyMap();
}
function updateNode(node, ownerID, shift, keyHash, key, value2, didChangeSize, didAlter) {
  if (!node) {
    if (value2 === NOT_SET) {
      return node;
    }
    SetRef(didAlter);
    SetRef(didChangeSize);
    return new ValueNode(ownerID, keyHash, [key, value2]);
  }
  return node.update(
    ownerID,
    shift,
    keyHash,
    key,
    value2,
    didChangeSize,
    didAlter
  );
}
function isLeafNode(node) {
  return node.constructor === ValueNode || node.constructor === HashCollisionNode;
}
function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
  if (node.keyHash === keyHash) {
    return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
  }
  var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
  var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
  var newNode;
  var nodes = idx1 === idx2 ? [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] : (newNode = new ValueNode(ownerID, keyHash, entry), idx1 < idx2 ? [node, newNode] : [newNode, node]);
  return new BitmapIndexedNode(ownerID, 1 << idx1 | 1 << idx2, nodes);
}
function createNodes(ownerID, entries3, key, value2) {
  if (!ownerID) {
    ownerID = new OwnerID();
  }
  var node = new ValueNode(ownerID, hash(key), [key, value2]);
  for (var ii = 0; ii < entries3.length; ii++) {
    var entry = entries3[ii];
    node = node.update(ownerID, 0, void 0, entry[0], entry[1]);
  }
  return node;
}
function packNodes(ownerID, nodes, count2, excluding) {
  var bitmap = 0;
  var packedII = 0;
  var packedNodes = new Array(count2);
  for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
    var node = nodes[ii];
    if (node !== void 0 && ii !== excluding) {
      bitmap |= bit;
      packedNodes[packedII++] = node;
    }
  }
  return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
}
function expandNodes(ownerID, nodes, bitmap, including, node) {
  var count2 = 0;
  var expandedNodes = new Array(SIZE);
  for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
    expandedNodes[ii] = bitmap & 1 ? nodes[count2++] : void 0;
  }
  expandedNodes[including] = node;
  return new HashArrayMapNode(ownerID, count2 + 1, expandedNodes);
}
function popCount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function setAt(array, idx, val, canEdit) {
  var newArray = canEdit ? array : arrCopy(array);
  newArray[idx] = val;
  return newArray;
}
function spliceIn(array, idx, val, canEdit) {
  var newLen = array.length + 1;
  if (canEdit && idx + 1 === newLen) {
    array[idx] = val;
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      newArray[ii] = val;
      after = -1;
    } else {
      newArray[ii] = array[ii + after];
    }
  }
  return newArray;
}
function spliceOut(array, idx, canEdit) {
  var newLen = array.length - 1;
  if (canEdit && idx === newLen) {
    array.pop();
    return array;
  }
  var newArray = new Array(newLen);
  var after = 0;
  for (var ii = 0; ii < newLen; ii++) {
    if (ii === idx) {
      after = 1;
    }
    newArray[ii] = array[ii + after];
  }
  return newArray;
}
function isList(maybeList) {
  return Boolean(maybeList && maybeList[IS_LIST_SYMBOL]);
}
function iterateList(list, reverse3) {
  var left = list._origin;
  var right = list._capacity;
  var tailPos = getTailOffset(right);
  var tail = list._tail;
  return iterateNodeOrLeaf(list._root, list._level, 0);
  function iterateNodeOrLeaf(node, level, offset) {
    return level === 0 ? iterateLeaf(node, offset) : iterateNode(node, level, offset);
  }
  function iterateLeaf(node, offset) {
    var array = offset === tailPos ? tail && tail.array : node && node.array;
    var from = offset > left ? 0 : left - offset;
    var to = right - offset;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      if (from === to) {
        return DONE;
      }
      var idx = reverse3 ? --to : from++;
      return array && array[idx];
    };
  }
  function iterateNode(node, level, offset) {
    var values2;
    var array = node && node.array;
    var from = offset > left ? 0 : left - offset >> level;
    var to = (right - offset >> level) + 1;
    if (to > SIZE) {
      to = SIZE;
    }
    return function() {
      while (true) {
        if (values2) {
          var value2 = values2();
          if (value2 !== DONE) {
            return value2;
          }
          values2 = null;
        }
        if (from === to) {
          return DONE;
        }
        var idx = reverse3 ? --to : from++;
        values2 = iterateNodeOrLeaf(
          array && array[idx],
          level - SHIFT,
          offset + (idx << level)
        );
      }
    };
  }
}
function makeList(origin, capacity, level, root, tail, ownerID, hash2) {
  var list = Object.create(ListPrototype);
  list.size = capacity - origin;
  list._origin = origin;
  list._capacity = capacity;
  list._level = level;
  list._root = root;
  list._tail = tail;
  list.__ownerID = ownerID;
  list.__hash = hash2;
  list.__altered = false;
  return list;
}
function emptyList() {
  return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
}
function updateList(list, index, value2) {
  index = wrapIndex(list, index);
  if (index !== index) {
    return list;
  }
  if (index >= list.size || index < 0) {
    return list.withMutations(function(list2) {
      index < 0 ? setListBounds(list2, index).set(0, value2) : setListBounds(list2, 0, index + 1).set(index, value2);
    });
  }
  index += list._origin;
  var newTail = list._tail;
  var newRoot = list._root;
  var didAlter = MakeRef();
  if (index >= getTailOffset(list._capacity)) {
    newTail = updateVNode(newTail, list.__ownerID, 0, index, value2, didAlter);
  } else {
    newRoot = updateVNode(
      newRoot,
      list.__ownerID,
      list._level,
      index,
      value2,
      didAlter
    );
  }
  if (!didAlter.value) {
    return list;
  }
  if (list.__ownerID) {
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
}
function updateVNode(node, ownerID, level, index, value2, didAlter) {
  var idx = index >>> level & MASK;
  var nodeHas = node && idx < node.array.length;
  if (!nodeHas && value2 === void 0) {
    return node;
  }
  var newNode;
  if (level > 0) {
    var lowerNode = node && node.array[idx];
    var newLowerNode = updateVNode(
      lowerNode,
      ownerID,
      level - SHIFT,
      index,
      value2,
      didAlter
    );
    if (newLowerNode === lowerNode) {
      return node;
    }
    newNode = editableVNode(node, ownerID);
    newNode.array[idx] = newLowerNode;
    return newNode;
  }
  if (nodeHas && node.array[idx] === value2) {
    return node;
  }
  if (didAlter) {
    SetRef(didAlter);
  }
  newNode = editableVNode(node, ownerID);
  if (value2 === void 0 && idx === newNode.array.length - 1) {
    newNode.array.pop();
  } else {
    newNode.array[idx] = value2;
  }
  return newNode;
}
function editableVNode(node, ownerID) {
  if (ownerID && node && ownerID === node.ownerID) {
    return node;
  }
  return new VNode(node ? node.array.slice() : [], ownerID);
}
function listNodeFor(list, rawIndex) {
  if (rawIndex >= getTailOffset(list._capacity)) {
    return list._tail;
  }
  if (rawIndex < 1 << list._level + SHIFT) {
    var node = list._root;
    var level = list._level;
    while (node && level > 0) {
      node = node.array[rawIndex >>> level & MASK];
      level -= SHIFT;
    }
    return node;
  }
}
function setListBounds(list, begin, end) {
  if (begin !== void 0) {
    begin |= 0;
  }
  if (end !== void 0) {
    end |= 0;
  }
  var owner = list.__ownerID || new OwnerID();
  var oldOrigin = list._origin;
  var oldCapacity = list._capacity;
  var newOrigin = oldOrigin + begin;
  var newCapacity = end === void 0 ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
  if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
    return list;
  }
  if (newOrigin >= newCapacity) {
    return list.clear();
  }
  var newLevel = list._level;
  var newRoot = list._root;
  var offsetShift = 0;
  while (newOrigin + offsetShift < 0) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [void 0, newRoot] : [],
      owner
    );
    newLevel += SHIFT;
    offsetShift += 1 << newLevel;
  }
  if (offsetShift) {
    newOrigin += offsetShift;
    oldOrigin += offsetShift;
    newCapacity += offsetShift;
    oldCapacity += offsetShift;
  }
  var oldTailOffset = getTailOffset(oldCapacity);
  var newTailOffset = getTailOffset(newCapacity);
  while (newTailOffset >= 1 << newLevel + SHIFT) {
    newRoot = new VNode(
      newRoot && newRoot.array.length ? [newRoot] : [],
      owner
    );
    newLevel += SHIFT;
  }
  var oldTail = list._tail;
  var newTail = newTailOffset < oldTailOffset ? listNodeFor(list, newCapacity - 1) : newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
  if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
    newRoot = editableVNode(newRoot, owner);
    var node = newRoot;
    for (var level = newLevel; level > SHIFT; level -= SHIFT) {
      var idx = oldTailOffset >>> level & MASK;
      node = node.array[idx] = editableVNode(node.array[idx], owner);
    }
    node.array[oldTailOffset >>> SHIFT & MASK] = oldTail;
  }
  if (newCapacity < oldCapacity) {
    newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
  }
  if (newOrigin >= newTailOffset) {
    newOrigin -= newTailOffset;
    newCapacity -= newTailOffset;
    newLevel = SHIFT;
    newRoot = null;
    newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
  } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
    offsetShift = 0;
    while (newRoot) {
      var beginIndex = newOrigin >>> newLevel & MASK;
      if (beginIndex !== newTailOffset >>> newLevel & MASK) {
        break;
      }
      if (beginIndex) {
        offsetShift += (1 << newLevel) * beginIndex;
      }
      newLevel -= SHIFT;
      newRoot = newRoot.array[beginIndex];
    }
    if (newRoot && newOrigin > oldOrigin) {
      newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
    }
    if (newRoot && newTailOffset < oldTailOffset) {
      newRoot = newRoot.removeAfter(
        owner,
        newLevel,
        newTailOffset - offsetShift
      );
    }
    if (offsetShift) {
      newOrigin -= offsetShift;
      newCapacity -= offsetShift;
    }
  }
  if (list.__ownerID) {
    list.size = newCapacity - newOrigin;
    list._origin = newOrigin;
    list._capacity = newCapacity;
    list._level = newLevel;
    list._root = newRoot;
    list._tail = newTail;
    list.__hash = void 0;
    list.__altered = true;
    return list;
  }
  return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
}
function getTailOffset(size) {
  return size < SIZE ? 0 : size - 1 >>> SHIFT << SHIFT;
}
function makeOrderedMap(map2, list, ownerID, hash2) {
  var omap = Object.create(OrderedMap.prototype);
  omap.size = map2 ? map2.size : 0;
  omap._map = map2;
  omap._list = list;
  omap.__ownerID = ownerID;
  omap.__hash = hash2;
  omap.__altered = false;
  return omap;
}
function emptyOrderedMap() {
  return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
}
function updateOrderedMap(omap, k, v) {
  var map2 = omap._map;
  var list = omap._list;
  var i = map2.get(k);
  var has5 = i !== void 0;
  var newMap;
  var newList;
  if (v === NOT_SET) {
    if (!has5) {
      return omap;
    }
    if (list.size >= SIZE && list.size >= map2.size * 2) {
      newList = list.filter(function(entry, idx) {
        return entry !== void 0 && i !== idx;
      });
      newMap = newList.toKeyedSeq().map(function(entry) {
        return entry[0];
      }).flip().toMap();
      if (omap.__ownerID) {
        newMap.__ownerID = newList.__ownerID = omap.__ownerID;
      }
    } else {
      newMap = map2.remove(k);
      newList = i === list.size - 1 ? list.pop() : list.set(i, void 0);
    }
  } else if (has5) {
    if (v === list.get(i)[1]) {
      return omap;
    }
    newMap = map2;
    newList = list.set(i, [k, v]);
  } else {
    newMap = map2.set(k, list.size);
    newList = list.set(list.size, [k, v]);
  }
  if (omap.__ownerID) {
    omap.size = newMap.size;
    omap._map = newMap;
    omap._list = newList;
    omap.__hash = void 0;
    omap.__altered = true;
    return omap;
  }
  return makeOrderedMap(newMap, newList);
}
function isStack(maybeStack) {
  return Boolean(maybeStack && maybeStack[IS_STACK_SYMBOL]);
}
function makeStack(size, head, ownerID, hash2) {
  var map2 = Object.create(StackPrototype);
  map2.size = size;
  map2._head = head;
  map2.__ownerID = ownerID;
  map2.__hash = hash2;
  map2.__altered = false;
  return map2;
}
function emptyStack() {
  return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
}
function isSet2(maybeSet) {
  return Boolean(maybeSet && maybeSet[IS_SET_SYMBOL]);
}
function isOrderedSet(maybeOrderedSet) {
  return isSet2(maybeOrderedSet) && isOrdered(maybeOrderedSet);
}
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (!isCollection(b) || a.size !== void 0 && b.size !== void 0 && a.size !== b.size || a.__hash !== void 0 && b.__hash !== void 0 && a.__hash !== b.__hash || isKeyed(a) !== isKeyed(b) || isIndexed(a) !== isIndexed(b) || isOrdered(a) !== isOrdered(b)) {
    return false;
  }
  if (a.size === 0 && b.size === 0) {
    return true;
  }
  var notAssociative = !isAssociative(a);
  if (isOrdered(a)) {
    var entries3 = a.entries();
    return b.every(function(v, k) {
      var entry = entries3.next().value;
      return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
    }) && entries3.next().done;
  }
  var flipped = false;
  if (a.size === void 0) {
    if (b.size === void 0) {
      if (typeof a.cacheResult === "function") {
        a.cacheResult();
      }
    } else {
      flipped = true;
      var _ = a;
      a = b;
      b = _;
    }
  }
  var allEqual = true;
  var bSize = b.__iterate(function(v, k) {
    if (notAssociative ? !a.has(v) : flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
      allEqual = false;
      return false;
    }
  });
  return allEqual && a.size === bSize;
}
function mixin(ctor, methods) {
  var keyCopier = function(key) {
    ctor.prototype[key] = methods[key];
  };
  Object.keys(methods).forEach(keyCopier);
  Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(methods).forEach(keyCopier);
  return ctor;
}
function toJS(value2) {
  if (!value2 || typeof value2 !== "object") {
    return value2;
  }
  if (!isCollection(value2)) {
    if (!isDataStructure(value2)) {
      return value2;
    }
    value2 = Seq(value2);
  }
  if (isKeyed(value2)) {
    var result$1 = {};
    value2.__iterate(function(v, k) {
      result$1[k] = toJS(v);
    });
    return result$1;
  }
  var result = [];
  value2.__iterate(function(v) {
    result.push(toJS(v));
  });
  return result;
}
function updateSet(set3, newMap) {
  if (set3.__ownerID) {
    set3.size = newMap.size;
    set3._map = newMap;
    return set3;
  }
  return newMap === set3._map ? set3 : newMap.size === 0 ? set3.__empty() : set3.__make(newMap);
}
function makeSet(map2, ownerID) {
  var set3 = Object.create(SetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
function emptySet() {
  return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
}
function getIn$1(collection, searchKeyPath, notSetValue) {
  var keyPath = coerceKeyPath(searchKeyPath);
  var i = 0;
  while (i !== keyPath.length) {
    collection = get(collection, keyPath[i++], NOT_SET);
    if (collection === NOT_SET) {
      return notSetValue;
    }
  }
  return collection;
}
function getIn(searchKeyPath, notSetValue) {
  return getIn$1(this, searchKeyPath, notSetValue);
}
function hasIn$1(collection, keyPath) {
  return getIn$1(collection, keyPath, NOT_SET) !== NOT_SET;
}
function hasIn(searchKeyPath) {
  return hasIn$1(this, searchKeyPath);
}
function toObject() {
  assertNotInfinite(this.size);
  var object = {};
  this.__iterate(function(v, k) {
    object[k] = v;
  });
  return object;
}
function reduce(collection, reducer, reduction, context, useFirst, reverse3) {
  assertNotInfinite(collection.size);
  collection.__iterate(function(v, k, c) {
    if (useFirst) {
      useFirst = false;
      reduction = v;
    } else {
      reduction = reducer.call(context, reduction, v, k, c);
    }
  }, reverse3);
  return reduction;
}
function keyMapper(v, k) {
  return k;
}
function entryMapper(v, k) {
  return [k, v];
}
function not(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
function neg2(predicate) {
  return function() {
    return -predicate.apply(this, arguments);
  };
}
function defaultZipper() {
  return arrCopy(arguments);
}
function defaultNegComparator(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function hashCollection(collection) {
  if (collection.size === Infinity) {
    return 0;
  }
  var ordered = isOrdered(collection);
  var keyed = isKeyed(collection);
  var h = ordered ? 1 : 0;
  var size = collection.__iterate(
    keyed ? ordered ? function(v, k) {
      h = 31 * h + hashMerge(hash(v), hash(k)) | 0;
    } : function(v, k) {
      h = h + hashMerge(hash(v), hash(k)) | 0;
    } : ordered ? function(v) {
      h = 31 * h + hash(v) | 0;
    } : function(v) {
      h = h + hash(v) | 0;
    }
  );
  return murmurHashOfSize(size, h);
}
function murmurHashOfSize(size, h) {
  h = imul(h, 3432918353);
  h = imul(h << 15 | h >>> -15, 461845907);
  h = imul(h << 13 | h >>> -13, 5);
  h = (h + 3864292196 | 0) ^ size;
  h = imul(h ^ h >>> 16, 2246822507);
  h = imul(h ^ h >>> 13, 3266489909);
  h = smi(h ^ h >>> 16);
  return h;
}
function hashMerge(a, b) {
  return a ^ b + 2654435769 + (a << 6) + (a >> 2) | 0;
}
function makeOrderedSet(map2, ownerID) {
  var set3 = Object.create(OrderedSetPrototype);
  set3.size = map2 ? map2.size : 0;
  set3._map = map2;
  set3.__ownerID = ownerID;
  return set3;
}
function emptyOrderedSet() {
  return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
}
function throwOnInvalidDefaultValues(defaultValues) {
  if (isRecord(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Record as default values. Use a plain javascript object instead."
    );
  }
  if (isImmutable(defaultValues)) {
    throw new Error(
      "Can not call `Record` with an immutable Collection as default values. Use a plain javascript object instead."
    );
  }
  if (defaultValues === null || typeof defaultValues !== "object") {
    throw new Error(
      "Can not call `Record` with a non-object as default values. Use a plain javascript object instead."
    );
  }
}
function makeRecord(likeRecord, values2, ownerID) {
  var record = Object.create(Object.getPrototypeOf(likeRecord));
  record._values = values2;
  record.__ownerID = ownerID;
  return record;
}
function recordName(record) {
  return record.constructor.displayName || record.constructor.name || "Record";
}
function recordSeq(record) {
  return keyedSeqFromValue(record._keys.map(function(k) {
    return [k, record.get(k)];
  }));
}
function setProp(prototype, name) {
  try {
    Object.defineProperty(prototype, name, {
      get: function() {
        return this.get(name);
      },
      set: function(value2) {
        invariant(this.__ownerID, "Cannot set on an immutable record.");
        this.set(name, value2);
      }
    });
  } catch (error) {
  }
}
function fromJS(value2, converter) {
  return fromJSWith(
    [],
    converter || defaultConverter,
    value2,
    "",
    converter && converter.length > 2 ? [] : void 0,
    { "": value2 }
  );
}
function fromJSWith(stack, converter, value2, key, keyPath, parentValue) {
  if (typeof value2 !== "string" && !isImmutable(value2) && (isArrayLike(value2) || hasIterator(value2) || isPlainObject3(value2))) {
    if (~stack.indexOf(value2)) {
      throw new TypeError("Cannot convert circular structure to Immutable");
    }
    stack.push(value2);
    keyPath && key !== "" && keyPath.push(key);
    var converted = converter.call(
      parentValue,
      key,
      Seq(value2).map(
        function(v, k) {
          return fromJSWith(stack, converter, v, k, keyPath, value2);
        }
      ),
      keyPath && keyPath.slice()
    );
    stack.pop();
    keyPath && keyPath.pop();
    return converted;
  }
  return value2;
}
function defaultConverter(k, v) {
  return isIndexed(v) ? v.toList() : isKeyed(v) ? v.toMap() : v.toSet();
}
var DELETE, SHIFT, SIZE, MASK, NOT_SET, IS_COLLECTION_SYMBOL, IS_KEYED_SYMBOL, IS_INDEXED_SYMBOL, Collection, KeyedCollection, IndexedCollection, SetCollection, IS_SEQ_SYMBOL, IS_RECORD_SYMBOL, IS_ORDERED_SYMBOL, ITERATE_KEYS, ITERATE_VALUES, ITERATE_ENTRIES, REAL_ITERATOR_SYMBOL, FAUX_ITERATOR_SYMBOL, ITERATOR_SYMBOL, Iterator, hasOwnProperty, Seq, KeyedSeq, IndexedSeq, SetSeq, ArraySeq, ObjectSeq, CollectionSeq, EMPTY_SEQ, IS_MAP_SYMBOL, imul, defaultValueOf, isExtensible, canDefineProperty, usingWeakMap, weakMap, symbolMap, _objHashUID, UID_HASH_KEY, STRING_HASH_CACHE_MIN_STRLEN, STRING_HASH_CACHE_MAX_SIZE, STRING_HASH_CACHE_SIZE, stringHashCache, ToKeyedSequence, ToIndexedSequence, ToSetSequence, FromEntriesSequence, toString2, Map2, MapPrototype, ArrayMapNode, BitmapIndexedNode, HashArrayMapNode, HashCollisionNode, ValueNode, MapIterator, EMPTY_MAP, MAX_ARRAY_MAP_SIZE, MAX_BITMAP_INDEXED_SIZE, MIN_HASH_ARRAY_MAP_SIZE, IS_LIST_SYMBOL, List, ListPrototype, VNode, DONE, EMPTY_LIST, OrderedMap, EMPTY_ORDERED_MAP, IS_STACK_SYMBOL, Stack, StackPrototype, EMPTY_STACK, IS_SET_SYMBOL, Set2, SetPrototype, EMPTY_SET, Range, EMPTY_RANGE, CollectionPrototype, KeyedCollectionPrototype, IndexedCollectionPrototype, SetCollectionPrototype, OrderedSet, OrderedSetPrototype, EMPTY_ORDERED_SET, PairSorting, Record, RecordPrototype, Repeat, EMPTY_REPEAT, version, Immutable, Iterable, immutable_es_default;
var init_immutable_es = __esm({
  "../node_modules/immutable/dist/immutable.es.js"() {
    "use strict";
    DELETE = "delete";
    SHIFT = 5;
    SIZE = 1 << SHIFT;
    MASK = SIZE - 1;
    NOT_SET = {};
    IS_COLLECTION_SYMBOL = "@@__IMMUTABLE_ITERABLE__@@";
    IS_KEYED_SYMBOL = "@@__IMMUTABLE_KEYED__@@";
    IS_INDEXED_SYMBOL = "@@__IMMUTABLE_INDEXED__@@";
    Collection = function Collection2(value2) {
      return isCollection(value2) ? value2 : Seq(value2);
    };
    KeyedCollection = /* @__PURE__ */ function(Collection3) {
      function KeyedCollection2(value2) {
        return isKeyed(value2) ? value2 : KeyedSeq(value2);
      }
      if (Collection3)
        KeyedCollection2.__proto__ = Collection3;
      KeyedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      KeyedCollection2.prototype.constructor = KeyedCollection2;
      return KeyedCollection2;
    }(Collection);
    IndexedCollection = /* @__PURE__ */ function(Collection3) {
      function IndexedCollection2(value2) {
        return isIndexed(value2) ? value2 : IndexedSeq(value2);
      }
      if (Collection3)
        IndexedCollection2.__proto__ = Collection3;
      IndexedCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      IndexedCollection2.prototype.constructor = IndexedCollection2;
      return IndexedCollection2;
    }(Collection);
    SetCollection = /* @__PURE__ */ function(Collection3) {
      function SetCollection2(value2) {
        return isCollection(value2) && !isAssociative(value2) ? value2 : SetSeq(value2);
      }
      if (Collection3)
        SetCollection2.__proto__ = Collection3;
      SetCollection2.prototype = Object.create(Collection3 && Collection3.prototype);
      SetCollection2.prototype.constructor = SetCollection2;
      return SetCollection2;
    }(Collection);
    Collection.Keyed = KeyedCollection;
    Collection.Indexed = IndexedCollection;
    Collection.Set = SetCollection;
    IS_SEQ_SYMBOL = "@@__IMMUTABLE_SEQ__@@";
    IS_RECORD_SYMBOL = "@@__IMMUTABLE_RECORD__@@";
    IS_ORDERED_SYMBOL = "@@__IMMUTABLE_ORDERED__@@";
    ITERATE_KEYS = 0;
    ITERATE_VALUES = 1;
    ITERATE_ENTRIES = 2;
    REAL_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
    FAUX_ITERATOR_SYMBOL = "@@iterator";
    ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
    Iterator = function Iterator2(next) {
      this.next = next;
    };
    Iterator.prototype.toString = function toString() {
      return "[Iterator]";
    };
    Iterator.KEYS = ITERATE_KEYS;
    Iterator.VALUES = ITERATE_VALUES;
    Iterator.ENTRIES = ITERATE_ENTRIES;
    Iterator.prototype.inspect = Iterator.prototype.toSource = function() {
      return this.toString();
    };
    Iterator.prototype[ITERATOR_SYMBOL] = function() {
      return this;
    };
    hasOwnProperty = Object.prototype.hasOwnProperty;
    Seq = /* @__PURE__ */ function(Collection3) {
      function Seq2(value2) {
        return value2 === void 0 || value2 === null ? emptySequence() : isImmutable(value2) ? value2.toSeq() : seqFromValue(value2);
      }
      if (Collection3)
        Seq2.__proto__ = Collection3;
      Seq2.prototype = Object.create(Collection3 && Collection3.prototype);
      Seq2.prototype.constructor = Seq2;
      Seq2.prototype.toSeq = function toSeq3() {
        return this;
      };
      Seq2.prototype.toString = function toString5() {
        return this.__toString("Seq {", "}");
      };
      Seq2.prototype.cacheResult = function cacheResult() {
        if (!this._cache && this.__iterateUncached) {
          this._cache = this.entrySeq().toArray();
          this.size = this._cache.length;
        }
        return this;
      };
      Seq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var cache = this._cache;
        if (cache) {
          var size = cache.length;
          var i = 0;
          while (i !== size) {
            var entry = cache[reverse3 ? size - ++i : i++];
            if (fn(entry[1], entry[0], this) === false) {
              break;
            }
          }
          return i;
        }
        return this.__iterateUncached(fn, reverse3);
      };
      Seq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var cache = this._cache;
        if (cache) {
          var size = cache.length;
          var i = 0;
          return new Iterator(function() {
            if (i === size) {
              return iteratorDone();
            }
            var entry = cache[reverse3 ? size - ++i : i++];
            return iteratorValue(type, entry[0], entry[1]);
          });
        }
        return this.__iteratorUncached(type, reverse3);
      };
      return Seq2;
    }(Collection);
    KeyedSeq = /* @__PURE__ */ function(Seq2) {
      function KeyedSeq2(value2) {
        return value2 === void 0 || value2 === null ? emptySequence().toKeyedSeq() : isCollection(value2) ? isKeyed(value2) ? value2.toSeq() : value2.fromEntrySeq() : isRecord(value2) ? value2.toSeq() : keyedSeqFromValue(value2);
      }
      if (Seq2)
        KeyedSeq2.__proto__ = Seq2;
      KeyedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      KeyedSeq2.prototype.constructor = KeyedSeq2;
      KeyedSeq2.prototype.toKeyedSeq = function toKeyedSeq3() {
        return this;
      };
      return KeyedSeq2;
    }(Seq);
    IndexedSeq = /* @__PURE__ */ function(Seq2) {
      function IndexedSeq2(value2) {
        return value2 === void 0 || value2 === null ? emptySequence() : isCollection(value2) ? isKeyed(value2) ? value2.entrySeq() : value2.toIndexedSeq() : isRecord(value2) ? value2.toSeq().entrySeq() : indexedSeqFromValue(value2);
      }
      if (Seq2)
        IndexedSeq2.__proto__ = Seq2;
      IndexedSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      IndexedSeq2.prototype.constructor = IndexedSeq2;
      IndexedSeq2.of = function of() {
        return IndexedSeq2(arguments);
      };
      IndexedSeq2.prototype.toIndexedSeq = function toIndexedSeq2() {
        return this;
      };
      IndexedSeq2.prototype.toString = function toString5() {
        return this.__toString("Seq [", "]");
      };
      return IndexedSeq2;
    }(Seq);
    SetSeq = /* @__PURE__ */ function(Seq2) {
      function SetSeq2(value2) {
        return (isCollection(value2) && !isAssociative(value2) ? value2 : IndexedSeq(value2)).toSetSeq();
      }
      if (Seq2)
        SetSeq2.__proto__ = Seq2;
      SetSeq2.prototype = Object.create(Seq2 && Seq2.prototype);
      SetSeq2.prototype.constructor = SetSeq2;
      SetSeq2.of = function of() {
        return SetSeq2(arguments);
      };
      SetSeq2.prototype.toSetSeq = function toSetSeq2() {
        return this;
      };
      return SetSeq2;
    }(Seq);
    Seq.isSeq = isSeq;
    Seq.Keyed = KeyedSeq;
    Seq.Set = SetSeq;
    Seq.Indexed = IndexedSeq;
    Seq.prototype[IS_SEQ_SYMBOL] = true;
    ArraySeq = /* @__PURE__ */ function(IndexedSeq2) {
      function ArraySeq2(array) {
        this._array = array;
        this.size = array.length;
      }
      if (IndexedSeq2)
        ArraySeq2.__proto__ = IndexedSeq2;
      ArraySeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      ArraySeq2.prototype.constructor = ArraySeq2;
      ArraySeq2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
      };
      ArraySeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        while (i !== size) {
          var ii = reverse3 ? size - ++i : i++;
          if (fn(array[ii], ii, this) === false) {
            break;
          }
        }
        return i;
      };
      ArraySeq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var array = this._array;
        var size = array.length;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var ii = reverse3 ? size - ++i : i++;
          return iteratorValue(type, ii, array[ii]);
        });
      };
      return ArraySeq2;
    }(IndexedSeq);
    ObjectSeq = /* @__PURE__ */ function(KeyedSeq2) {
      function ObjectSeq2(object) {
        var keys2 = Object.keys(object).concat(
          Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : []
        );
        this._object = object;
        this._keys = keys2;
        this.size = keys2.length;
      }
      if (KeyedSeq2)
        ObjectSeq2.__proto__ = KeyedSeq2;
      ObjectSeq2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      ObjectSeq2.prototype.constructor = ObjectSeq2;
      ObjectSeq2.prototype.get = function get11(key, notSetValue) {
        if (notSetValue !== void 0 && !this.has(key)) {
          return notSetValue;
        }
        return this._object[key];
      };
      ObjectSeq2.prototype.has = function has5(key) {
        return hasOwnProperty.call(this._object, key);
      };
      ObjectSeq2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var object = this._object;
        var keys2 = this._keys;
        var size = keys2.length;
        var i = 0;
        while (i !== size) {
          var key = keys2[reverse3 ? size - ++i : i++];
          if (fn(object[key], key, this) === false) {
            break;
          }
        }
        return i;
      };
      ObjectSeq2.prototype.__iterator = function __iterator2(type, reverse3) {
        var object = this._object;
        var keys2 = this._keys;
        var size = keys2.length;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var key = keys2[reverse3 ? size - ++i : i++];
          return iteratorValue(type, key, object[key]);
        });
      };
      return ObjectSeq2;
    }(KeyedSeq);
    ObjectSeq.prototype[IS_ORDERED_SYMBOL] = true;
    CollectionSeq = /* @__PURE__ */ function(IndexedSeq2) {
      function CollectionSeq2(collection) {
        this._collection = collection;
        this.size = collection.length || collection.size;
      }
      if (IndexedSeq2)
        CollectionSeq2.__proto__ = IndexedSeq2;
      CollectionSeq2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      CollectionSeq2.prototype.constructor = CollectionSeq2;
      CollectionSeq2.prototype.__iterateUncached = function __iterateUncached(fn, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterate(fn, reverse3);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        var iterations = 0;
        if (isIterator(iterator)) {
          var step;
          while (!(step = iterator.next()).done) {
            if (fn(step.value, iterations++, this) === false) {
              break;
            }
          }
        }
        return iterations;
      };
      CollectionSeq2.prototype.__iteratorUncached = function __iteratorUncached(type, reverse3) {
        if (reverse3) {
          return this.cacheResult().__iterator(type, reverse3);
        }
        var collection = this._collection;
        var iterator = getIterator(collection);
        if (!isIterator(iterator)) {
          return new Iterator(iteratorDone);
        }
        var iterations = 0;
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, iterations++, step.value);
        });
      };
      return CollectionSeq2;
    }(IndexedSeq);
    IS_MAP_SYMBOL = "@@__IMMUTABLE_MAP__@@";
    imul = typeof Math.imul === "function" && Math.imul(4294967295, 2) === -2 ? Math.imul : function imul2(a, b) {
      a |= 0;
      b |= 0;
      var c = a & 65535;
      var d = b & 65535;
      return c * d + ((a >>> 16) * d + c * (b >>> 16) << 16 >>> 0) | 0;
    };
    defaultValueOf = Object.prototype.valueOf;
    isExtensible = Object.isExtensible;
    canDefineProperty = function() {
      try {
        Object.defineProperty({}, "@", {});
        return true;
      } catch (e) {
        return false;
      }
    }();
    usingWeakMap = typeof WeakMap === "function";
    if (usingWeakMap) {
      weakMap = /* @__PURE__ */ new WeakMap();
    }
    symbolMap = /* @__PURE__ */ Object.create(null);
    _objHashUID = 0;
    UID_HASH_KEY = "__immutablehash__";
    if (typeof Symbol === "function") {
      UID_HASH_KEY = Symbol(UID_HASH_KEY);
    }
    STRING_HASH_CACHE_MIN_STRLEN = 16;
    STRING_HASH_CACHE_MAX_SIZE = 255;
    STRING_HASH_CACHE_SIZE = 0;
    stringHashCache = {};
    ToKeyedSequence = /* @__PURE__ */ function(KeyedSeq2) {
      function ToKeyedSequence2(indexed, useKeys) {
        this._iter = indexed;
        this._useKeys = useKeys;
        this.size = indexed.size;
      }
      if (KeyedSeq2)
        ToKeyedSequence2.__proto__ = KeyedSeq2;
      ToKeyedSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      ToKeyedSequence2.prototype.constructor = ToKeyedSequence2;
      ToKeyedSequence2.prototype.get = function get11(key, notSetValue) {
        return this._iter.get(key, notSetValue);
      };
      ToKeyedSequence2.prototype.has = function has5(key) {
        return this._iter.has(key);
      };
      ToKeyedSequence2.prototype.valueSeq = function valueSeq2() {
        return this._iter.valueSeq();
      };
      ToKeyedSequence2.prototype.reverse = function reverse3() {
        var this$1$1 = this;
        var reversedSequence = reverseFactory(this, true);
        if (!this._useKeys) {
          reversedSequence.valueSeq = function() {
            return this$1$1._iter.toSeq().reverse();
          };
        }
        return reversedSequence;
      };
      ToKeyedSequence2.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        var mappedSequence = mapFactory(this, mapper, context);
        if (!this._useKeys) {
          mappedSequence.valueSeq = function() {
            return this$1$1._iter.toSeq().map(mapper, context);
          };
        }
        return mappedSequence;
      };
      ToKeyedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(v, k) {
          return fn(v, k, this$1$1);
        }, reverse3);
      };
      ToKeyedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._iter.__iterator(type, reverse3);
      };
      return ToKeyedSequence2;
    }(KeyedSeq);
    ToKeyedSequence.prototype[IS_ORDERED_SYMBOL] = true;
    ToIndexedSequence = /* @__PURE__ */ function(IndexedSeq2) {
      function ToIndexedSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      if (IndexedSeq2)
        ToIndexedSequence2.__proto__ = IndexedSeq2;
      ToIndexedSequence2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      ToIndexedSequence2.prototype.constructor = ToIndexedSequence2;
      ToIndexedSequence2.prototype.includes = function includes4(value2) {
        return this._iter.includes(value2);
      };
      ToIndexedSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        var i = 0;
        reverse3 && ensureSize(this);
        return this._iter.__iterate(
          function(v) {
            return fn(v, reverse3 ? this$1$1.size - ++i : i++, this$1$1);
          },
          reverse3
        );
      };
      ToIndexedSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var this$1$1 = this;
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        var i = 0;
        reverse3 && ensureSize(this);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(
            type,
            reverse3 ? this$1$1.size - ++i : i++,
            step.value,
            step
          );
        });
      };
      return ToIndexedSequence2;
    }(IndexedSeq);
    ToSetSequence = /* @__PURE__ */ function(SetSeq2) {
      function ToSetSequence2(iter) {
        this._iter = iter;
        this.size = iter.size;
      }
      if (SetSeq2)
        ToSetSequence2.__proto__ = SetSeq2;
      ToSetSequence2.prototype = Object.create(SetSeq2 && SetSeq2.prototype);
      ToSetSequence2.prototype.constructor = ToSetSequence2;
      ToSetSequence2.prototype.has = function has5(key) {
        return this._iter.includes(key);
      };
      ToSetSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(v) {
          return fn(v, v, this$1$1);
        }, reverse3);
      };
      ToSetSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          var step = iterator.next();
          return step.done ? step : iteratorValue(type, step.value, step.value, step);
        });
      };
      return ToSetSequence2;
    }(SetSeq);
    FromEntriesSequence = /* @__PURE__ */ function(KeyedSeq2) {
      function FromEntriesSequence2(entries3) {
        this._iter = entries3;
        this.size = entries3.size;
      }
      if (KeyedSeq2)
        FromEntriesSequence2.__proto__ = KeyedSeq2;
      FromEntriesSequence2.prototype = Object.create(KeyedSeq2 && KeyedSeq2.prototype);
      FromEntriesSequence2.prototype.constructor = FromEntriesSequence2;
      FromEntriesSequence2.prototype.entrySeq = function entrySeq2() {
        return this._iter.toSeq();
      };
      FromEntriesSequence2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._iter.__iterate(function(entry) {
          if (entry) {
            validateEntry(entry);
            var indexedCollection = isCollection(entry);
            return fn(
              indexedCollection ? entry.get(1) : entry[1],
              indexedCollection ? entry.get(0) : entry[0],
              this$1$1
            );
          }
        }, reverse3);
      };
      FromEntriesSequence2.prototype.__iterator = function __iterator2(type, reverse3) {
        var iterator = this._iter.__iterator(ITERATE_VALUES, reverse3);
        return new Iterator(function() {
          while (true) {
            var step = iterator.next();
            if (step.done) {
              return step;
            }
            var entry = step.value;
            if (entry) {
              validateEntry(entry);
              var indexedCollection = isCollection(entry);
              return iteratorValue(
                type,
                indexedCollection ? entry.get(0) : entry[0],
                indexedCollection ? entry.get(1) : entry[1],
                step
              );
            }
          }
        });
      };
      return FromEntriesSequence2;
    }(KeyedSeq);
    ToIndexedSequence.prototype.cacheResult = ToKeyedSequence.prototype.cacheResult = ToSetSequence.prototype.cacheResult = FromEntriesSequence.prototype.cacheResult = cacheResultThrough;
    toString2 = Object.prototype.toString;
    Map2 = /* @__PURE__ */ function(KeyedCollection2) {
      function Map3(value2) {
        return value2 === void 0 || value2 === null ? emptyMap() : isMap2(value2) && !isOrdered(value2) ? value2 : emptyMap().withMutations(function(map2) {
          var iter = KeyedCollection2(value2);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k) {
            return map2.set(k, v);
          });
        });
      }
      if (KeyedCollection2)
        Map3.__proto__ = KeyedCollection2;
      Map3.prototype = Object.create(KeyedCollection2 && KeyedCollection2.prototype);
      Map3.prototype.constructor = Map3;
      Map3.of = function of() {
        var keyValues = [], len = arguments.length;
        while (len--)
          keyValues[len] = arguments[len];
        return emptyMap().withMutations(function(map2) {
          for (var i = 0; i < keyValues.length; i += 2) {
            if (i + 1 >= keyValues.length) {
              throw new Error("Missing value for key: " + keyValues[i]);
            }
            map2.set(keyValues[i], keyValues[i + 1]);
          }
        });
      };
      Map3.prototype.toString = function toString5() {
        return this.__toString("Map {", "}");
      };
      Map3.prototype.get = function get11(k, notSetValue) {
        return this._root ? this._root.get(0, void 0, k, notSetValue) : notSetValue;
      };
      Map3.prototype.set = function set3(k, v) {
        return updateMap(this, k, v);
      };
      Map3.prototype.remove = function remove3(k) {
        return updateMap(this, k, NOT_SET);
      };
      Map3.prototype.deleteAll = function deleteAll(keys2) {
        var collection = Collection(keys2);
        if (collection.size === 0) {
          return this;
        }
        return this.withMutations(function(map2) {
          collection.forEach(function(key) {
            return map2.remove(key);
          });
        });
      };
      Map3.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._root = null;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyMap();
      };
      Map3.prototype.sort = function sort2(comparator) {
        return OrderedMap(sortFactory(this, comparator));
      };
      Map3.prototype.sortBy = function sortBy2(mapper, comparator) {
        return OrderedMap(sortFactory(this, comparator, mapper));
      };
      Map3.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        return this.withMutations(function(map3) {
          map3.forEach(function(value2, key) {
            map3.set(key, mapper.call(context, value2, key, this$1$1));
          });
        });
      };
      Map3.prototype.__iterator = function __iterator2(type, reverse3) {
        return new MapIterator(this, type, reverse3);
      };
      Map3.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        var iterations = 0;
        this._root && this._root.iterate(function(entry) {
          iterations++;
          return fn(entry[1], entry[0], this$1$1);
        }, reverse3);
        return iterations;
      };
      Map3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyMap();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeMap(this.size, this._root, ownerID, this.__hash);
      };
      return Map3;
    }(KeyedCollection);
    Map2.isMap = isMap2;
    MapPrototype = Map2.prototype;
    MapPrototype[IS_MAP_SYMBOL] = true;
    MapPrototype[DELETE] = MapPrototype.remove;
    MapPrototype.removeAll = MapPrototype.deleteAll;
    MapPrototype.setIn = setIn;
    MapPrototype.removeIn = MapPrototype.deleteIn = deleteIn;
    MapPrototype.update = update;
    MapPrototype.updateIn = updateIn;
    MapPrototype.merge = MapPrototype.concat = merge$1;
    MapPrototype.mergeWith = mergeWith$1;
    MapPrototype.mergeDeep = mergeDeep;
    MapPrototype.mergeDeepWith = mergeDeepWith;
    MapPrototype.mergeIn = mergeIn;
    MapPrototype.mergeDeepIn = mergeDeepIn;
    MapPrototype.withMutations = withMutations;
    MapPrototype.wasAltered = wasAltered;
    MapPrototype.asImmutable = asImmutable;
    MapPrototype["@@transducer/init"] = MapPrototype.asMutable = asMutable;
    MapPrototype["@@transducer/step"] = function(result, arr) {
      return result.set(arr[0], arr[1]);
    };
    MapPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    ArrayMapNode = function ArrayMapNode2(ownerID, entries3) {
      this.ownerID = ownerID;
      this.entries = entries3;
    };
    ArrayMapNode.prototype.get = function get2(shift, keyHash, key, notSetValue) {
      var entries3 = this.entries;
      for (var ii = 0, len = entries3.length; ii < len; ii++) {
        if (is(key, entries3[ii][0])) {
          return entries3[ii][1];
        }
      }
      return notSetValue;
    };
    ArrayMapNode.prototype.update = function update2(ownerID, shift, keyHash, key, value2, didChangeSize, didAlter) {
      var removed = value2 === NOT_SET;
      var entries3 = this.entries;
      var idx = 0;
      var len = entries3.length;
      for (; idx < len; idx++) {
        if (is(key, entries3[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries3[idx][1] === value2 : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && entries3.length === 1) {
        return;
      }
      if (!exists && !removed && entries3.length >= MAX_ARRAY_MAP_SIZE) {
        return createNodes(ownerID, entries3, key, value2);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries3 : arrCopy(entries3);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value2];
        }
      } else {
        newEntries.push([key, value2]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new ArrayMapNode(ownerID, newEntries);
    };
    BitmapIndexedNode = function BitmapIndexedNode2(ownerID, bitmap, nodes) {
      this.ownerID = ownerID;
      this.bitmap = bitmap;
      this.nodes = nodes;
    };
    BitmapIndexedNode.prototype.get = function get3(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var bit = 1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK);
      var bitmap = this.bitmap;
      return (bitmap & bit) === 0 ? notSetValue : this.nodes[popCount(bitmap & bit - 1)].get(
        shift + SHIFT,
        keyHash,
        key,
        notSetValue
      );
    };
    BitmapIndexedNode.prototype.update = function update3(ownerID, shift, keyHash, key, value2, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var bit = 1 << keyHashFrag;
      var bitmap = this.bitmap;
      var exists = (bitmap & bit) !== 0;
      if (!exists && value2 === NOT_SET) {
        return this;
      }
      var idx = popCount(bitmap & bit - 1);
      var nodes = this.nodes;
      var node = exists ? nodes[idx] : void 0;
      var newNode = updateNode(
        node,
        ownerID,
        shift + SHIFT,
        keyHash,
        key,
        value2,
        didChangeSize,
        didAlter
      );
      if (newNode === node) {
        return this;
      }
      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
      }
      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
        return nodes[idx ^ 1];
      }
      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
        return newNode;
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
      var newNodes = exists ? newNode ? setAt(nodes, idx, newNode, isEditable) : spliceOut(nodes, idx, isEditable) : spliceIn(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.bitmap = newBitmap;
        this.nodes = newNodes;
        return this;
      }
      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
    };
    HashArrayMapNode = function HashArrayMapNode2(ownerID, count2, nodes) {
      this.ownerID = ownerID;
      this.count = count2;
      this.nodes = nodes;
    };
    HashArrayMapNode.prototype.get = function get4(shift, keyHash, key, notSetValue) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var node = this.nodes[idx];
      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
    };
    HashArrayMapNode.prototype.update = function update4(ownerID, shift, keyHash, key, value2, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
      var removed = value2 === NOT_SET;
      var nodes = this.nodes;
      var node = nodes[idx];
      if (removed && !node) {
        return this;
      }
      var newNode = updateNode(
        node,
        ownerID,
        shift + SHIFT,
        keyHash,
        key,
        value2,
        didChangeSize,
        didAlter
      );
      if (newNode === node) {
        return this;
      }
      var newCount = this.count;
      if (!node) {
        newCount++;
      } else if (!newNode) {
        newCount--;
        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
          return packNodes(ownerID, nodes, newCount, idx);
        }
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newNodes = setAt(nodes, idx, newNode, isEditable);
      if (isEditable) {
        this.count = newCount;
        this.nodes = newNodes;
        return this;
      }
      return new HashArrayMapNode(ownerID, newCount, newNodes);
    };
    HashCollisionNode = function HashCollisionNode2(ownerID, keyHash, entries3) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entries = entries3;
    };
    HashCollisionNode.prototype.get = function get5(shift, keyHash, key, notSetValue) {
      var entries3 = this.entries;
      for (var ii = 0, len = entries3.length; ii < len; ii++) {
        if (is(key, entries3[ii][0])) {
          return entries3[ii][1];
        }
      }
      return notSetValue;
    };
    HashCollisionNode.prototype.update = function update5(ownerID, shift, keyHash, key, value2, didChangeSize, didAlter) {
      if (keyHash === void 0) {
        keyHash = hash(key);
      }
      var removed = value2 === NOT_SET;
      if (keyHash !== this.keyHash) {
        if (removed) {
          return this;
        }
        SetRef(didAlter);
        SetRef(didChangeSize);
        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value2]);
      }
      var entries3 = this.entries;
      var idx = 0;
      var len = entries3.length;
      for (; idx < len; idx++) {
        if (is(key, entries3[idx][0])) {
          break;
        }
      }
      var exists = idx < len;
      if (exists ? entries3[idx][1] === value2 : removed) {
        return this;
      }
      SetRef(didAlter);
      (removed || !exists) && SetRef(didChangeSize);
      if (removed && len === 2) {
        return new ValueNode(ownerID, this.keyHash, entries3[idx ^ 1]);
      }
      var isEditable = ownerID && ownerID === this.ownerID;
      var newEntries = isEditable ? entries3 : arrCopy(entries3);
      if (exists) {
        if (removed) {
          idx === len - 1 ? newEntries.pop() : newEntries[idx] = newEntries.pop();
        } else {
          newEntries[idx] = [key, value2];
        }
      } else {
        newEntries.push([key, value2]);
      }
      if (isEditable) {
        this.entries = newEntries;
        return this;
      }
      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
    };
    ValueNode = function ValueNode2(ownerID, keyHash, entry) {
      this.ownerID = ownerID;
      this.keyHash = keyHash;
      this.entry = entry;
    };
    ValueNode.prototype.get = function get6(shift, keyHash, key, notSetValue) {
      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
    };
    ValueNode.prototype.update = function update6(ownerID, shift, keyHash, key, value2, didChangeSize, didAlter) {
      var removed = value2 === NOT_SET;
      var keyMatch = is(key, this.entry[0]);
      if (keyMatch ? value2 === this.entry[1] : removed) {
        return this;
      }
      SetRef(didAlter);
      if (removed) {
        SetRef(didChangeSize);
        return;
      }
      if (keyMatch) {
        if (ownerID && ownerID === this.ownerID) {
          this.entry[1] = value2;
          return this;
        }
        return new ValueNode(ownerID, this.keyHash, [key, value2]);
      }
      SetRef(didChangeSize);
      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value2]);
    };
    ArrayMapNode.prototype.iterate = HashCollisionNode.prototype.iterate = function(fn, reverse3) {
      var entries3 = this.entries;
      for (var ii = 0, maxIndex = entries3.length - 1; ii <= maxIndex; ii++) {
        if (fn(entries3[reverse3 ? maxIndex - ii : ii]) === false) {
          return false;
        }
      }
    };
    BitmapIndexedNode.prototype.iterate = HashArrayMapNode.prototype.iterate = function(fn, reverse3) {
      var nodes = this.nodes;
      for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
        var node = nodes[reverse3 ? maxIndex - ii : ii];
        if (node && node.iterate(fn, reverse3) === false) {
          return false;
        }
      }
    };
    ValueNode.prototype.iterate = function(fn, reverse3) {
      return fn(this.entry);
    };
    MapIterator = /* @__PURE__ */ function(Iterator3) {
      function MapIterator2(map2, type, reverse3) {
        this._type = type;
        this._reverse = reverse3;
        this._stack = map2._root && mapIteratorFrame(map2._root);
      }
      if (Iterator3)
        MapIterator2.__proto__ = Iterator3;
      MapIterator2.prototype = Object.create(Iterator3 && Iterator3.prototype);
      MapIterator2.prototype.constructor = MapIterator2;
      MapIterator2.prototype.next = function next() {
        var type = this._type;
        var stack = this._stack;
        while (stack) {
          var node = stack.node;
          var index = stack.index++;
          var maxIndex = void 0;
          if (node.entry) {
            if (index === 0) {
              return mapIteratorValue(type, node.entry);
            }
          } else if (node.entries) {
            maxIndex = node.entries.length - 1;
            if (index <= maxIndex) {
              return mapIteratorValue(
                type,
                node.entries[this._reverse ? maxIndex - index : index]
              );
            }
          } else {
            maxIndex = node.nodes.length - 1;
            if (index <= maxIndex) {
              var subNode = node.nodes[this._reverse ? maxIndex - index : index];
              if (subNode) {
                if (subNode.entry) {
                  return mapIteratorValue(type, subNode.entry);
                }
                stack = this._stack = mapIteratorFrame(subNode, stack);
              }
              continue;
            }
          }
          stack = this._stack = this._stack.__prev;
        }
        return iteratorDone();
      };
      return MapIterator2;
    }(Iterator);
    MAX_ARRAY_MAP_SIZE = SIZE / 4;
    MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
    MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
    IS_LIST_SYMBOL = "@@__IMMUTABLE_LIST__@@";
    List = /* @__PURE__ */ function(IndexedCollection2) {
      function List2(value2) {
        var empty = emptyList();
        if (value2 === void 0 || value2 === null) {
          return empty;
        }
        if (isList(value2)) {
          return value2;
        }
        var iter = IndexedCollection2(value2);
        var size = iter.size;
        if (size === 0) {
          return empty;
        }
        assertNotInfinite(size);
        if (size > 0 && size < SIZE) {
          return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
        }
        return empty.withMutations(function(list) {
          list.setSize(size);
          iter.forEach(function(v, i) {
            return list.set(i, v);
          });
        });
      }
      if (IndexedCollection2)
        List2.__proto__ = IndexedCollection2;
      List2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
      List2.prototype.constructor = List2;
      List2.of = function of() {
        return this(arguments);
      };
      List2.prototype.toString = function toString5() {
        return this.__toString("List [", "]");
      };
      List2.prototype.get = function get11(index, notSetValue) {
        index = wrapIndex(this, index);
        if (index >= 0 && index < this.size) {
          index += this._origin;
          var node = listNodeFor(this, index);
          return node && node.array[index & MASK];
        }
        return notSetValue;
      };
      List2.prototype.set = function set3(index, value2) {
        return updateList(this, index, value2);
      };
      List2.prototype.remove = function remove3(index) {
        return !this.has(index) ? this : index === 0 ? this.shift() : index === this.size - 1 ? this.pop() : this.splice(index, 1);
      };
      List2.prototype.insert = function insert(index, value2) {
        return this.splice(index, 0, value2);
      };
      List2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = this._origin = this._capacity = 0;
          this._level = SHIFT;
          this._root = this._tail = this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyList();
      };
      List2.prototype.push = function push() {
        var values2 = arguments;
        var oldSize = this.size;
        return this.withMutations(function(list) {
          setListBounds(list, 0, oldSize + values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(oldSize + ii, values2[ii]);
          }
        });
      };
      List2.prototype.pop = function pop() {
        return setListBounds(this, 0, -1);
      };
      List2.prototype.unshift = function unshift() {
        var values2 = arguments;
        return this.withMutations(function(list) {
          setListBounds(list, -values2.length);
          for (var ii = 0; ii < values2.length; ii++) {
            list.set(ii, values2[ii]);
          }
        });
      };
      List2.prototype.shift = function shift() {
        return setListBounds(this, 1);
      };
      List2.prototype.concat = function concat2() {
        var arguments$1 = arguments;
        var seqs = [];
        for (var i = 0; i < arguments.length; i++) {
          var argument = arguments$1[i];
          var seq = IndexedCollection2(
            typeof argument !== "string" && hasIterator(argument) ? argument : [argument]
          );
          if (seq.size !== 0) {
            seqs.push(seq);
          }
        }
        if (seqs.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && seqs.length === 1) {
          return this.constructor(seqs[0]);
        }
        return this.withMutations(function(list) {
          seqs.forEach(function(seq2) {
            return seq2.forEach(function(value2) {
              return list.push(value2);
            });
          });
        });
      };
      List2.prototype.setSize = function setSize(size) {
        return setListBounds(this, 0, size);
      };
      List2.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        return this.withMutations(function(list) {
          for (var i = 0; i < this$1$1.size; i++) {
            list.set(i, mapper.call(context, list.get(i), i, this$1$1));
          }
        });
      };
      List2.prototype.slice = function slice3(begin, end) {
        var size = this.size;
        if (wholeSlice(begin, end, size)) {
          return this;
        }
        return setListBounds(
          this,
          resolveBegin(begin, size),
          resolveEnd(end, size)
        );
      };
      List2.prototype.__iterator = function __iterator2(type, reverse3) {
        var index = reverse3 ? this.size : 0;
        var values2 = iterateList(this, reverse3);
        return new Iterator(function() {
          var value2 = values2();
          return value2 === DONE ? iteratorDone() : iteratorValue(type, reverse3 ? --index : index++, value2);
        });
      };
      List2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var index = reverse3 ? this.size : 0;
        var values2 = iterateList(this, reverse3);
        var value2;
        while ((value2 = values2()) !== DONE) {
          if (fn(value2, reverse3 ? --index : index++, this) === false) {
            break;
          }
        }
        return index;
      };
      List2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyList();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeList(
          this._origin,
          this._capacity,
          this._level,
          this._root,
          this._tail,
          ownerID,
          this.__hash
        );
      };
      return List2;
    }(IndexedCollection);
    List.isList = isList;
    ListPrototype = List.prototype;
    ListPrototype[IS_LIST_SYMBOL] = true;
    ListPrototype[DELETE] = ListPrototype.remove;
    ListPrototype.merge = ListPrototype.concat;
    ListPrototype.setIn = setIn;
    ListPrototype.deleteIn = ListPrototype.removeIn = deleteIn;
    ListPrototype.update = update;
    ListPrototype.updateIn = updateIn;
    ListPrototype.mergeIn = mergeIn;
    ListPrototype.mergeDeepIn = mergeDeepIn;
    ListPrototype.withMutations = withMutations;
    ListPrototype.wasAltered = wasAltered;
    ListPrototype.asImmutable = asImmutable;
    ListPrototype["@@transducer/init"] = ListPrototype.asMutable = asMutable;
    ListPrototype["@@transducer/step"] = function(result, arr) {
      return result.push(arr);
    };
    ListPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    VNode = function VNode2(array, ownerID) {
      this.array = array;
      this.ownerID = ownerID;
    };
    VNode.prototype.removeBefore = function removeBefore(ownerID, level, index) {
      if (index === level ? 1 << level : this.array.length === 0) {
        return this;
      }
      var originIndex = index >>> level & MASK;
      if (originIndex >= this.array.length) {
        return new VNode([], ownerID);
      }
      var removingFirst = originIndex === 0;
      var newChild;
      if (level > 0) {
        var oldChild = this.array[originIndex];
        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
        if (newChild === oldChild && removingFirst) {
          return this;
        }
      }
      if (removingFirst && !newChild) {
        return this;
      }
      var editable = editableVNode(this, ownerID);
      if (!removingFirst) {
        for (var ii = 0; ii < originIndex; ii++) {
          editable.array[ii] = void 0;
        }
      }
      if (newChild) {
        editable.array[originIndex] = newChild;
      }
      return editable;
    };
    VNode.prototype.removeAfter = function removeAfter(ownerID, level, index) {
      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
        return this;
      }
      var sizeIndex = index - 1 >>> level & MASK;
      if (sizeIndex >= this.array.length) {
        return this;
      }
      var newChild;
      if (level > 0) {
        var oldChild = this.array[sizeIndex];
        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
          return this;
        }
      }
      var editable = editableVNode(this, ownerID);
      editable.array.splice(sizeIndex + 1);
      if (newChild) {
        editable.array[sizeIndex] = newChild;
      }
      return editable;
    };
    DONE = {};
    OrderedMap = /* @__PURE__ */ function(Map3) {
      function OrderedMap2(value2) {
        return value2 === void 0 || value2 === null ? emptyOrderedMap() : isOrderedMap(value2) ? value2 : emptyOrderedMap().withMutations(function(map2) {
          var iter = KeyedCollection(value2);
          assertNotInfinite(iter.size);
          iter.forEach(function(v, k) {
            return map2.set(k, v);
          });
        });
      }
      if (Map3)
        OrderedMap2.__proto__ = Map3;
      OrderedMap2.prototype = Object.create(Map3 && Map3.prototype);
      OrderedMap2.prototype.constructor = OrderedMap2;
      OrderedMap2.of = function of() {
        return this(arguments);
      };
      OrderedMap2.prototype.toString = function toString5() {
        return this.__toString("OrderedMap {", "}");
      };
      OrderedMap2.prototype.get = function get11(k, notSetValue) {
        var index = this._map.get(k);
        return index !== void 0 ? this._list.get(index)[1] : notSetValue;
      };
      OrderedMap2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._map.clear();
          this._list.clear();
          this.__altered = true;
          return this;
        }
        return emptyOrderedMap();
      };
      OrderedMap2.prototype.set = function set3(k, v) {
        return updateOrderedMap(this, k, v);
      };
      OrderedMap2.prototype.remove = function remove3(k) {
        return updateOrderedMap(this, k, NOT_SET);
      };
      OrderedMap2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._list.__iterate(
          function(entry) {
            return entry && fn(entry[1], entry[0], this$1$1);
          },
          reverse3
        );
      };
      OrderedMap2.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._list.fromEntrySeq().__iterator(type, reverse3);
      };
      OrderedMap2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        var newList = this._list.__ensureOwner(ownerID);
        if (!ownerID) {
          if (this.size === 0) {
            return emptyOrderedMap();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          this._map = newMap;
          this._list = newList;
          return this;
        }
        return makeOrderedMap(newMap, newList, ownerID, this.__hash);
      };
      return OrderedMap2;
    }(Map2);
    OrderedMap.isOrderedMap = isOrderedMap;
    OrderedMap.prototype[IS_ORDERED_SYMBOL] = true;
    OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
    IS_STACK_SYMBOL = "@@__IMMUTABLE_STACK__@@";
    Stack = /* @__PURE__ */ function(IndexedCollection2) {
      function Stack2(value2) {
        return value2 === void 0 || value2 === null ? emptyStack() : isStack(value2) ? value2 : emptyStack().pushAll(value2);
      }
      if (IndexedCollection2)
        Stack2.__proto__ = IndexedCollection2;
      Stack2.prototype = Object.create(IndexedCollection2 && IndexedCollection2.prototype);
      Stack2.prototype.constructor = Stack2;
      Stack2.of = function of() {
        return this(arguments);
      };
      Stack2.prototype.toString = function toString5() {
        return this.__toString("Stack [", "]");
      };
      Stack2.prototype.get = function get11(index, notSetValue) {
        var head = this._head;
        index = wrapIndex(this, index);
        while (head && index--) {
          head = head.next;
        }
        return head ? head.value : notSetValue;
      };
      Stack2.prototype.peek = function peek() {
        return this._head && this._head.value;
      };
      Stack2.prototype.push = function push() {
        var arguments$1 = arguments;
        if (arguments.length === 0) {
          return this;
        }
        var newSize = this.size + arguments.length;
        var head = this._head;
        for (var ii = arguments.length - 1; ii >= 0; ii--) {
          head = {
            value: arguments$1[ii],
            next: head
          };
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.pushAll = function pushAll(iter) {
        iter = IndexedCollection2(iter);
        if (iter.size === 0) {
          return this;
        }
        if (this.size === 0 && isStack(iter)) {
          return iter;
        }
        assertNotInfinite(iter.size);
        var newSize = this.size;
        var head = this._head;
        iter.__iterate(
          function(value2) {
            newSize++;
            head = {
              value: value2,
              next: head
            };
          },
          /* reverse */
          true
        );
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.pop = function pop() {
        return this.slice(1);
      };
      Stack2.prototype.clear = function clear2() {
        if (this.size === 0) {
          return this;
        }
        if (this.__ownerID) {
          this.size = 0;
          this._head = void 0;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return emptyStack();
      };
      Stack2.prototype.slice = function slice3(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        var resolvedBegin = resolveBegin(begin, this.size);
        var resolvedEnd = resolveEnd(end, this.size);
        if (resolvedEnd !== this.size) {
          return IndexedCollection2.prototype.slice.call(this, begin, end);
        }
        var newSize = this.size - resolvedBegin;
        var head = this._head;
        while (resolvedBegin--) {
          head = head.next;
        }
        if (this.__ownerID) {
          this.size = newSize;
          this._head = head;
          this.__hash = void 0;
          this.__altered = true;
          return this;
        }
        return makeStack(newSize, head);
      };
      Stack2.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        if (!ownerID) {
          if (this.size === 0) {
            return emptyStack();
          }
          this.__ownerID = ownerID;
          this.__altered = false;
          return this;
        }
        return makeStack(this.size, this._head, ownerID, this.__hash);
      };
      Stack2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        if (reverse3) {
          return new ArraySeq(this.toArray()).__iterate(
            function(v, k) {
              return fn(v, k, this$1$1);
            },
            reverse3
          );
        }
        var iterations = 0;
        var node = this._head;
        while (node) {
          if (fn(node.value, iterations++, this) === false) {
            break;
          }
          node = node.next;
        }
        return iterations;
      };
      Stack2.prototype.__iterator = function __iterator2(type, reverse3) {
        if (reverse3) {
          return new ArraySeq(this.toArray()).__iterator(type, reverse3);
        }
        var iterations = 0;
        var node = this._head;
        return new Iterator(function() {
          if (node) {
            var value2 = node.value;
            node = node.next;
            return iteratorValue(type, iterations++, value2);
          }
          return iteratorDone();
        });
      };
      return Stack2;
    }(IndexedCollection);
    Stack.isStack = isStack;
    StackPrototype = Stack.prototype;
    StackPrototype[IS_STACK_SYMBOL] = true;
    StackPrototype.shift = StackPrototype.pop;
    StackPrototype.unshift = StackPrototype.push;
    StackPrototype.unshiftAll = StackPrototype.pushAll;
    StackPrototype.withMutations = withMutations;
    StackPrototype.wasAltered = wasAltered;
    StackPrototype.asImmutable = asImmutable;
    StackPrototype["@@transducer/init"] = StackPrototype.asMutable = asMutable;
    StackPrototype["@@transducer/step"] = function(result, arr) {
      return result.unshift(arr);
    };
    StackPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    IS_SET_SYMBOL = "@@__IMMUTABLE_SET__@@";
    Set2 = /* @__PURE__ */ function(SetCollection2) {
      function Set3(value2) {
        return value2 === void 0 || value2 === null ? emptySet() : isSet2(value2) && !isOrdered(value2) ? value2 : emptySet().withMutations(function(set3) {
          var iter = SetCollection2(value2);
          assertNotInfinite(iter.size);
          iter.forEach(function(v) {
            return set3.add(v);
          });
        });
      }
      if (SetCollection2)
        Set3.__proto__ = SetCollection2;
      Set3.prototype = Object.create(SetCollection2 && SetCollection2.prototype);
      Set3.prototype.constructor = Set3;
      Set3.of = function of() {
        return this(arguments);
      };
      Set3.fromKeys = function fromKeys(value2) {
        return this(KeyedCollection(value2).keySeq());
      };
      Set3.intersect = function intersect(sets) {
        sets = Collection(sets).toArray();
        return sets.length ? SetPrototype.intersect.apply(Set3(sets.pop()), sets) : emptySet();
      };
      Set3.union = function union(sets) {
        sets = Collection(sets).toArray();
        return sets.length ? SetPrototype.union.apply(Set3(sets.pop()), sets) : emptySet();
      };
      Set3.prototype.toString = function toString5() {
        return this.__toString("Set {", "}");
      };
      Set3.prototype.has = function has5(value2) {
        return this._map.has(value2);
      };
      Set3.prototype.add = function add(value2) {
        return updateSet(this, this._map.set(value2, value2));
      };
      Set3.prototype.remove = function remove3(value2) {
        return updateSet(this, this._map.remove(value2));
      };
      Set3.prototype.clear = function clear2() {
        return updateSet(this, this._map.clear());
      };
      Set3.prototype.map = function map2(mapper, context) {
        var this$1$1 = this;
        var didChanges = false;
        var newMap = updateSet(
          this,
          this._map.mapEntries(function(ref) {
            var v = ref[1];
            var mapped = mapper.call(context, v, v, this$1$1);
            if (mapped !== v) {
              didChanges = true;
            }
            return [mapped, mapped];
          }, context)
        );
        return didChanges ? newMap : this;
      };
      Set3.prototype.union = function union() {
        var iters = [], len = arguments.length;
        while (len--)
          iters[len] = arguments[len];
        iters = iters.filter(function(x) {
          return x.size !== 0;
        });
        if (iters.length === 0) {
          return this;
        }
        if (this.size === 0 && !this.__ownerID && iters.length === 1) {
          return this.constructor(iters[0]);
        }
        return this.withMutations(function(set3) {
          for (var ii = 0; ii < iters.length; ii++) {
            if (typeof iters[ii] === "string") {
              set3.add(iters[ii]);
            } else {
              SetCollection2(iters[ii]).forEach(function(value2) {
                return set3.add(value2);
              });
            }
          }
        });
      };
      Set3.prototype.intersect = function intersect() {
        var iters = [], len = arguments.length;
        while (len--)
          iters[len] = arguments[len];
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetCollection2(iter);
        });
        var toRemove = [];
        this.forEach(function(value2) {
          if (!iters.every(function(iter) {
            return iter.includes(value2);
          })) {
            toRemove.push(value2);
          }
        });
        return this.withMutations(function(set3) {
          toRemove.forEach(function(value2) {
            set3.remove(value2);
          });
        });
      };
      Set3.prototype.subtract = function subtract() {
        var iters = [], len = arguments.length;
        while (len--)
          iters[len] = arguments[len];
        if (iters.length === 0) {
          return this;
        }
        iters = iters.map(function(iter) {
          return SetCollection2(iter);
        });
        var toRemove = [];
        this.forEach(function(value2) {
          if (iters.some(function(iter) {
            return iter.includes(value2);
          })) {
            toRemove.push(value2);
          }
        });
        return this.withMutations(function(set3) {
          toRemove.forEach(function(value2) {
            set3.remove(value2);
          });
        });
      };
      Set3.prototype.sort = function sort2(comparator) {
        return OrderedSet(sortFactory(this, comparator));
      };
      Set3.prototype.sortBy = function sortBy2(mapper, comparator) {
        return OrderedSet(sortFactory(this, comparator, mapper));
      };
      Set3.prototype.wasAltered = function wasAltered3() {
        return this._map.wasAltered();
      };
      Set3.prototype.__iterate = function __iterate2(fn, reverse3) {
        var this$1$1 = this;
        return this._map.__iterate(function(k) {
          return fn(k, k, this$1$1);
        }, reverse3);
      };
      Set3.prototype.__iterator = function __iterator2(type, reverse3) {
        return this._map.__iterator(type, reverse3);
      };
      Set3.prototype.__ensureOwner = function __ensureOwner2(ownerID) {
        if (ownerID === this.__ownerID) {
          return this;
        }
        var newMap = this._map.__ensureOwner(ownerID);
        if (!ownerID) {
          if (this.size === 0) {
            return this.__empty();
          }
          this.__ownerID = ownerID;
          this._map = newMap;
          return this;
        }
        return this.__make(newMap, ownerID);
      };
      return Set3;
    }(SetCollection);
    Set2.isSet = isSet2;
    SetPrototype = Set2.prototype;
    SetPrototype[IS_SET_SYMBOL] = true;
    SetPrototype[DELETE] = SetPrototype.remove;
    SetPrototype.merge = SetPrototype.concat = SetPrototype.union;
    SetPrototype.withMutations = withMutations;
    SetPrototype.asImmutable = asImmutable;
    SetPrototype["@@transducer/init"] = SetPrototype.asMutable = asMutable;
    SetPrototype["@@transducer/step"] = function(result, arr) {
      return result.add(arr);
    };
    SetPrototype["@@transducer/result"] = function(obj) {
      return obj.asImmutable();
    };
    SetPrototype.__empty = emptySet;
    SetPrototype.__make = makeSet;
    Range = /* @__PURE__ */ function(IndexedSeq2) {
      function Range2(start, end, step) {
        if (!(this instanceof Range2)) {
          return new Range2(start, end, step);
        }
        invariant(step !== 0, "Cannot step a Range by 0");
        start = start || 0;
        if (end === void 0) {
          end = Infinity;
        }
        step = step === void 0 ? 1 : Math.abs(step);
        if (end < start) {
          step = -step;
        }
        this._start = start;
        this._end = end;
        this._step = step;
        this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
        if (this.size === 0) {
          if (EMPTY_RANGE) {
            return EMPTY_RANGE;
          }
          EMPTY_RANGE = this;
        }
      }
      if (IndexedSeq2)
        Range2.__proto__ = IndexedSeq2;
      Range2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      Range2.prototype.constructor = Range2;
      Range2.prototype.toString = function toString5() {
        if (this.size === 0) {
          return "Range []";
        }
        return "Range [ " + this._start + "..." + this._end + (this._step !== 1 ? " by " + this._step : "") + " ]";
      };
      Range2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._start + wrapIndex(this, index) * this._step : notSetValue;
      };
      Range2.prototype.includes = function includes4(searchValue) {
        var possibleIndex = (searchValue - this._start) / this._step;
        return possibleIndex >= 0 && possibleIndex < this.size && possibleIndex === Math.floor(possibleIndex);
      };
      Range2.prototype.slice = function slice3(begin, end) {
        if (wholeSlice(begin, end, this.size)) {
          return this;
        }
        begin = resolveBegin(begin, this.size);
        end = resolveEnd(end, this.size);
        if (end <= begin) {
          return new Range2(0, 0);
        }
        return new Range2(
          this.get(begin, this._end),
          this.get(end, this._end),
          this._step
        );
      };
      Range2.prototype.indexOf = function indexOf2(searchValue) {
        var offsetValue = searchValue - this._start;
        if (offsetValue % this._step === 0) {
          var index = offsetValue / this._step;
          if (index >= 0 && index < this.size) {
            return index;
          }
        }
        return -1;
      };
      Range2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
        return this.indexOf(searchValue);
      };
      Range2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var size = this.size;
        var step = this._step;
        var value2 = reverse3 ? this._start + (size - 1) * step : this._start;
        var i = 0;
        while (i !== size) {
          if (fn(value2, reverse3 ? size - ++i : i++, this) === false) {
            break;
          }
          value2 += reverse3 ? -step : step;
        }
        return i;
      };
      Range2.prototype.__iterator = function __iterator2(type, reverse3) {
        var size = this.size;
        var step = this._step;
        var value2 = reverse3 ? this._start + (size - 1) * step : this._start;
        var i = 0;
        return new Iterator(function() {
          if (i === size) {
            return iteratorDone();
          }
          var v = value2;
          value2 += reverse3 ? -step : step;
          return iteratorValue(type, reverse3 ? size - ++i : i++, v);
        });
      };
      Range2.prototype.equals = function equals3(other) {
        return other instanceof Range2 ? this._start === other._start && this._end === other._end && this._step === other._step : deepEqual(this, other);
      };
      return Range2;
    }(IndexedSeq);
    Collection.isIterable = isCollection;
    Collection.isKeyed = isKeyed;
    Collection.isIndexed = isIndexed;
    Collection.isAssociative = isAssociative;
    Collection.isOrdered = isOrdered;
    Collection.Iterator = Iterator;
    mixin(Collection, {
      // ### Conversion to other types
      toArray: function toArray() {
        assertNotInfinite(this.size);
        var array = new Array(this.size || 0);
        var useTuples = isKeyed(this);
        var i = 0;
        this.__iterate(function(v, k) {
          array[i++] = useTuples ? [k, v] : v;
        });
        return array;
      },
      toIndexedSeq: function toIndexedSeq() {
        return new ToIndexedSequence(this);
      },
      toJS: function toJS$1() {
        return toJS(this);
      },
      toKeyedSeq: function toKeyedSeq() {
        return new ToKeyedSequence(this, true);
      },
      toMap: function toMap() {
        return Map2(this.toKeyedSeq());
      },
      toObject,
      toOrderedMap: function toOrderedMap() {
        return OrderedMap(this.toKeyedSeq());
      },
      toOrderedSet: function toOrderedSet() {
        return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
      },
      toSet: function toSet() {
        return Set2(isKeyed(this) ? this.valueSeq() : this);
      },
      toSetSeq: function toSetSeq() {
        return new ToSetSequence(this);
      },
      toSeq: function toSeq() {
        return isIndexed(this) ? this.toIndexedSeq() : isKeyed(this) ? this.toKeyedSeq() : this.toSetSeq();
      },
      toStack: function toStack() {
        return Stack(isKeyed(this) ? this.valueSeq() : this);
      },
      toList: function toList() {
        return List(isKeyed(this) ? this.valueSeq() : this);
      },
      // ### Common JavaScript methods and properties
      toString: function toString3() {
        return "[Collection]";
      },
      __toString: function __toString(head, tail) {
        if (this.size === 0) {
          return head + tail;
        }
        return head + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + tail;
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      concat: function concat() {
        var values2 = [], len = arguments.length;
        while (len--)
          values2[len] = arguments[len];
        return reify(this, concatFactory(this, values2));
      },
      includes: function includes2(searchValue) {
        return this.some(function(value2) {
          return is(value2, searchValue);
        });
      },
      entries: function entries() {
        return this.__iterator(ITERATE_ENTRIES);
      },
      every: function every(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = true;
        this.__iterate(function(v, k, c) {
          if (!predicate.call(context, v, k, c)) {
            returnValue = false;
            return false;
          }
        });
        return returnValue;
      },
      filter: function filter(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, true));
      },
      partition: function partition(predicate, context) {
        return partitionFactory(this, predicate, context);
      },
      find: function find2(predicate, context, notSetValue) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[1] : notSetValue;
      },
      forEach: function forEach2(sideEffect, context) {
        assertNotInfinite(this.size);
        return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
      },
      join: function join(separator) {
        assertNotInfinite(this.size);
        separator = separator !== void 0 ? "" + separator : ",";
        var joined = "";
        var isFirst = true;
        this.__iterate(function(v) {
          isFirst ? isFirst = false : joined += separator;
          joined += v !== null && v !== void 0 ? v.toString() : "";
        });
        return joined;
      },
      keys: function keys() {
        return this.__iterator(ITERATE_KEYS);
      },
      map: function map(mapper, context) {
        return reify(this, mapFactory(this, mapper, context));
      },
      reduce: function reduce$1(reducer, initialReduction, context) {
        return reduce(
          this,
          reducer,
          initialReduction,
          context,
          arguments.length < 2,
          false
        );
      },
      reduceRight: function reduceRight(reducer, initialReduction, context) {
        return reduce(
          this,
          reducer,
          initialReduction,
          context,
          arguments.length < 2,
          true
        );
      },
      reverse: function reverse() {
        return reify(this, reverseFactory(this, true));
      },
      slice: function slice(begin, end) {
        return reify(this, sliceFactory(this, begin, end, true));
      },
      some: function some(predicate, context) {
        assertNotInfinite(this.size);
        var returnValue = false;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            returnValue = true;
            return false;
          }
        });
        return returnValue;
      },
      sort: function sort(comparator) {
        return reify(this, sortFactory(this, comparator));
      },
      values: function values() {
        return this.__iterator(ITERATE_VALUES);
      },
      // ### More sequential methods
      butLast: function butLast() {
        return this.slice(0, -1);
      },
      isEmpty: function isEmpty() {
        return this.size !== void 0 ? this.size === 0 : !this.some(function() {
          return true;
        });
      },
      count: function count(predicate, context) {
        return ensureSize(
          predicate ? this.toSeq().filter(predicate, context) : this
        );
      },
      countBy: function countBy(grouper, context) {
        return countByFactory(this, grouper, context);
      },
      equals: function equals(other) {
        return deepEqual(this, other);
      },
      entrySeq: function entrySeq() {
        var collection = this;
        if (collection._cache) {
          return new ArraySeq(collection._cache);
        }
        var entriesSequence = collection.toSeq().map(entryMapper).toIndexedSeq();
        entriesSequence.fromEntrySeq = function() {
          return collection.toSeq();
        };
        return entriesSequence;
      },
      filterNot: function filterNot(predicate, context) {
        return this.filter(not(predicate), context);
      },
      findEntry: function findEntry(predicate, context, notSetValue) {
        var found = notSetValue;
        this.__iterate(function(v, k, c) {
          if (predicate.call(context, v, k, c)) {
            found = [k, v];
            return false;
          }
        });
        return found;
      },
      findKey: function findKey(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry && entry[0];
      },
      findLast: function findLast(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
      },
      findLastEntry: function findLastEntry(predicate, context, notSetValue) {
        return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);
      },
      findLastKey: function findLastKey(predicate, context) {
        return this.toKeyedSeq().reverse().findKey(predicate, context);
      },
      first: function first(notSetValue) {
        return this.find(returnTrue, null, notSetValue);
      },
      flatMap: function flatMap(mapper, context) {
        return reify(this, flatMapFactory(this, mapper, context));
      },
      flatten: function flatten(depth) {
        return reify(this, flattenFactory(this, depth, true));
      },
      fromEntrySeq: function fromEntrySeq() {
        return new FromEntriesSequence(this);
      },
      get: function get7(searchKey, notSetValue) {
        return this.find(function(_, key) {
          return is(key, searchKey);
        }, void 0, notSetValue);
      },
      getIn,
      groupBy: function groupBy(grouper, context) {
        return groupByFactory(this, grouper, context);
      },
      has: function has2(searchKey) {
        return this.get(searchKey, NOT_SET) !== NOT_SET;
      },
      hasIn,
      isSubset: function isSubset(iter) {
        iter = typeof iter.includes === "function" ? iter : Collection(iter);
        return this.every(function(value2) {
          return iter.includes(value2);
        });
      },
      isSuperset: function isSuperset(iter) {
        iter = typeof iter.isSubset === "function" ? iter : Collection(iter);
        return iter.isSubset(this);
      },
      keyOf: function keyOf(searchValue) {
        return this.findKey(function(value2) {
          return is(value2, searchValue);
        });
      },
      keySeq: function keySeq() {
        return this.toSeq().map(keyMapper).toIndexedSeq();
      },
      last: function last(notSetValue) {
        return this.toSeq().reverse().first(notSetValue);
      },
      lastKeyOf: function lastKeyOf(searchValue) {
        return this.toKeyedSeq().reverse().keyOf(searchValue);
      },
      max: function max(comparator) {
        return maxFactory(this, comparator);
      },
      maxBy: function maxBy(mapper, comparator) {
        return maxFactory(this, comparator, mapper);
      },
      min: function min(comparator) {
        return maxFactory(
          this,
          comparator ? neg2(comparator) : defaultNegComparator
        );
      },
      minBy: function minBy(mapper, comparator) {
        return maxFactory(
          this,
          comparator ? neg2(comparator) : defaultNegComparator,
          mapper
        );
      },
      rest: function rest() {
        return this.slice(1);
      },
      skip: function skip(amount) {
        return amount === 0 ? this : this.slice(Math.max(0, amount));
      },
      skipLast: function skipLast(amount) {
        return amount === 0 ? this : this.slice(0, -Math.max(0, amount));
      },
      skipWhile: function skipWhile(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, true));
      },
      skipUntil: function skipUntil(predicate, context) {
        return this.skipWhile(not(predicate), context);
      },
      sortBy: function sortBy(mapper, comparator) {
        return reify(this, sortFactory(this, comparator, mapper));
      },
      take: function take(amount) {
        return this.slice(0, Math.max(0, amount));
      },
      takeLast: function takeLast(amount) {
        return this.slice(-Math.max(0, amount));
      },
      takeWhile: function takeWhile(predicate, context) {
        return reify(this, takeWhileFactory(this, predicate, context));
      },
      takeUntil: function takeUntil(predicate, context) {
        return this.takeWhile(not(predicate), context);
      },
      update: function update7(fn) {
        return fn(this);
      },
      valueSeq: function valueSeq() {
        return this.toIndexedSeq();
      },
      // ### Hashable Object
      hashCode: function hashCode() {
        return this.__hash || (this.__hash = hashCollection(this));
      }
      // ### Internal
      // abstract __iterate(fn, reverse)
      // abstract __iterator(type, reverse)
    });
    CollectionPrototype = Collection.prototype;
    CollectionPrototype[IS_COLLECTION_SYMBOL] = true;
    CollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.values;
    CollectionPrototype.toJSON = CollectionPrototype.toArray;
    CollectionPrototype.__toStringMapper = quoteString;
    CollectionPrototype.inspect = CollectionPrototype.toSource = function() {
      return this.toString();
    };
    CollectionPrototype.chain = CollectionPrototype.flatMap;
    CollectionPrototype.contains = CollectionPrototype.includes;
    mixin(KeyedCollection, {
      // ### More sequential methods
      flip: function flip() {
        return reify(this, flipFactory(this));
      },
      mapEntries: function mapEntries(mapper, context) {
        var this$1$1 = this;
        var iterations = 0;
        return reify(
          this,
          this.toSeq().map(function(v, k) {
            return mapper.call(context, [k, v], iterations++, this$1$1);
          }).fromEntrySeq()
        );
      },
      mapKeys: function mapKeys(mapper, context) {
        var this$1$1 = this;
        return reify(
          this,
          this.toSeq().flip().map(function(k, v) {
            return mapper.call(context, k, v, this$1$1);
          }).flip()
        );
      }
    });
    KeyedCollectionPrototype = KeyedCollection.prototype;
    KeyedCollectionPrototype[IS_KEYED_SYMBOL] = true;
    KeyedCollectionPrototype[ITERATOR_SYMBOL] = CollectionPrototype.entries;
    KeyedCollectionPrototype.toJSON = toObject;
    KeyedCollectionPrototype.__toStringMapper = function(v, k) {
      return quoteString(k) + ": " + quoteString(v);
    };
    mixin(IndexedCollection, {
      // ### Conversion to other types
      toKeyedSeq: function toKeyedSeq2() {
        return new ToKeyedSequence(this, false);
      },
      // ### ES6 Collection methods (ES6 Array and Map)
      filter: function filter2(predicate, context) {
        return reify(this, filterFactory(this, predicate, context, false));
      },
      findIndex: function findIndex(predicate, context) {
        var entry = this.findEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      indexOf: function indexOf(searchValue) {
        var key = this.keyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      lastIndexOf: function lastIndexOf(searchValue) {
        var key = this.lastKeyOf(searchValue);
        return key === void 0 ? -1 : key;
      },
      reverse: function reverse2() {
        return reify(this, reverseFactory(this, false));
      },
      slice: function slice2(begin, end) {
        return reify(this, sliceFactory(this, begin, end, false));
      },
      splice: function splice(index, removeNum) {
        var numArgs = arguments.length;
        removeNum = Math.max(removeNum || 0, 0);
        if (numArgs === 0 || numArgs === 2 && !removeNum) {
          return this;
        }
        index = resolveBegin(index, index < 0 ? this.count() : this.size);
        var spliced = this.slice(0, index);
        return reify(
          this,
          numArgs === 1 ? spliced : spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
        );
      },
      // ### More collection methods
      findLastIndex: function findLastIndex(predicate, context) {
        var entry = this.findLastEntry(predicate, context);
        return entry ? entry[0] : -1;
      },
      first: function first2(notSetValue) {
        return this.get(0, notSetValue);
      },
      flatten: function flatten2(depth) {
        return reify(this, flattenFactory(this, depth, false));
      },
      get: function get8(index, notSetValue) {
        index = wrapIndex(this, index);
        return index < 0 || this.size === Infinity || this.size !== void 0 && index > this.size ? notSetValue : this.find(function(_, key) {
          return key === index;
        }, void 0, notSetValue);
      },
      has: function has3(index) {
        index = wrapIndex(this, index);
        return index >= 0 && (this.size !== void 0 ? this.size === Infinity || index < this.size : this.indexOf(index) !== -1);
      },
      interpose: function interpose(separator) {
        return reify(this, interposeFactory(this, separator));
      },
      interleave: function interleave() {
        var collections = [this].concat(arrCopy(arguments));
        var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, collections);
        var interleaved = zipped.flatten(true);
        if (zipped.size) {
          interleaved.size = zipped.size * collections.length;
        }
        return reify(this, interleaved);
      },
      keySeq: function keySeq2() {
        return Range(0, this.size);
      },
      last: function last2(notSetValue) {
        return this.get(-1, notSetValue);
      },
      skipWhile: function skipWhile2(predicate, context) {
        return reify(this, skipWhileFactory(this, predicate, context, false));
      },
      zip: function zip() {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections));
      },
      zipAll: function zipAll() {
        var collections = [this].concat(arrCopy(arguments));
        return reify(this, zipWithFactory(this, defaultZipper, collections, true));
      },
      zipWith: function zipWith(zipper) {
        var collections = arrCopy(arguments);
        collections[0] = this;
        return reify(this, zipWithFactory(this, zipper, collections));
      }
    });
    IndexedCollectionPrototype = IndexedCollection.prototype;
    IndexedCollectionPrototype[IS_INDEXED_SYMBOL] = true;
    IndexedCollectionPrototype[IS_ORDERED_SYMBOL] = true;
    mixin(SetCollection, {
      // ### ES6 Collection methods (ES6 Array and Map)
      get: function get9(value2, notSetValue) {
        return this.has(value2) ? value2 : notSetValue;
      },
      includes: function includes3(value2) {
        return this.has(value2);
      },
      // ### More sequential methods
      keySeq: function keySeq3() {
        return this.valueSeq();
      }
    });
    SetCollectionPrototype = SetCollection.prototype;
    SetCollectionPrototype.has = CollectionPrototype.includes;
    SetCollectionPrototype.contains = SetCollectionPrototype.includes;
    SetCollectionPrototype.keys = SetCollectionPrototype.values;
    mixin(KeyedSeq, KeyedCollectionPrototype);
    mixin(IndexedSeq, IndexedCollectionPrototype);
    mixin(SetSeq, SetCollectionPrototype);
    OrderedSet = /* @__PURE__ */ function(Set3) {
      function OrderedSet2(value2) {
        return value2 === void 0 || value2 === null ? emptyOrderedSet() : isOrderedSet(value2) ? value2 : emptyOrderedSet().withMutations(function(set3) {
          var iter = SetCollection(value2);
          assertNotInfinite(iter.size);
          iter.forEach(function(v) {
            return set3.add(v);
          });
        });
      }
      if (Set3)
        OrderedSet2.__proto__ = Set3;
      OrderedSet2.prototype = Object.create(Set3 && Set3.prototype);
      OrderedSet2.prototype.constructor = OrderedSet2;
      OrderedSet2.of = function of() {
        return this(arguments);
      };
      OrderedSet2.fromKeys = function fromKeys(value2) {
        return this(KeyedCollection(value2).keySeq());
      };
      OrderedSet2.prototype.toString = function toString5() {
        return this.__toString("OrderedSet {", "}");
      };
      return OrderedSet2;
    }(Set2);
    OrderedSet.isOrderedSet = isOrderedSet;
    OrderedSetPrototype = OrderedSet.prototype;
    OrderedSetPrototype[IS_ORDERED_SYMBOL] = true;
    OrderedSetPrototype.zip = IndexedCollectionPrototype.zip;
    OrderedSetPrototype.zipWith = IndexedCollectionPrototype.zipWith;
    OrderedSetPrototype.zipAll = IndexedCollectionPrototype.zipAll;
    OrderedSetPrototype.__empty = emptyOrderedSet;
    OrderedSetPrototype.__make = makeOrderedSet;
    PairSorting = {
      LeftThenRight: -1,
      RightThenLeft: 1
    };
    Record = function Record2(defaultValues, name) {
      var hasInitialized;
      throwOnInvalidDefaultValues(defaultValues);
      var RecordType = function Record3(values2) {
        var this$1$1 = this;
        if (values2 instanceof RecordType) {
          return values2;
        }
        if (!(this instanceof RecordType)) {
          return new RecordType(values2);
        }
        if (!hasInitialized) {
          hasInitialized = true;
          var keys2 = Object.keys(defaultValues);
          var indices = RecordTypePrototype._indices = {};
          RecordTypePrototype._name = name;
          RecordTypePrototype._keys = keys2;
          RecordTypePrototype._defaultValues = defaultValues;
          for (var i = 0; i < keys2.length; i++) {
            var propName = keys2[i];
            indices[propName] = i;
            if (RecordTypePrototype[propName]) {
              typeof console === "object" && console.warn && console.warn(
                "Cannot define " + recordName(this) + ' with property "' + propName + '" since that property name is part of the Record API.'
              );
            } else {
              setProp(RecordTypePrototype, propName);
            }
          }
        }
        this.__ownerID = void 0;
        this._values = List().withMutations(function(l) {
          l.setSize(this$1$1._keys.length);
          KeyedCollection(values2).forEach(function(v, k) {
            l.set(this$1$1._indices[k], v === this$1$1._defaultValues[k] ? void 0 : v);
          });
        });
        return this;
      };
      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
      RecordTypePrototype.constructor = RecordType;
      if (name) {
        RecordType.displayName = name;
      }
      return RecordType;
    };
    Record.prototype.toString = function toString4() {
      var str = recordName(this) + " { ";
      var keys2 = this._keys;
      var k;
      for (var i = 0, l = keys2.length; i !== l; i++) {
        k = keys2[i];
        str += (i ? ", " : "") + k + ": " + quoteString(this.get(k));
      }
      return str + " }";
    };
    Record.prototype.equals = function equals2(other) {
      return this === other || isRecord(other) && recordSeq(this).equals(recordSeq(other));
    };
    Record.prototype.hashCode = function hashCode2() {
      return recordSeq(this).hashCode();
    };
    Record.prototype.has = function has4(k) {
      return this._indices.hasOwnProperty(k);
    };
    Record.prototype.get = function get10(k, notSetValue) {
      if (!this.has(k)) {
        return notSetValue;
      }
      var index = this._indices[k];
      var value2 = this._values.get(index);
      return value2 === void 0 ? this._defaultValues[k] : value2;
    };
    Record.prototype.set = function set2(k, v) {
      if (this.has(k)) {
        var newValues = this._values.set(
          this._indices[k],
          v === this._defaultValues[k] ? void 0 : v
        );
        if (newValues !== this._values && !this.__ownerID) {
          return makeRecord(this, newValues);
        }
      }
      return this;
    };
    Record.prototype.remove = function remove2(k) {
      return this.set(k);
    };
    Record.prototype.clear = function clear() {
      var newValues = this._values.clear().setSize(this._keys.length);
      return this.__ownerID ? this : makeRecord(this, newValues);
    };
    Record.prototype.wasAltered = function wasAltered2() {
      return this._values.wasAltered();
    };
    Record.prototype.toSeq = function toSeq2() {
      return recordSeq(this);
    };
    Record.prototype.toJS = function toJS$12() {
      return toJS(this);
    };
    Record.prototype.entries = function entries2() {
      return this.__iterator(ITERATE_ENTRIES);
    };
    Record.prototype.__iterator = function __iterator(type, reverse3) {
      return recordSeq(this).__iterator(type, reverse3);
    };
    Record.prototype.__iterate = function __iterate(fn, reverse3) {
      return recordSeq(this).__iterate(fn, reverse3);
    };
    Record.prototype.__ensureOwner = function __ensureOwner(ownerID) {
      if (ownerID === this.__ownerID) {
        return this;
      }
      var newValues = this._values.__ensureOwner(ownerID);
      if (!ownerID) {
        this.__ownerID = ownerID;
        this._values = newValues;
        return this;
      }
      return makeRecord(this, newValues, ownerID);
    };
    Record.isRecord = isRecord;
    Record.getDescriptiveName = recordName;
    RecordPrototype = Record.prototype;
    RecordPrototype[IS_RECORD_SYMBOL] = true;
    RecordPrototype[DELETE] = RecordPrototype.remove;
    RecordPrototype.deleteIn = RecordPrototype.removeIn = deleteIn;
    RecordPrototype.getIn = getIn;
    RecordPrototype.hasIn = CollectionPrototype.hasIn;
    RecordPrototype.merge = merge$1;
    RecordPrototype.mergeWith = mergeWith$1;
    RecordPrototype.mergeIn = mergeIn;
    RecordPrototype.mergeDeep = mergeDeep;
    RecordPrototype.mergeDeepWith = mergeDeepWith;
    RecordPrototype.mergeDeepIn = mergeDeepIn;
    RecordPrototype.setIn = setIn;
    RecordPrototype.update = update;
    RecordPrototype.updateIn = updateIn;
    RecordPrototype.withMutations = withMutations;
    RecordPrototype.asMutable = asMutable;
    RecordPrototype.asImmutable = asImmutable;
    RecordPrototype[ITERATOR_SYMBOL] = RecordPrototype.entries;
    RecordPrototype.toJSON = RecordPrototype.toObject = CollectionPrototype.toObject;
    RecordPrototype.inspect = RecordPrototype.toSource = function() {
      return this.toString();
    };
    Repeat = /* @__PURE__ */ function(IndexedSeq2) {
      function Repeat2(value2, times) {
        if (!(this instanceof Repeat2)) {
          return new Repeat2(value2, times);
        }
        this._value = value2;
        this.size = times === void 0 ? Infinity : Math.max(0, times);
        if (this.size === 0) {
          if (EMPTY_REPEAT) {
            return EMPTY_REPEAT;
          }
          EMPTY_REPEAT = this;
        }
      }
      if (IndexedSeq2)
        Repeat2.__proto__ = IndexedSeq2;
      Repeat2.prototype = Object.create(IndexedSeq2 && IndexedSeq2.prototype);
      Repeat2.prototype.constructor = Repeat2;
      Repeat2.prototype.toString = function toString5() {
        if (this.size === 0) {
          return "Repeat []";
        }
        return "Repeat [ " + this._value + " " + this.size + " times ]";
      };
      Repeat2.prototype.get = function get11(index, notSetValue) {
        return this.has(index) ? this._value : notSetValue;
      };
      Repeat2.prototype.includes = function includes4(searchValue) {
        return is(this._value, searchValue);
      };
      Repeat2.prototype.slice = function slice3(begin, end) {
        var size = this.size;
        return wholeSlice(begin, end, size) ? this : new Repeat2(
          this._value,
          resolveEnd(end, size) - resolveBegin(begin, size)
        );
      };
      Repeat2.prototype.reverse = function reverse3() {
        return this;
      };
      Repeat2.prototype.indexOf = function indexOf2(searchValue) {
        if (is(this._value, searchValue)) {
          return 0;
        }
        return -1;
      };
      Repeat2.prototype.lastIndexOf = function lastIndexOf2(searchValue) {
        if (is(this._value, searchValue)) {
          return this.size;
        }
        return -1;
      };
      Repeat2.prototype.__iterate = function __iterate2(fn, reverse3) {
        var size = this.size;
        var i = 0;
        while (i !== size) {
          if (fn(this._value, reverse3 ? size - ++i : i++, this) === false) {
            break;
          }
        }
        return i;
      };
      Repeat2.prototype.__iterator = function __iterator2(type, reverse3) {
        var this$1$1 = this;
        var size = this.size;
        var i = 0;
        return new Iterator(
          function() {
            return i === size ? iteratorDone() : iteratorValue(type, reverse3 ? size - ++i : i++, this$1$1._value);
          }
        );
      };
      Repeat2.prototype.equals = function equals3(other) {
        return other instanceof Repeat2 ? is(this._value, other._value) : deepEqual(other);
      };
      return Repeat2;
    }(IndexedSeq);
    version = "4.3.4";
    Immutable = {
      version,
      Collection,
      // Note: Iterable is deprecated
      Iterable: Collection,
      Seq,
      Map: Map2,
      OrderedMap,
      List,
      Stack,
      Set: Set2,
      OrderedSet,
      PairSorting,
      Record,
      Range,
      Repeat,
      is,
      fromJS,
      hash,
      isImmutable,
      isCollection,
      isKeyed,
      isIndexed,
      isAssociative,
      isOrdered,
      isValueObject,
      isPlainObject: isPlainObject3,
      isSeq,
      isList,
      isMap: isMap2,
      isOrderedMap,
      isStack,
      isSet: isSet2,
      isOrderedSet,
      isRecord,
      get,
      getIn: getIn$1,
      has,
      hasIn: hasIn$1,
      merge,
      mergeDeep: mergeDeep$1,
      mergeWith,
      mergeDeepWith: mergeDeepWith$1,
      remove,
      removeIn,
      set,
      setIn: setIn$1,
      update: update$1,
      updateIn: updateIn$1
    };
    Iterable = Collection;
    immutable_es_default = Immutable;
  }
});

// ../node_modules/moment/moment.js
var require_moment = __commonJS({
  "../node_modules/moment/moment.js"(exports, module2) {
    "use strict";
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray3(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined3(input) {
        return input === void 0;
      }
      function isNumber2(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate2(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i, arrLen = arr.length;
        for (i = 0; i < arrLen; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some2;
      if (Array.prototype.some) {
        some2 = Array.prototype.some;
      } else {
        some2 = function(fun) {
          var t2 = Object(this), len = t2.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t2 && fun.call(this, t2[i], i, t2)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some2.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val, momentPropertiesLen = momentProperties.length;
        if (!isUndefined3(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined3(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined3(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined3(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined3(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined3(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined3(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined3(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined3(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined3(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentPropertiesLen > 0) {
          for (i = 0; i < momentPropertiesLen; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined3(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config2) {
        copyConfig(this, config2);
        this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = /* @__PURE__ */ new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key, argLen = arguments.length;
            for (i = 0; i < argLen; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set3(config2) {
        var prop, i;
        for (i in config2) {
          if (hasOwnProp(config2, i)) {
            prop = config2[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config2;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config2) {
        if (config2 != null) {
          this.set(config2);
        }
      }
      var keys2;
      if (Object.keys) {
        keys2 = Object.keys;
      } else {
        keys2 = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value2 = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value2 = absFloor(coercedNumber);
        }
        return value2;
      }
      function makeGetSet(unit, keepTime) {
        return function(value2) {
          if (value2 != null) {
            set$1(this, unit, value2);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get11(this, unit);
          }
        };
      }
      function get11(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value2) {
        if (mom.isValid() && !isNaN(value2)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value2 = toInt(value2);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value2,
              mom.month(),
              daysInMonth(value2, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value2);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value2) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;
          for (i = 0; i < prioritizedLen; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value2);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config2) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config2._strict, config2._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(
            /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
            function(matched, p1, p2, p3, p4) {
              return p1 || p2 || p3 || p4;
            }
          )
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback, tokenLen;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber2(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        tokenLen = token2.length;
        for (i = 0; i < tokenLen; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config2, token3) {
          config2._w = config2._w || {};
          callback(input, config2._w, config2, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config2) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config2._a, config2, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf2;
      if (Array.prototype.indexOf) {
        indexOf2 = Array.prototype.indexOf;
      } else {
        indexOf2 = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config2, token2) {
        var month = config2._locale.monthsParse(input, token2, config2._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config2).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray3(this._months) ? this._months : this._months["standalone"];
        }
        return isArray3(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray3(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray3(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf2.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf2.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value2) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value2 === "string") {
          if (/^\d+$/.test(value2)) {
            value2 = toInt(value2);
          } else {
            value2 = mom.localeData().monthsParse(value2);
            if (!isNumber2(value2)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value2));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value2, dayOfMonth);
        return mom;
      }
      function getSetMonth(value2) {
        if (value2 != null) {
          setMonth(this, value2);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get11(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M2, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M2, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M2, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(
        ["w", "ww", "W", "WW"],
        function(input, week, config2, token2) {
          week[token2.substr(0, 1)] = toInt(input);
        }
      );
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
        var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config2).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray3(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf2.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf2.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf2.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf2.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config2) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config2) {
        config2._isPm = config2._locale.isPM(input);
        config2._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config2) {
        array[HOUR] = toInt(input);
        getParsingFlags(config2).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config2) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config2).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config2) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config2).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config2) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config2) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours3, minutes3, isLower) {
        if (hours3 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function isLocaleNameSane(name) {
        return name.match("^[^/\\\\]*$") != null;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports && isLocaleNameSane(name)) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values2) {
        var data;
        if (key) {
          if (isUndefined3(values2)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values2);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config2) {
        if (config2 !== null) {
          var locale2, parentConfig = baseConfig;
          config2.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config2.parentLocale != null) {
            if (locales[config2.parentLocale] != null) {
              parentConfig = locales[config2.parentLocale]._config;
            } else {
              locale2 = loadLocale(config2.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config2.parentLocale]) {
                  localeFamilies[config2.parentLocale] = [];
                }
                localeFamilies[config2.parentLocale].push({
                  name,
                  config: config2
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config2));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config2) {
        if (config2 != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config2));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config2 = mergeConfigs(parentConfig, config2);
            if (tmpLocale == null) {
              config2.abbr = name;
            }
            locale2 = new Locale(config2);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray3(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys2(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config2) {
        var i, l, string2 = config2._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
        if (match) {
          getParsingFlags(config2).iso = true;
          for (i = 0, l = isoDatesLen; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config2._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimesLen; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config2._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config2._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config2._isValid = false;
              return;
            }
          }
          config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config2);
        } else {
          config2._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config2) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config2).weekdayMismatch = true;
            config2._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config2) {
        var match = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config2)) {
            return;
          }
          config2._a = parsedArray;
          config2._tzm = calculateOffset(match[8], match[9], match[10]);
          config2._d = createUTCDate.apply(null, config2._a);
          config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
          getParsingFlags(config2).rfc2822 = true;
        } else {
          config2._isValid = false;
        }
      }
      function configFromString(config2) {
        var matched = aspNetJsonRegex.exec(config2._i);
        if (matched !== null) {
          config2._d = /* @__PURE__ */ new Date(+matched[1]);
          return;
        }
        configFromISO(config2);
        if (config2._isValid === false) {
          delete config2._isValid;
        } else {
          return;
        }
        configFromRFC2822(config2);
        if (config2._isValid === false) {
          delete config2._isValid;
        } else {
          return;
        }
        if (config2._strict) {
          config2._isValid = false;
        } else {
          hooks.createFromInputFallback(config2);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config2) {
          config2._d = /* @__PURE__ */ new Date(config2._i + (config2._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config2) {
        var nowValue = new Date(hooks.now());
        if (config2._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config2) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config2._d) {
          return;
        }
        currentDate = currentDateArray(config2);
        if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config2);
        }
        if (config2._dayOfYear != null) {
          yearToUse = defaults(config2._a[YEAR], currentDate[YEAR]);
          if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
            getParsingFlags(config2)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config2._dayOfYear);
          config2._a[MONTH] = date.getUTCMonth();
          config2._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config2._a[i] == null; ++i) {
          config2._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config2._a[i] = input[i] = config2._a[i] == null ? i === 2 ? 1 : 0 : config2._a[i];
        }
        if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
          config2._nextDay = true;
          config2._a[HOUR] = 0;
        }
        config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
        if (config2._tzm != null) {
          config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
        }
        if (config2._nextDay) {
          config2._a[HOUR] = 24;
        }
        if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
          getParsingFlags(config2).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config2) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config2._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config2._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config2._locale._week.dow;
          doy = config2._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config2._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config2)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config2)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config2._a[YEAR] = temp.year;
          config2._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config2) {
        if (config2._f === hooks.ISO_8601) {
          configFromISO(config2);
          return;
        }
        if (config2._f === hooks.RFC_2822) {
          configFromRFC2822(config2);
          return;
        }
        config2._a = [];
        getParsingFlags(config2).empty = true;
        var string2 = "" + config2._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
        tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
        tokenLen = tokens2.length;
        for (i = 0; i < tokenLen; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config2).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config2).empty = false;
            } else {
              getParsingFlags(config2).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config2);
          } else if (config2._strict && !parsedInput) {
            getParsingFlags(config2).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config2).unusedInput.push(string2);
        }
        if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
          getParsingFlags(config2).bigHour = void 0;
        }
        getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
        getParsingFlags(config2).meridiem = config2._meridiem;
        config2._a[HOUR] = meridiemFixWrap(
          config2._locale,
          config2._a[HOUR],
          config2._meridiem
        );
        era = getParsingFlags(config2).era;
        if (era !== null) {
          config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
        }
        configFromArray(config2);
        checkOverflow(config2);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config2) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
        if (configfLen === 0) {
          getParsingFlags(config2).invalidFormat = true;
          config2._d = /* @__PURE__ */ new Date(NaN);
          return;
        }
        for (i = 0; i < configfLen; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config2);
          if (config2._useUTC != null) {
            tempConfig._useUTC = config2._useUTC;
          }
          tempConfig._f = config2._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config2, bestMoment || tempConfig);
      }
      function configFromObject(config2) {
        if (config2._d) {
          return;
        }
        var i = normalizeObjectUnits(config2._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config2._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config2);
      }
      function createFromConfig(config2) {
        var res = new Moment(checkOverflow(prepareConfig(config2)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config2) {
        var input = config2._i, format2 = config2._f;
        config2._locale = config2._locale || getLocale(config2._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config2._i = input = config2._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate2(input)) {
          config2._d = input;
        } else if (isArray3(format2)) {
          configFromStringAndArray(config2);
        } else if (format2) {
          configFromStringAndFormat(config2);
        } else {
          configFromInput(config2);
        }
        if (!isValid(config2)) {
          config2._d = null;
        }
        return config2;
      }
      function configFromInput(config2) {
        var input = config2._i;
        if (isUndefined3(input)) {
          config2._d = new Date(hooks.now());
        } else if (isDate2(input)) {
          config2._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config2);
        } else if (isArray3(input)) {
          config2._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config2);
        } else if (isObject(input)) {
          configFromObject(config2);
        } else if (isNumber2(input)) {
          config2._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config2);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray3(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray3(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min2() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max2() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i, orderLen = ordering.length;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf2.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < orderLen; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years3 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months3 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days3 = normalizedInput.day || 0, hours3 = normalizedInput.hour || 0, minutes3 = normalizedInput.minute || 0, seconds3 = normalizedInput.second || 0, milliseconds3 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds3 + seconds3 * 1e3 + // 1000
        minutes3 * 6e4 + // 1000 * 60
        hours3 * 1e3 * 60 * 60;
        this._days = +days3 + weeks2 * 7;
        this._months = +months3 + quarters * 3 + years3 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config2) {
        config2._useUTC = true;
        config2._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes3;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes3 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes3 === 0 ? 0 : parts[0] === "+" ? minutes3 : -minutes3;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined3(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber2(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds3 = duration._milliseconds, days3 = absRound(duration._days), months3 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months3) {
          setMonth(mom, get11(mom, "Month") + months3 * isAdding);
        }
        if (days3) {
          set$1(mom, "Date", get11(mom, "Date") + days3 * isAdding);
        }
        if (milliseconds3) {
          mom._d.setTime(mom._d.valueOf() + milliseconds3 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days3 || months3);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString2(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate2(input) || isString2(input) || isNumber2(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property, propertyLen = properties.length;
        for (i = 0; i < propertyLen; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray3(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber2(item) && isString2(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString5() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf2() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray2() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject2() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(
        ["N", "NN", "NNN", "NNNN", "NNNNN"],
        function(input, array, config2, token2) {
          var era = config2._locale.erasParse(input, token2, config2._strict);
          if (era) {
            getParsingFlags(config2).era = era;
          } else {
            getParsingFlags(config2).invalidEra = input;
          }
        }
      );
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config2, token2) {
        var match;
        if (config2._locale._eraYearOrdinalRegex) {
          match = input.match(config2._locale._eraYearOrdinalRegex);
        }
        if (config2._locale.eraYearOrdinalParse) {
          array[YEAR] = config2._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(
        ["gggg", "ggggg", "GGGG", "GGGGG"],
        function(input, week, config2, token2) {
          week[token2.substr(0, 2)] = toInt(input);
        }
      );
      addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config2) {
        config2._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray2;
      proto.toObject = toObject2;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString5;
      proto.unix = unix;
      proto.valueOf = valueOf2;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set3;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber2(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber2(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value2, direction) {
        var other = createDuration(input, value2);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value2) {
        return addSubtract$1(this, input, value2, 1);
      }
      function subtract$1(input, value2) {
        return addSubtract$1(this, input, value2, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds3 = this._milliseconds, days3 = this._days, months3 = this._months, data = this._data, seconds3, minutes3, hours3, years3, monthsFromDays;
        if (!(milliseconds3 >= 0 && days3 >= 0 && months3 >= 0 || milliseconds3 <= 0 && days3 <= 0 && months3 <= 0)) {
          milliseconds3 += absCeil(monthsToDays(months3) + days3) * 864e5;
          days3 = 0;
          months3 = 0;
        }
        data.milliseconds = milliseconds3 % 1e3;
        seconds3 = absFloor(milliseconds3 / 1e3);
        data.seconds = seconds3 % 60;
        minutes3 = absFloor(seconds3 / 60);
        data.minutes = minutes3 % 60;
        hours3 = absFloor(minutes3 / 60);
        data.hours = hours3 % 24;
        days3 += absFloor(hours3 / 24);
        monthsFromDays = absFloor(daysToMonths(days3));
        months3 += monthsFromDays;
        days3 -= absCeil(monthsToDays(monthsFromDays));
        years3 = absFloor(months3 / 12);
        months3 %= 12;
        data.days = days3;
        data.months = months3;
        data.years = years3;
        return this;
      }
      function daysToMonths(days3) {
        return days3 * 4800 / 146097;
      }
      function monthsToDays(months3) {
        return months3 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days3, months3, milliseconds3 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days3 = this._days + milliseconds3 / 864e5;
          months3 = this._months + daysToMonths(days3);
          switch (units) {
            case "month":
              return months3;
            case "quarter":
              return months3 / 3;
            case "year":
              return months3 / 12;
          }
        } else {
          days3 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days3 / 7 + milliseconds3 / 6048e5;
            case "day":
              return days3 + milliseconds3 / 864e5;
            case "hour":
              return days3 * 24 + milliseconds3 / 36e5;
            case "minute":
              return days3 * 1440 + milliseconds3 / 6e4;
            case "second":
              return days3 * 86400 + milliseconds3 / 1e3;
            case "millisecond":
              return Math.floor(days3 * 864e5) + milliseconds3;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds2 = makeGetter("milliseconds"), seconds2 = makeGetter("seconds"), minutes2 = makeGetter("minutes"), hours2 = makeGetter("hours"), days2 = makeGetter("days"), months2 = makeGetter("months"), years2 = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds3 = round(duration.as("s")), minutes3 = round(duration.as("m")), hours3 = round(duration.as("h")), days3 = round(duration.as("d")), months3 = round(duration.as("M")), weeks2 = round(duration.as("w")), years3 = round(duration.as("y")), a = seconds3 <= thresholds2.ss && ["s", seconds3] || seconds3 < thresholds2.s && ["ss", seconds3] || minutes3 <= 1 && ["m"] || minutes3 < thresholds2.m && ["mm", minutes3] || hours3 <= 1 && ["h"] || hours3 < thresholds2.h && ["hh", hours3] || days3 <= 1 && ["d"] || days3 < thresholds2.d && ["dd", days3];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months3 <= 1 && ["M"] || months3 < thresholds2.M && ["MM", months3] || years3 <= 1 && ["y"] || ["yy", years3];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds3 = abs$1(this._milliseconds) / 1e3, days3 = abs$1(this._days), months3 = abs$1(this._months), minutes3, hours3, years3, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes3 = absFloor(seconds3 / 60);
        hours3 = absFloor(minutes3 / 60);
        seconds3 %= 60;
        minutes3 %= 60;
        years3 = absFloor(months3 / 12);
        months3 %= 12;
        s = seconds3 ? seconds3.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years3 ? ymSign + years3 + "Y" : "") + (months3 ? ymSign + months3 + "M" : "") + (days3 ? daysSign + days3 + "D" : "") + (hours3 || minutes3 || seconds3 ? "T" : "") + (hours3 ? hmsSign + hours3 + "H" : "") + (minutes3 ? hmsSign + minutes3 + "M" : "") + (seconds3 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds2;
      proto$2.seconds = seconds2;
      proto$2.minutes = minutes2;
      proto$2.hours = hours2;
      proto$2.days = days2;
      proto$2.weeks = weeks;
      proto$2.months = months2;
      proto$2.years = years2;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config2) {
        config2._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config2) {
        config2._d = new Date(toInt(input));
      });
      hooks.version = "2.29.4";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min2;
      hooks.max = max2;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate2;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// ../node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "../node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker2 = this.head; walker2; walker2 = walker2.next) {
          yield walker2.value;
        }
      };
    };
  }
});

// ../node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "../node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self = this;
      if (!(self instanceof Yallist)) {
        self = new Yallist();
      }
      self.tail = null;
      self.head = null;
      self.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self.push(arguments[i]);
        }
      }
      return self;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker2 = this.head, i = 0; walker2 !== null; i++) {
        fn.call(thisp, walker2.value, i, this);
        walker2 = walker2.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker2 = this.tail, i = this.length - 1; walker2 !== null; i--) {
        fn.call(thisp, walker2.value, i, this);
        walker2 = walker2.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker2 = this.head; walker2 !== null && i < n; i++) {
        walker2 = walker2.next;
      }
      if (i === n && walker2 !== null) {
        return walker2.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker2 = this.tail; walker2 !== null && i < n; i++) {
        walker2 = walker2.prev;
      }
      if (i === n && walker2 !== null) {
        return walker2.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker2 = this.head; walker2 !== null; ) {
        res.push(fn.call(thisp, walker2.value, this));
        walker2 = walker2.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker2 = this.tail; walker2 !== null; ) {
        res.push(fn.call(thisp, walker2.value, this));
        walker2 = walker2.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker2 = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker2 = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker2 !== null; i++) {
        acc = fn(acc, walker2.value, i);
        walker2 = walker2.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker2 = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker2 = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker2 !== null; i--) {
        acc = fn(acc, walker2.value, i);
        walker2 = walker2.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker2 = this.head; walker2 !== null; i++) {
        arr[i] = walker2.value;
        walker2 = walker2.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker2 = this.tail; walker2 !== null; i++) {
        arr[i] = walker2.value;
        walker2 = walker2.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker2 = this.head; walker2 !== null && i < from; i++) {
        walker2 = walker2.next;
      }
      for (; walker2 !== null && i < to; i++, walker2 = walker2.next) {
        ret.push(walker2.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker2 = this.tail; walker2 !== null && i > to; i--) {
        walker2 = walker2.prev;
      }
      for (; walker2 !== null && i > from; i--, walker2 = walker2.prev) {
        ret.push(walker2.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker2 = this.head; walker2 !== null && i < start; i++) {
        walker2 = walker2.next;
      }
      var ret = [];
      for (var i = 0; walker2 && i < deleteCount; i++) {
        ret.push(walker2.value);
        walker2 = this.removeNode(walker2);
      }
      if (walker2 === null) {
        walker2 = this.tail;
      }
      if (walker2 !== this.head && walker2 !== this.tail) {
        walker2 = walker2.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker2 = insert(this, walker2, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker2 = head; walker2 !== null; walker2 = walker2.prev) {
        var p = walker2.prev;
        walker2.prev = walker2.next;
        walker2.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self, node, value2) {
      var inserted = node === self.head ? new Node(value2, null, node, self) : new Node(value2, node, node.next, self);
      if (inserted.next === null) {
        self.tail = inserted;
      }
      if (inserted.prev === null) {
        self.head = inserted;
      }
      self.length++;
      return inserted;
    }
    function push(self, item) {
      self.tail = new Node(item, self.tail, null, self);
      if (!self.head) {
        self.head = self.tail;
      }
      self.length++;
    }
    function unshift(self, item) {
      self.head = new Node(item, null, self.head, self);
      if (!self.tail) {
        self.tail = self.head;
      }
      self.length++;
    }
    function Node(value2, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value2, prev, next, list);
      }
      this.list = list;
      this.value = value2;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// ../node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max2 = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker2 = this[LRU_LIST].tail; walker2 !== null; ) {
          const prev = walker2.prev;
          forEachStep(this, fn, walker2, thisp);
          walker2 = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker2 = this[LRU_LIST].head; walker2 !== null; ) {
          const next = walker2.next;
          forEachStep(this, fn, walker2, thisp);
          walker2 = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value2, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value2, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value2;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value2, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value2);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get11(this, key, true);
      }
      peek(key) {
        return get11(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value2, key) => get11(this, key, false));
      }
    };
    var get11 = (self, key, doUse) => {
      const node = self[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
          del(self, node);
          if (!self[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self, hit) => {
      if (!hit || !hit.maxAge && !self[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
    };
    var trim = (self) => {
      if (self[LENGTH] > self[MAX]) {
        for (let walker2 = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker2 !== null; ) {
          const prev = walker2.prev;
          del(self, walker2);
          walker2 = prev;
        }
      }
    };
    var del = (self, node) => {
      if (node) {
        const hit = node.value;
        if (self[DISPOSE])
          self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value2, length, now, maxAge) {
        this.key = key;
        this.value = value2;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self);
    };
    module2.exports = LRUCache;
  }
});

// ../node_modules/jsonify/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/jsonify/lib/parse.js"(exports, module2) {
    "use strict";
    var at;
    var ch;
    var escapee = {
      '"': '"',
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
    };
    var text;
    function error(m) {
      throw {
        name: "SyntaxError",
        message: m,
        at,
        text
      };
    }
    function next(c) {
      if (c && c !== ch) {
        error("Expected '" + c + "' instead of '" + ch + "'");
      }
      ch = text.charAt(at);
      at += 1;
      return ch;
    }
    function number() {
      var num;
      var str = "";
      if (ch === "-") {
        str = "-";
        next("-");
      }
      while (ch >= "0" && ch <= "9") {
        str += ch;
        next();
      }
      if (ch === ".") {
        str += ".";
        while (next() && ch >= "0" && ch <= "9") {
          str += ch;
        }
      }
      if (ch === "e" || ch === "E") {
        str += ch;
        next();
        if (ch === "-" || ch === "+") {
          str += ch;
          next();
        }
        while (ch >= "0" && ch <= "9") {
          str += ch;
          next();
        }
      }
      num = Number(str);
      if (!isFinite(num)) {
        error("Bad number");
      }
      return num;
    }
    function string2() {
      var hex;
      var i;
      var str = "";
      var uffff;
      if (ch === '"') {
        while (next()) {
          if (ch === '"') {
            next();
            return str;
          } else if (ch === "\\") {
            next();
            if (ch === "u") {
              uffff = 0;
              for (i = 0; i < 4; i += 1) {
                hex = parseInt(next(), 16);
                if (!isFinite(hex)) {
                  break;
                }
                uffff = uffff * 16 + hex;
              }
              str += String.fromCharCode(uffff);
            } else if (typeof escapee[ch] === "string") {
              str += escapee[ch];
            } else {
              break;
            }
          } else {
            str += ch;
          }
        }
      }
      error("Bad string");
    }
    function white() {
      while (ch && ch <= " ") {
        next();
      }
    }
    function word2() {
      switch (ch) {
        case "t":
          next("t");
          next("r");
          next("u");
          next("e");
          return true;
        case "f":
          next("f");
          next("a");
          next("l");
          next("s");
          next("e");
          return false;
        case "n":
          next("n");
          next("u");
          next("l");
          next("l");
          return null;
        default:
          error("Unexpected '" + ch + "'");
      }
    }
    function array() {
      var arr = [];
      if (ch === "[") {
        next("[");
        white();
        if (ch === "]") {
          next("]");
          return arr;
        }
        while (ch) {
          arr.push(value2());
          white();
          if (ch === "]") {
            next("]");
            return arr;
          }
          next(",");
          white();
        }
      }
      error("Bad array");
    }
    function object() {
      var key;
      var obj = {};
      if (ch === "{") {
        next("{");
        white();
        if (ch === "}") {
          next("}");
          return obj;
        }
        while (ch) {
          key = string2();
          white();
          next(":");
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            error('Duplicate key "' + key + '"');
          }
          obj[key] = value2();
          white();
          if (ch === "}") {
            next("}");
            return obj;
          }
          next(",");
          white();
        }
      }
      error("Bad object");
    }
    function value2() {
      white();
      switch (ch) {
        case "{":
          return object();
        case "[":
          return array();
        case '"':
          return string2();
        case "-":
          return number();
        default:
          return ch >= "0" && ch <= "9" ? number() : word2();
      }
    }
    module2.exports = function(source, reviver) {
      var result;
      text = source;
      at = 0;
      ch = " ";
      result = value2();
      white();
      if (ch) {
        error("Syntax error");
      }
      return typeof reviver === "function" ? function walk(holder, key) {
        var k;
        var v;
        var val = holder[key];
        if (val && typeof val === "object") {
          for (k in value2) {
            if (Object.prototype.hasOwnProperty.call(val, k)) {
              v = walk(val, k);
              if (typeof v === "undefined") {
                delete val[k];
              } else {
                val[k] = v;
              }
            }
          }
        }
        return reviver.call(holder, key, val);
      }({ "": result }, "") : result;
    };
  }
});

// ../node_modules/jsonify/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/jsonify/lib/stringify.js"(exports, module2) {
    "use strict";
    var escapable = /[\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
    var gap;
    var indent;
    var meta = {
      // table of character substitutions
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\f": "\\f",
      "\r": "\\r",
      '"': '\\"',
      "\\": "\\\\"
    };
    var rep;
    function quote(string2) {
      escapable.lastIndex = 0;
      return escapable.test(string2) ? '"' + string2.replace(escapable, function(a) {
        var c = meta[a];
        return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
      }) + '"' : '"' + string2 + '"';
    }
    function str(key, holder) {
      var i;
      var k;
      var v;
      var length;
      var mind = gap;
      var partial;
      var value2 = holder[key];
      if (value2 && typeof value2 === "object" && typeof value2.toJSON === "function") {
        value2 = value2.toJSON(key);
      }
      if (typeof rep === "function") {
        value2 = rep.call(holder, key, value2);
      }
      switch (typeof value2) {
        case "string":
          return quote(value2);
        case "number":
          return isFinite(value2) ? String(value2) : "null";
        case "boolean":
        case "null":
          return String(value2);
        case "object":
          if (!value2) {
            return "null";
          }
          gap += indent;
          partial = [];
          if (Object.prototype.toString.apply(value2) === "[object Array]") {
            length = value2.length;
            for (i = 0; i < length; i += 1) {
              partial[i] = str(i, value2) || "null";
            }
            v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
            gap = mind;
            return v;
          }
          if (rep && typeof rep === "object") {
            length = rep.length;
            for (i = 0; i < length; i += 1) {
              k = rep[i];
              if (typeof k === "string") {
                v = str(k, value2);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          } else {
            for (k in value2) {
              if (Object.prototype.hasOwnProperty.call(value2, k)) {
                v = str(k, value2);
                if (v) {
                  partial.push(quote(k) + (gap ? ": " : ":") + v);
                }
              }
            }
          }
          v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
          gap = mind;
          return v;
        default:
      }
    }
    module2.exports = function(value2, replacer, space) {
      var i;
      gap = "";
      indent = "";
      if (typeof space === "number") {
        for (i = 0; i < space; i += 1) {
          indent += " ";
        }
      } else if (typeof space === "string") {
        indent = space;
      }
      rep = replacer;
      if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
        throw new Error("JSON.stringify");
      }
      return str("", { "": value2 });
    };
  }
});

// ../node_modules/jsonify/index.js
var require_jsonify = __commonJS({
  "../node_modules/jsonify/index.js"(exports) {
    "use strict";
    exports.parse = require_parse();
    exports.stringify = require_stringify();
  }
});

// ../node_modules/json-stable-stringify/index.js
var require_json_stable_stringify = __commonJS({
  "../node_modules/json-stable-stringify/index.js"(exports, module2) {
    "use strict";
    var json = typeof JSON !== "undefined" ? JSON : require_jsonify();
    var isArray3 = Array.isArray || function(x) {
      return {}.toString.call(x) === "[object Array]";
    };
    var objectKeys = Object.keys || function(obj) {
      var has5 = Object.prototype.hasOwnProperty || function() {
        return true;
      };
      var keys2 = [];
      for (var key in obj) {
        if (has5.call(obj, key)) {
          keys2.push(key);
        }
      }
      return keys2;
    };
    module2.exports = function(obj, opts) {
      if (!opts) {
        opts = {};
      }
      if (typeof opts === "function") {
        opts = { cmp: opts };
      }
      var space = opts.space || "";
      if (typeof space === "number") {
        space = Array(space + 1).join(" ");
      }
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var replacer = opts.replacer || function(key, value2) {
        return value2;
      };
      var cmp = opts.cmp && function(f) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(parent, key, node, level) {
        var indent = space ? "\n" + new Array(level + 1).join(space) : "";
        var colonSeparator = space ? ": " : ":";
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        node = replacer.call(parent, key, node);
        if (node === void 0) {
          return;
        }
        if (typeof node !== "object" || node === null) {
          return json.stringify(node);
        }
        if (isArray3(node)) {
          var out = [];
          for (var i = 0; i < node.length; i++) {
            var item = stringify2(node, i, node[i], level + 1) || json.stringify(null);
            out.push(indent + space + item);
          }
          return "[" + out.join(",") + indent + "]";
        }
        if (seen.indexOf(node) !== -1) {
          if (cycles) {
            return json.stringify("__cycle__");
          }
          throw new TypeError("Converting circular structure to JSON");
        } else {
          seen.push(node);
        }
        var keys2 = objectKeys(node).sort(cmp && cmp(node));
        var out = [];
        for (var i = 0; i < keys2.length; i++) {
          var key = keys2[i];
          var value2 = stringify2(node, key, node[key], level + 1);
          if (!value2) {
            continue;
          }
          var keyValue = json.stringify(key) + colonSeparator + value2;
          out.push(indent + space + keyValue);
        }
        seen.splice(seen.indexOf(node), 1);
        return "{" + out.join(",") + indent + "}";
      }({ "": obj }, "", obj, 0);
    };
  }
});

// ../node_modules/functional-red-black-tree/rbtree.js
var require_rbtree = __commonJS({
  "../node_modules/functional-red-black-tree/rbtree.js"(exports, module2) {
    "use strict";
    module2.exports = createRBTree;
    var RED = 0;
    var BLACK = 1;
    function RBNode(color, key, value2, left, right, count2) {
      this._color = color;
      this.key = key;
      this.value = value2;
      this.left = left;
      this.right = right;
      this._count = count2;
    }
    function cloneNode(node) {
      return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
    }
    function repaint(color, node) {
      return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
    }
    function recount(node) {
      node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
    }
    function RedBlackTree(compare, root) {
      this._compare = compare;
      this.root = root;
    }
    var proto = RedBlackTree.prototype;
    Object.defineProperty(proto, "keys", {
      get: function() {
        var result = [];
        this.forEach(function(k, v) {
          result.push(k);
        });
        return result;
      }
    });
    Object.defineProperty(proto, "values", {
      get: function() {
        var result = [];
        this.forEach(function(k, v) {
          result.push(v);
        });
        return result;
      }
    });
    Object.defineProperty(proto, "length", {
      get: function() {
        if (this.root) {
          return this.root._count;
        }
        return 0;
      }
    });
    proto.insert = function(key, value2) {
      var cmp = this._compare;
      var n = this.root;
      var n_stack = [];
      var d_stack = [];
      while (n) {
        var d = cmp(key, n.key);
        n_stack.push(n);
        d_stack.push(d);
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      n_stack.push(new RBNode(RED, key, value2, null, null, 1));
      for (var s = n_stack.length - 2; s >= 0; --s) {
        var n = n_stack[s];
        if (d_stack[s] <= 0) {
          n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
        } else {
          n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
        }
      }
      for (var s = n_stack.length - 1; s > 1; --s) {
        var p = n_stack[s - 1];
        var n = n_stack[s];
        if (p._color === BLACK || n._color === BLACK) {
          break;
        }
        var pp = n_stack[s - 2];
        if (pp.left === p) {
          if (p.left === n) {
            var y = pp.right;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.right = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              pp._color = RED;
              pp.left = p.right;
              p._color = BLACK;
              p.right = pp;
              n_stack[s - 2] = p;
              n_stack[s - 1] = n;
              recount(pp);
              recount(p);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.left === pp) {
                  ppp.left = p;
                } else {
                  ppp.right = p;
                }
              }
              break;
            }
          } else {
            var y = pp.right;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.right = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              p.right = n.left;
              pp._color = RED;
              pp.left = n.right;
              n._color = BLACK;
              n.left = p;
              n.right = pp;
              n_stack[s - 2] = n;
              n_stack[s - 1] = p;
              recount(pp);
              recount(p);
              recount(n);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.left === pp) {
                  ppp.left = n;
                } else {
                  ppp.right = n;
                }
              }
              break;
            }
          }
        } else {
          if (p.right === n) {
            var y = pp.left;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.left = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              pp._color = RED;
              pp.right = p.left;
              p._color = BLACK;
              p.left = pp;
              n_stack[s - 2] = p;
              n_stack[s - 1] = n;
              recount(pp);
              recount(p);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.right === pp) {
                  ppp.right = p;
                } else {
                  ppp.left = p;
                }
              }
              break;
            }
          } else {
            var y = pp.left;
            if (y && y._color === RED) {
              p._color = BLACK;
              pp.left = repaint(BLACK, y);
              pp._color = RED;
              s -= 1;
            } else {
              p.left = n.right;
              pp._color = RED;
              pp.right = n.left;
              n._color = BLACK;
              n.right = p;
              n.left = pp;
              n_stack[s - 2] = n;
              n_stack[s - 1] = p;
              recount(pp);
              recount(p);
              recount(n);
              if (s >= 3) {
                var ppp = n_stack[s - 3];
                if (ppp.right === pp) {
                  ppp.right = n;
                } else {
                  ppp.left = n;
                }
              }
              break;
            }
          }
        }
      }
      n_stack[0]._color = BLACK;
      return new RedBlackTree(cmp, n_stack[0]);
    };
    function doVisitFull(visit, node) {
      if (node.left) {
        var v = doVisitFull(visit, node.left);
        if (v) {
          return v;
        }
      }
      var v = visit(node.key, node.value);
      if (v) {
        return v;
      }
      if (node.right) {
        return doVisitFull(visit, node.right);
      }
    }
    function doVisitHalf(lo, compare, visit, node) {
      var l = compare(lo, node.key);
      if (l <= 0) {
        if (node.left) {
          var v = doVisitHalf(lo, compare, visit, node.left);
          if (v) {
            return v;
          }
        }
        var v = visit(node.key, node.value);
        if (v) {
          return v;
        }
      }
      if (node.right) {
        return doVisitHalf(lo, compare, visit, node.right);
      }
    }
    function doVisit(lo, hi, compare, visit, node) {
      var l = compare(lo, node.key);
      var h = compare(hi, node.key);
      var v;
      if (l <= 0) {
        if (node.left) {
          v = doVisit(lo, hi, compare, visit, node.left);
          if (v) {
            return v;
          }
        }
        if (h > 0) {
          v = visit(node.key, node.value);
          if (v) {
            return v;
          }
        }
      }
      if (h > 0 && node.right) {
        return doVisit(lo, hi, compare, visit, node.right);
      }
    }
    proto.forEach = function rbTreeForEach(visit, lo, hi) {
      if (!this.root) {
        return;
      }
      switch (arguments.length) {
        case 1:
          return doVisitFull(visit, this.root);
          break;
        case 2:
          return doVisitHalf(lo, this._compare, visit, this.root);
          break;
        case 3:
          if (this._compare(lo, hi) >= 0) {
            return;
          }
          return doVisit(lo, hi, this._compare, visit, this.root);
          break;
      }
    };
    Object.defineProperty(proto, "begin", {
      get: function() {
        var stack = [];
        var n = this.root;
        while (n) {
          stack.push(n);
          n = n.left;
        }
        return new RedBlackTreeIterator(this, stack);
      }
    });
    Object.defineProperty(proto, "end", {
      get: function() {
        var stack = [];
        var n = this.root;
        while (n) {
          stack.push(n);
          n = n.right;
        }
        return new RedBlackTreeIterator(this, stack);
      }
    });
    proto.at = function(idx) {
      if (idx < 0) {
        return new RedBlackTreeIterator(this, []);
      }
      var n = this.root;
      var stack = [];
      while (true) {
        stack.push(n);
        if (n.left) {
          if (idx < n.left._count) {
            n = n.left;
            continue;
          }
          idx -= n.left._count;
        }
        if (!idx) {
          return new RedBlackTreeIterator(this, stack);
        }
        idx -= 1;
        if (n.right) {
          if (idx >= n.right._count) {
            break;
          }
          n = n.right;
        } else {
          break;
        }
      }
      return new RedBlackTreeIterator(this, []);
    };
    proto.ge = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d <= 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.gt = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d < 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.lt = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d > 0) {
          last_ptr = stack.length;
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.le = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      var last_ptr = 0;
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d >= 0) {
          last_ptr = stack.length;
        }
        if (d < 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      stack.length = last_ptr;
      return new RedBlackTreeIterator(this, stack);
    };
    proto.find = function(key) {
      var cmp = this._compare;
      var n = this.root;
      var stack = [];
      while (n) {
        var d = cmp(key, n.key);
        stack.push(n);
        if (d === 0) {
          return new RedBlackTreeIterator(this, stack);
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      return new RedBlackTreeIterator(this, []);
    };
    proto.remove = function(key) {
      var iter = this.find(key);
      if (iter) {
        return iter.remove();
      }
      return this;
    };
    proto.get = function(key) {
      var cmp = this._compare;
      var n = this.root;
      while (n) {
        var d = cmp(key, n.key);
        if (d === 0) {
          return n.value;
        }
        if (d <= 0) {
          n = n.left;
        } else {
          n = n.right;
        }
      }
      return;
    };
    function RedBlackTreeIterator(tree, stack) {
      this.tree = tree;
      this._stack = stack;
    }
    var iproto = RedBlackTreeIterator.prototype;
    Object.defineProperty(iproto, "valid", {
      get: function() {
        return this._stack.length > 0;
      }
    });
    Object.defineProperty(iproto, "node", {
      get: function() {
        if (this._stack.length > 0) {
          return this._stack[this._stack.length - 1];
        }
        return null;
      },
      enumerable: true
    });
    iproto.clone = function() {
      return new RedBlackTreeIterator(this.tree, this._stack.slice());
    };
    function swapNode(n, v) {
      n.key = v.key;
      n.value = v.value;
      n.left = v.left;
      n.right = v.right;
      n._color = v._color;
      n._count = v._count;
    }
    function fixDoubleBlack(stack) {
      var n, p, s, z11;
      for (var i = stack.length - 1; i >= 0; --i) {
        n = stack[i];
        if (i === 0) {
          n._color = BLACK;
          return;
        }
        p = stack[i - 1];
        if (p.left === n) {
          s = p.right;
          if (s.right && s.right._color === RED) {
            s = p.right = cloneNode(s);
            z11 = s.right = cloneNode(s.right);
            p.right = s.left;
            s.left = p;
            s.right = z11;
            s._color = p._color;
            n._color = BLACK;
            p._color = BLACK;
            z11._color = BLACK;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = s;
              } else {
                pp.right = s;
              }
            }
            stack[i - 1] = s;
            return;
          } else if (s.left && s.left._color === RED) {
            s = p.right = cloneNode(s);
            z11 = s.left = cloneNode(s.left);
            p.right = z11.left;
            s.left = z11.right;
            z11.left = p;
            z11.right = s;
            z11._color = p._color;
            p._color = BLACK;
            s._color = BLACK;
            n._color = BLACK;
            recount(p);
            recount(s);
            recount(z11);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = z11;
              } else {
                pp.right = z11;
              }
            }
            stack[i - 1] = z11;
            return;
          }
          if (s._color === BLACK) {
            if (p._color === RED) {
              p._color = BLACK;
              p.right = repaint(RED, s);
              return;
            } else {
              p.right = repaint(RED, s);
              continue;
            }
          } else {
            s = cloneNode(s);
            p.right = s.left;
            s.left = p;
            s._color = p._color;
            p._color = RED;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.left === p) {
                pp.left = s;
              } else {
                pp.right = s;
              }
            }
            stack[i - 1] = s;
            stack[i] = p;
            if (i + 1 < stack.length) {
              stack[i + 1] = n;
            } else {
              stack.push(n);
            }
            i = i + 2;
          }
        } else {
          s = p.left;
          if (s.left && s.left._color === RED) {
            s = p.left = cloneNode(s);
            z11 = s.left = cloneNode(s.left);
            p.left = s.right;
            s.right = p;
            s.left = z11;
            s._color = p._color;
            n._color = BLACK;
            p._color = BLACK;
            z11._color = BLACK;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = s;
              } else {
                pp.left = s;
              }
            }
            stack[i - 1] = s;
            return;
          } else if (s.right && s.right._color === RED) {
            s = p.left = cloneNode(s);
            z11 = s.right = cloneNode(s.right);
            p.left = z11.right;
            s.right = z11.left;
            z11.right = p;
            z11.left = s;
            z11._color = p._color;
            p._color = BLACK;
            s._color = BLACK;
            n._color = BLACK;
            recount(p);
            recount(s);
            recount(z11);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = z11;
              } else {
                pp.left = z11;
              }
            }
            stack[i - 1] = z11;
            return;
          }
          if (s._color === BLACK) {
            if (p._color === RED) {
              p._color = BLACK;
              p.left = repaint(RED, s);
              return;
            } else {
              p.left = repaint(RED, s);
              continue;
            }
          } else {
            s = cloneNode(s);
            p.left = s.right;
            s.right = p;
            s._color = p._color;
            p._color = RED;
            recount(p);
            recount(s);
            if (i > 1) {
              var pp = stack[i - 2];
              if (pp.right === p) {
                pp.right = s;
              } else {
                pp.left = s;
              }
            }
            stack[i - 1] = s;
            stack[i] = p;
            if (i + 1 < stack.length) {
              stack[i + 1] = n;
            } else {
              stack.push(n);
            }
            i = i + 2;
          }
        }
      }
    }
    iproto.remove = function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return this.tree;
      }
      var cstack = new Array(stack.length);
      var n = stack[stack.length - 1];
      cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
      for (var i = stack.length - 2; i >= 0; --i) {
        var n = stack[i];
        if (n.left === stack[i + 1]) {
          cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
        } else {
          cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
        }
      }
      n = cstack[cstack.length - 1];
      if (n.left && n.right) {
        var split = cstack.length;
        n = n.left;
        while (n.right) {
          cstack.push(n);
          n = n.right;
        }
        var v = cstack[split - 1];
        cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
        cstack[split - 1].key = n.key;
        cstack[split - 1].value = n.value;
        for (var i = cstack.length - 2; i >= split; --i) {
          n = cstack[i];
          cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
        }
        cstack[split - 1].left = cstack[split];
      }
      n = cstack[cstack.length - 1];
      if (n._color === RED) {
        var p = cstack[cstack.length - 2];
        if (p.left === n) {
          p.left = null;
        } else if (p.right === n) {
          p.right = null;
        }
        cstack.pop();
        for (var i = 0; i < cstack.length; ++i) {
          cstack[i]._count--;
        }
        return new RedBlackTree(this.tree._compare, cstack[0]);
      } else {
        if (n.left || n.right) {
          if (n.left) {
            swapNode(n, n.left);
          } else if (n.right) {
            swapNode(n, n.right);
          }
          n._color = BLACK;
          for (var i = 0; i < cstack.length - 1; ++i) {
            cstack[i]._count--;
          }
          return new RedBlackTree(this.tree._compare, cstack[0]);
        } else if (cstack.length === 1) {
          return new RedBlackTree(this.tree._compare, null);
        } else {
          for (var i = 0; i < cstack.length; ++i) {
            cstack[i]._count--;
          }
          var parent = cstack[cstack.length - 2];
          fixDoubleBlack(cstack);
          if (parent.left === n) {
            parent.left = null;
          } else {
            parent.right = null;
          }
        }
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    };
    Object.defineProperty(iproto, "key", {
      get: function() {
        if (this._stack.length > 0) {
          return this._stack[this._stack.length - 1].key;
        }
        return;
      },
      enumerable: true
    });
    Object.defineProperty(iproto, "value", {
      get: function() {
        if (this._stack.length > 0) {
          return this._stack[this._stack.length - 1].value;
        }
        return;
      },
      enumerable: true
    });
    Object.defineProperty(iproto, "index", {
      get: function() {
        var idx = 0;
        var stack = this._stack;
        if (stack.length === 0) {
          var r = this.tree.root;
          if (r) {
            return r._count;
          }
          return 0;
        } else if (stack[stack.length - 1].left) {
          idx = stack[stack.length - 1].left._count;
        }
        for (var s = stack.length - 2; s >= 0; --s) {
          if (stack[s + 1] === stack[s].right) {
            ++idx;
            if (stack[s].left) {
              idx += stack[s].left._count;
            }
          }
        }
        return idx;
      },
      enumerable: true
    });
    iproto.next = function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return;
      }
      var n = stack[stack.length - 1];
      if (n.right) {
        n = n.right;
        while (n) {
          stack.push(n);
          n = n.left;
        }
      } else {
        stack.pop();
        while (stack.length > 0 && stack[stack.length - 1].right === n) {
          n = stack[stack.length - 1];
          stack.pop();
        }
      }
    };
    Object.defineProperty(iproto, "hasNext", {
      get: function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return false;
        }
        if (stack[stack.length - 1].right) {
          return true;
        }
        for (var s = stack.length - 1; s > 0; --s) {
          if (stack[s - 1].left === stack[s]) {
            return true;
          }
        }
        return false;
      }
    });
    iproto.update = function(value2) {
      var stack = this._stack;
      if (stack.length === 0) {
        throw new Error("Can't update empty node!");
      }
      var cstack = new Array(stack.length);
      var n = stack[stack.length - 1];
      cstack[cstack.length - 1] = new RBNode(n._color, n.key, value2, n.left, n.right, n._count);
      for (var i = stack.length - 2; i >= 0; --i) {
        n = stack[i];
        if (n.left === stack[i + 1]) {
          cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
        } else {
          cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
        }
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    };
    iproto.prev = function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return;
      }
      var n = stack[stack.length - 1];
      if (n.left) {
        n = n.left;
        while (n) {
          stack.push(n);
          n = n.right;
        }
      } else {
        stack.pop();
        while (stack.length > 0 && stack[stack.length - 1].left === n) {
          n = stack[stack.length - 1];
          stack.pop();
        }
      }
    };
    Object.defineProperty(iproto, "hasPrev", {
      get: function() {
        var stack = this._stack;
        if (stack.length === 0) {
          return false;
        }
        if (stack[stack.length - 1].left) {
          return true;
        }
        for (var s = stack.length - 1; s > 0; --s) {
          if (stack[s - 1].right === stack[s]) {
            return true;
          }
        }
        return false;
      }
    });
    function defaultCompare(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function createRBTree(compare) {
      return new RedBlackTree(compare || defaultCompare, null);
    }
  }
});

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/knex/node_modules/debug/src/common.js
var require_common = __commonJS({
  "../node_modules/knex/node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../node_modules/knex/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/knex/node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min2 = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min2;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min2;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min2;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../node_modules/knex/node_modules/debug/src/node.js
var require_node = __commonJS({
  "../node_modules/knex/node_modules/debug/src/node.js"(exports, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../node_modules/knex/node_modules/debug/src/index.js
var require_src = __commonJS({
  "../node_modules/knex/node_modules/debug/src/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// ../node_modules/knex/lib/constants.js
var require_constants = __commonJS({
  "../node_modules/knex/lib/constants.js"(exports, module2) {
    "use strict";
    var CLIENT_ALIASES = Object.freeze({
      pg: "postgres",
      postgresql: "postgres",
      sqlite: "sqlite3"
    });
    var SUPPORTED_CLIENTS = Object.freeze(
      [
        "mssql",
        "mysql",
        "mysql2",
        "oracledb",
        "postgres",
        "redshift",
        "sqlite3"
      ].concat(Object.keys(CLIENT_ALIASES))
    );
    var POOL_CONFIG_OPTIONS = Object.freeze([
      "maxWaitingClients",
      "testOnBorrow",
      "fifo",
      "priorityRange",
      "autostart",
      "evictionRunIntervalMillis",
      "numTestsPerRun",
      "softIdleTimeoutMillis",
      "Promise"
    ]);
    var COMMA_NO_PAREN_REGEX = /,[\s](?![^(]*\))/g;
    module2.exports = {
      CLIENT_ALIASES,
      SUPPORTED_CLIENTS,
      POOL_CONFIG_OPTIONS,
      COMMA_NO_PAREN_REGEX
    };
  }
});

// ../node_modules/knex/lib/util/is.js
var require_is = __commonJS({
  "../node_modules/knex/lib/util/is.js"(exports, module2) {
    "use strict";
    function isString2(value2) {
      return typeof value2 === "string";
    }
    function isNumber2(value2) {
      return typeof value2 === "number";
    }
    function isBoolean2(value2) {
      return typeof value2 === "boolean";
    }
    function isUndefined3(value2) {
      return typeof value2 === "undefined";
    }
    function isObject(value2) {
      return typeof value2 === "object" && value2 !== null;
    }
    function isFunction(value2) {
      return typeof value2 === "function";
    }
    module2.exports = {
      isString: isString2,
      isNumber: isNumber2,
      isBoolean: isBoolean2,
      isUndefined: isUndefined3,
      isObject,
      isFunction
    };
  }
});

// ../node_modules/knex/lib/helpers.js
var require_helpers = __commonJS({
  "../node_modules/knex/lib/helpers.js"(exports, module2) {
    "use strict";
    var isPlainObject4 = require("lodash/isPlainObject");
    var isTypedArray2 = require("lodash/isTypedArray");
    var { CLIENT_ALIASES } = require_constants();
    var { isFunction } = require_is();
    function normalizeArr() {
      const args = new Array(arguments.length);
      for (let i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      if (Array.isArray(args[0])) {
        return args[0];
      }
      return args;
    }
    function containsUndefined(mixed) {
      let argContainsUndefined = false;
      if (isTypedArray2(mixed))
        return false;
      if (mixed && isFunction(mixed.toSQL)) {
        return argContainsUndefined;
      }
      if (Array.isArray(mixed)) {
        for (let i = 0; i < mixed.length; i++) {
          if (argContainsUndefined)
            break;
          argContainsUndefined = containsUndefined(mixed[i]);
        }
      } else if (isPlainObject4(mixed)) {
        Object.keys(mixed).forEach((key) => {
          if (!argContainsUndefined) {
            argContainsUndefined = containsUndefined(mixed[key]);
          }
        });
      } else {
        argContainsUndefined = mixed === void 0;
      }
      return argContainsUndefined;
    }
    function getUndefinedIndices(mixed) {
      const indices = [];
      if (Array.isArray(mixed)) {
        mixed.forEach((item, index) => {
          if (containsUndefined(item)) {
            indices.push(index);
          }
        });
      } else if (isPlainObject4(mixed)) {
        Object.keys(mixed).forEach((key) => {
          if (containsUndefined(mixed[key])) {
            indices.push(key);
          }
        });
      } else {
        indices.push(0);
      }
      return indices;
    }
    function addQueryContext(Target) {
      Target.prototype.queryContext = function(context) {
        if (context === void 0) {
          return this._queryContext;
        }
        this._queryContext = context;
        return this;
      };
    }
    function resolveClientNameWithAliases(clientName) {
      return CLIENT_ALIASES[clientName] || clientName;
    }
    module2.exports = {
      addQueryContext,
      containsUndefined,
      normalizeArr,
      resolveClientNameWithAliases,
      getUndefinedIndices
    };
  }
});

// ../node_modules/knex/lib/util/save-async-stack.js
var require_save_async_stack = __commonJS({
  "../node_modules/knex/lib/util/save-async-stack.js"(exports, module2) {
    "use strict";
    module2.exports = function saveAsyncStack(instance, lines) {
      if (instance.client.config.asyncStackTraces) {
        instance._asyncStack = {
          error: new Error(),
          lines
        };
      }
    };
  }
});

// ../node_modules/knex/lib/util/nanoid.js
var require_nanoid = __commonJS({
  "../node_modules/knex/lib/util/nanoid.js"(exports, module2) {
    "use strict";
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    function nanoid(size = 21) {
      let id = "";
      let i = size;
      while (i--) {
        id += urlAlphabet[Math.random() * 64 | 0];
      }
      return id;
    }
    module2.exports = { nanoid };
  }
});

// ../node_modules/knex/lib/util/noop.js
var require_noop = __commonJS({
  "../node_modules/knex/lib/util/noop.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// ../node_modules/knex/lib/util/finally-mixin.js
var require_finally_mixin = __commonJS({
  "../node_modules/knex/lib/util/finally-mixin.js"(exports, module2) {
    "use strict";
    var noop = require_noop();
    var finallyMixin = (prototype) => Object.assign(prototype, {
      finally(onFinally) {
        return this.then().finally(onFinally);
      }
    });
    module2.exports = Promise.prototype.finally ? finallyMixin : noop;
  }
});

// ../node_modules/knex/lib/interface.js
var require_interface = __commonJS({
  "../node_modules/knex/lib/interface.js"(exports, module2) {
    "use strict";
    var clone = require("lodash/clone");
    var isEmpty2 = require("lodash/isEmpty");
    var { callbackify } = require("util");
    var finallyMixin = require_finally_mixin();
    function augmentWithBuilderInterface(Target) {
      Target.prototype.toQuery = function(tz) {
        let data = this.toSQL(this._method, tz);
        if (!Array.isArray(data))
          data = [data];
        if (!data.length) {
          return "";
        }
        return data.map((statement) => {
          return this.client._formatQuery(statement.sql, statement.bindings, tz);
        }).reduce((a, c) => a.concat(a.endsWith(";") ? "\n" : ";\n", c));
      };
      Target.prototype.then = function() {
        let result = this.client.runner(this).run();
        if (this.client.config.asyncStackTraces) {
          result = result.catch((err) => {
            err.originalStack = err.stack;
            const firstLine = err.stack.split("\n")[0];
            const { error, lines } = this._asyncStack;
            const stackByLines = error.stack.split("\n");
            const asyncStack = stackByLines.slice(lines);
            asyncStack.unshift(firstLine);
            err.stack = asyncStack.join("\n");
            throw err;
          });
        }
        return result.then.apply(result, arguments);
      };
      Target.prototype.options = function(opts) {
        this._options = this._options || [];
        this._options.push(clone(opts) || {});
        return this;
      };
      Target.prototype.connection = function(connection) {
        this._connection = connection;
        return this;
      };
      Target.prototype.debug = function(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      };
      Target.prototype.transacting = function(transaction) {
        if (transaction && transaction.client) {
          if (!transaction.client.transacting) {
            transaction.client.logger.warn(
              `Invalid transaction value: ${transaction.client}`
            );
          } else {
            this.client = transaction.client;
          }
        }
        if (isEmpty2(transaction)) {
          this.client.logger.error(
            "Invalid value on transacting call, potential bug"
          );
          throw Error(
            "Invalid transacting value (null, undefined or empty object)"
          );
        }
        return this;
      };
      Target.prototype.stream = function(options) {
        return this.client.runner(this).stream(options);
      };
      Target.prototype.pipe = function(writable, options) {
        return this.client.runner(this).pipe(writable, options);
      };
      Target.prototype.asCallback = function(cb) {
        const promise = this.then();
        callbackify(() => promise)(cb);
        return promise;
      };
      Target.prototype.catch = function(onReject) {
        return this.then().catch(onReject);
      };
      Object.defineProperty(Target.prototype, Symbol.toStringTag, {
        get: () => "object"
      });
      finallyMixin(Target.prototype);
    }
    module2.exports = augmentWithBuilderInterface;
  }
});

// ../node_modules/knex/lib/raw.js
var require_raw = __commonJS({
  "../node_modules/knex/lib/raw.js"(exports, module2) {
    "use strict";
    var { inherits } = require("util");
    var { EventEmitter } = require("events");
    var debug = require_src();
    var assign = require("lodash/assign");
    var isPlainObject4 = require("lodash/isPlainObject");
    var reduce2 = require("lodash/reduce");
    var helpers = require_helpers();
    var saveAsyncStack = require_save_async_stack();
    var { nanoid } = require_nanoid();
    var { isNumber: isNumber2, isObject } = require_is();
    var debugBindings = debug("knex:bindings");
    function Raw(client) {
      this.client = client;
      this.sql = "";
      this.bindings = [];
      this._wrappedBefore = void 0;
      this._wrappedAfter = void 0;
      if (client && client.config) {
        this._debug = client.config.debug;
        saveAsyncStack(this, 4);
      }
    }
    inherits(Raw, EventEmitter);
    assign(Raw.prototype, {
      set(sql, bindings) {
        this.sql = sql;
        this.bindings = isObject(bindings) && !bindings.toSQL || bindings === void 0 ? bindings : [bindings];
        return this;
      },
      timeout(ms, { cancel } = {}) {
        if (isNumber2(ms) && ms > 0) {
          this._timeout = ms;
          if (cancel) {
            this.client.assertCanCancelQuery();
            this._cancelOnTimeout = true;
          }
        }
        return this;
      },
      // Wraps the current sql with `before` and `after`.
      wrap(before, after) {
        this._wrappedBefore = before;
        this._wrappedAfter = after;
        return this;
      },
      // Calls `toString` on the Knex object.
      toString() {
        return this.toQuery();
      },
      // Returns the raw sql for the query.
      toSQL(method, tz) {
        let obj;
        const formatter = this.client.formatter(this);
        if (Array.isArray(this.bindings)) {
          obj = replaceRawArrBindings(this, formatter);
        } else if (this.bindings && isPlainObject4(this.bindings)) {
          obj = replaceKeyBindings(this, formatter);
        } else {
          obj = {
            method: "raw",
            sql: this.sql,
            bindings: this.bindings === void 0 ? [] : [this.bindings]
          };
        }
        if (this._wrappedBefore) {
          obj.sql = this._wrappedBefore + obj.sql;
        }
        if (this._wrappedAfter) {
          obj.sql = obj.sql + this._wrappedAfter;
        }
        obj.options = reduce2(this._options, assign, {});
        if (this._timeout) {
          obj.timeout = this._timeout;
          if (this._cancelOnTimeout) {
            obj.cancelOnTimeout = this._cancelOnTimeout;
          }
        }
        obj.bindings = obj.bindings || [];
        if (helpers.containsUndefined(obj.bindings)) {
          const undefinedBindingIndices = helpers.getUndefinedIndices(
            this.bindings
          );
          debugBindings(obj.bindings);
          throw new Error(
            `Undefined binding(s) detected for keys [${undefinedBindingIndices}] when compiling RAW query: ${obj.sql}`
          );
        }
        obj.__knexQueryUid = nanoid();
        return obj;
      }
    });
    function replaceRawArrBindings(raw, formatter) {
      const expectedBindings = raw.bindings.length;
      const values2 = raw.bindings;
      let index = 0;
      const sql = raw.sql.replace(/\\?\?\??/g, function(match) {
        if (match === "\\?") {
          return match;
        }
        const value2 = values2[index++];
        if (match === "??") {
          return formatter.columnize(value2);
        }
        return formatter.parameter(value2);
      });
      if (expectedBindings !== index) {
        throw new Error(`Expected ${expectedBindings} bindings, saw ${index}`);
      }
      return {
        method: "raw",
        sql,
        bindings: formatter.bindings
      };
    }
    function replaceKeyBindings(raw, formatter) {
      const values2 = raw.bindings;
      const regex = /\\?(:(\w+):(?=::)|:(\w+):(?!:)|:(\w+))/g;
      const sql = raw.sql.replace(regex, function(match, p1, p2, p3, p4) {
        if (match !== p1) {
          return p1;
        }
        const part = p2 || p3 || p4;
        const key = match.trim();
        const isIdentifier = key[key.length - 1] === ":";
        const value2 = values2[part];
        if (value2 === void 0) {
          if (Object.prototype.hasOwnProperty.call(values2, part)) {
            formatter.bindings.push(value2);
          }
          return match;
        }
        if (isIdentifier) {
          return match.replace(p1, formatter.columnize(value2));
        }
        return match.replace(p1, formatter.parameter(value2));
      });
      return {
        method: "raw",
        sql,
        bindings: formatter.bindings
      };
    }
    require_interface()(Raw);
    helpers.addQueryContext(Raw);
    module2.exports = Raw;
  }
});

// ../node_modules/knex/lib/ref.js
var require_ref = __commonJS({
  "../node_modules/knex/lib/ref.js"(exports, module2) {
    "use strict";
    var Raw = require_raw();
    var Ref = class extends Raw {
      constructor(client, ref) {
        super(client);
        this.ref = ref;
        this._schema = null;
        this._alias = null;
      }
      withSchema(schema2) {
        this._schema = schema2;
        return this;
      }
      as(alias) {
        this._alias = alias;
        return this;
      }
      toSQL() {
        const string2 = this._schema ? `${this._schema}.${this.ref}` : this.ref;
        const formatter = this.client.formatter(this);
        const ref = formatter.columnize(string2);
        const sql = this._alias ? `${ref} as ${formatter.wrap(this._alias)}` : ref;
        this.set(sql, []);
        return super.toSQL(...arguments);
      }
    };
    module2.exports = Ref;
  }
});

// ../node_modules/knex/lib/util/timeout.js
var require_timeout = __commonJS({
  "../node_modules/knex/lib/util/timeout.js"(exports, module2) {
    "use strict";
    var KnexTimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "KnexTimeoutError";
      }
    };
    function timeout(promise, ms) {
      return new Promise(function(resolve, reject) {
        const id = setTimeout(function() {
          reject(new KnexTimeoutError("operation timed out"));
        }, ms);
        function wrappedResolve(value2) {
          clearTimeout(id);
          resolve(value2);
        }
        function wrappedReject(err) {
          clearTimeout(id);
          reject(err);
        }
        promise.then(wrappedResolve, wrappedReject);
      });
    }
    module2.exports.KnexTimeoutError = KnexTimeoutError;
    module2.exports.timeout = timeout;
  }
});

// ../node_modules/knex/lib/runner.js
var require_runner = __commonJS({
  "../node_modules/knex/lib/runner.js"(exports, module2) {
    "use strict";
    var { KnexTimeoutError } = require_timeout();
    var { timeout } = require_timeout();
    var Transform;
    function Runner(client, builder) {
      this.client = client;
      this.builder = builder;
      this.queries = [];
      this.connection = void 0;
    }
    Object.assign(Runner.prototype, {
      // "Run" the target, calling "toSQL" on the builder, returning
      // an object or array of queries to run, each of which are run on
      // a single connection.
      run() {
        const runner = this;
        return this.ensureConnection(function(connection) {
          runner.connection = connection;
          runner.client.emit("start", runner.builder);
          runner.builder.emit("start", runner.builder);
          const sql = runner.builder.toSQL();
          if (runner.builder._debug) {
            runner.client.logger.debug(sql);
          }
          if (Array.isArray(sql)) {
            return runner.queryArray(sql);
          }
          return runner.query(sql);
        }).catch(function(err) {
          if (runner.builder._events && runner.builder._events.error) {
            runner.builder.emit("error", err);
          }
          throw err;
        }).then(function(res) {
          runner.builder.emit("end");
          return res;
        });
      },
      // Stream the result set, by passing through to the dialect's streaming
      // capabilities. If the options are
      stream(options, handler) {
        if (arguments.length === 1) {
          if (typeof options === "function") {
            handler = options;
            options = {};
          }
        }
        const hasHandler = typeof handler === "function";
        Transform = Transform || require("stream").Transform;
        const runner = this;
        const queryContext = this.builder.queryContext();
        let queryStream;
        const stream = new Transform({
          objectMode: true,
          transform: (chunk, _, callback) => {
            callback(null, this.client.postProcessResponse(chunk, queryContext));
          },
          destroy() {
            if (queryStream && queryStream.destroy) {
              queryStream.destroy(new Error("stream destroyed"));
            }
          }
        });
        stream.on("pipe", (qs) => {
          queryStream = qs;
        });
        let hasConnection = false;
        const promise = this.ensureConnection(function(connection) {
          hasConnection = true;
          runner.connection = connection;
          try {
            const sql = runner.builder.toSQL();
            if (Array.isArray(sql) && hasHandler) {
              throw new Error(
                "The stream may only be used with a single query statement."
              );
            }
            return runner.client.stream(runner.connection, sql, stream, options);
          } catch (e) {
            stream.emit("error", e);
            throw e;
          }
        });
        if (hasHandler) {
          handler(stream);
          return promise;
        }
        promise.catch(function(err) {
          if (!hasConnection)
            stream.emit("error", err);
        });
        return stream;
      },
      // Allow you to pipe the stream to a writable stream.
      pipe(writable, options) {
        return this.stream(options).pipe(writable);
      },
      // "Runs" a query, returning a promise. All queries specified by the builder are guaranteed
      // to run in sequence, and on the same connection, especially helpful when schema building
      // and dealing with foreign key constraints, etc.
      query: async function(obj) {
        const { __knexUid, __knexTxId } = this.connection;
        this.builder.emit("query", Object.assign({ __knexUid, __knexTxId }, obj));
        const runner = this;
        let queryPromise = this.client.query(this.connection, obj);
        if (obj.timeout) {
          queryPromise = timeout(queryPromise, obj.timeout);
        }
        return queryPromise.then((resp) => this.client.processResponse(resp, runner)).then((processedResponse) => {
          const queryContext = this.builder.queryContext();
          const postProcessedResponse = this.client.postProcessResponse(
            processedResponse,
            queryContext
          );
          this.builder.emit(
            "query-response",
            postProcessedResponse,
            Object.assign({ __knexUid, __knexTxId }, obj),
            this.builder
          );
          this.client.emit(
            "query-response",
            postProcessedResponse,
            Object.assign({ __knexUid, __knexTxId }, obj),
            this.builder
          );
          return postProcessedResponse;
        }).catch((error) => {
          if (!(error instanceof KnexTimeoutError)) {
            return Promise.reject(error);
          }
          const { timeout: timeout2, sql, bindings } = obj;
          let cancelQuery;
          if (obj.cancelOnTimeout) {
            cancelQuery = this.client.cancelQuery(this.connection);
          } else {
            this.connection.__knex__disposed = error;
            cancelQuery = Promise.resolve();
          }
          return cancelQuery.catch((cancelError) => {
            this.connection.__knex__disposed = error;
            throw Object.assign(cancelError, {
              message: `After query timeout of ${timeout2}ms exceeded, cancelling of query failed.`,
              sql,
              bindings,
              timeout: timeout2
            });
          }).then(() => {
            throw Object.assign(error, {
              message: `Defined query timeout of ${timeout2}ms exceeded when running query.`,
              sql,
              bindings,
              timeout: timeout2
            });
          });
        }).catch((error) => {
          this.builder.emit(
            "query-error",
            error,
            Object.assign({ __knexUid, __knexTxId }, obj)
          );
          throw error;
        });
      },
      // In the case of the "schema builder" we call `queryArray`, which runs each
      // of the queries in sequence.
      async queryArray(queries) {
        if (queries.length === 1) {
          return this.query(queries[0]);
        }
        const results = [];
        for (const query of queries) {
          results.push(await this.query(query));
        }
        return results;
      },
      // Check whether there's a transaction flag, and that it has a connection.
      async ensureConnection(cb) {
        if (this.builder._connection) {
          return cb(this.builder._connection);
        }
        if (this.connection) {
          return cb(this.connection);
        }
        return this.client.acquireConnection().catch((error) => {
          if (!(error instanceof KnexTimeoutError)) {
            return Promise.reject(error);
          }
          if (this.builder) {
            error.sql = this.builder.sql;
            error.bindings = this.builder.bindings;
          }
          throw error;
        }).then(async (connection) => {
          try {
            return await cb(connection);
          } finally {
            await this.client.releaseConnection(this.connection);
          }
        });
      }
    });
    module2.exports = Runner;
  }
});

// ../node_modules/knex/lib/query/joinclause.js
var require_joinclause = __commonJS({
  "../node_modules/knex/lib/query/joinclause.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    function JoinClause(table, type, schema2) {
      this.schema = schema2;
      this.table = table;
      this.joinType = type;
      this.and = this;
      this.clauses = [];
    }
    function getClauseFromArguments(compilerType, bool, first3, operator, second) {
      let data = null;
      if (typeof first3 === "function") {
        data = {
          type: "onWrapped",
          value: first3,
          bool
        };
      } else {
        switch (arguments.length) {
          case 3: {
            data = { type: "onRaw", value: first3, bool };
            break;
          }
          case 4:
            data = {
              type: compilerType,
              column: first3,
              operator: "=",
              value: operator,
              bool
            };
            break;
          default:
            data = {
              type: compilerType,
              column: first3,
              operator,
              value: second,
              bool
            };
        }
      }
      return data;
    }
    Object.assign(JoinClause.prototype, {
      grouping: "join",
      // Adds an "on" clause to the current join object.
      on(first3) {
        if (typeof first3 === "object" && typeof first3.toSQL !== "function") {
          const keys2 = Object.keys(first3);
          let i = -1;
          const method = this._bool() === "or" ? "orOn" : "on";
          while (++i < keys2.length) {
            this[method](keys2[i], first3[keys2[i]]);
          }
          return this;
        }
        const data = getClauseFromArguments("onBasic", this._bool(), ...arguments);
        if (data) {
          this.clauses.push(data);
        }
        return this;
      },
      // Adds a "using" clause to the current join.
      using(column) {
        return this.clauses.push({ type: "onUsing", column, bool: this._bool() });
      },
      /*// Adds an "and on" clause to the current join object.
      andOn() {
        return this.on.apply(this, arguments);
      },*/
      // Adds an "or on" clause to the current join object.
      orOn(first3, operator, second) {
        return this._bool("or").on.apply(this, arguments);
      },
      onVal(first3) {
        if (typeof first3 === "object" && typeof first3.toSQL !== "function") {
          const keys2 = Object.keys(first3);
          let i = -1;
          const method = this._bool() === "or" ? "orOnVal" : "onVal";
          while (++i < keys2.length) {
            this[method](keys2[i], first3[keys2[i]]);
          }
          return this;
        }
        const data = getClauseFromArguments("onVal", this._bool(), ...arguments);
        if (data) {
          this.clauses.push(data);
        }
        return this;
      },
      andOnVal() {
        return this.onVal(...arguments);
      },
      orOnVal() {
        return this._bool("or").onVal(...arguments);
      },
      onBetween(column, values2) {
        assert(
          Array.isArray(values2),
          "The second argument to onBetween must be an array."
        );
        assert(
          values2.length === 2,
          "You must specify 2 values for the onBetween clause"
        );
        this.clauses.push({
          type: "onBetween",
          column,
          value: values2,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      },
      onNotBetween(column, values2) {
        return this._not(true).onBetween(column, values2);
      },
      orOnBetween(column, values2) {
        return this._bool("or").onBetween(column, values2);
      },
      orOnNotBetween(column, values2) {
        return this._bool("or")._not(true).onBetween(column, values2);
      },
      onIn(column, values2) {
        if (Array.isArray(values2) && values2.length === 0)
          return this.on(1, "=", 0);
        this.clauses.push({
          type: "onIn",
          column,
          value: values2,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      onNotIn(column, values2) {
        return this._not(true).onIn(column, values2);
      },
      orOnIn(column, values2) {
        return this._bool("or").onIn(column, values2);
      },
      orOnNotIn(column, values2) {
        return this._bool("or")._not(true).onIn(column, values2);
      },
      onNull(column) {
        this.clauses.push({
          type: "onNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      orOnNull(callback) {
        return this._bool("or").onNull(callback);
      },
      onNotNull(callback) {
        return this._not(true).onNull(callback);
      },
      orOnNotNull(callback) {
        return this._not(true)._bool("or").onNull(callback);
      },
      onExists(callback) {
        this.clauses.push({
          type: "onExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      orOnExists(callback) {
        return this._bool("or").onExists(callback);
      },
      onNotExists(callback) {
        return this._not(true).onExists(callback);
      },
      orOnNotExists(callback) {
        return this._not(true)._bool("or").onExists(callback);
      },
      // Explicitly set the type of join, useful within a function when creating a grouped join.
      type(type) {
        this.joinType = type;
        return this;
      },
      _bool(bool) {
        if (arguments.length === 1) {
          this._boolFlag = bool;
          return this;
        }
        const ret = this._boolFlag || "and";
        this._boolFlag = "and";
        return ret;
      },
      _not(val) {
        if (arguments.length === 1) {
          this._notFlag = val;
          return this;
        }
        const ret = this._notFlag;
        this._notFlag = false;
        return ret;
      }
    });
    Object.defineProperty(JoinClause.prototype, "or", {
      get() {
        return this._bool("or");
      }
    });
    JoinClause.prototype.andOn = JoinClause.prototype.on;
    JoinClause.prototype.andOnIn = JoinClause.prototype.onIn;
    JoinClause.prototype.andOnNotIn = JoinClause.prototype.onNotIn;
    JoinClause.prototype.andOnNull = JoinClause.prototype.onNull;
    JoinClause.prototype.andOnNotNull = JoinClause.prototype.onNotNull;
    JoinClause.prototype.andOnExists = JoinClause.prototype.onExists;
    JoinClause.prototype.andOnNotExists = JoinClause.prototype.onNotExists;
    JoinClause.prototype.andOnBetween = JoinClause.prototype.onBetween;
    JoinClause.prototype.andOnNotBetween = JoinClause.prototype.onNotBetween;
    module2.exports = JoinClause;
  }
});

// ../node_modules/knex/lib/query/constants.js
var require_constants2 = __commonJS({
  "../node_modules/knex/lib/query/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      lockMode: {
        forShare: "forShare",
        forUpdate: "forUpdate"
      },
      waitMode: {
        skipLocked: "skipLocked",
        noWait: "noWait"
      }
    };
  }
});

// ../node_modules/knex/lib/query/builder.js
var require_builder = __commonJS({
  "../node_modules/knex/lib/query/builder.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var { inherits } = require("util");
    var { EventEmitter } = require("events");
    var Raw = require_raw();
    var helpers = require_helpers();
    var JoinClause = require_joinclause();
    var assign = require("lodash/assign");
    var clone = require("lodash/clone");
    var each = require("lodash/each");
    var isEmpty2 = require("lodash/isEmpty");
    var isPlainObject4 = require("lodash/isPlainObject");
    var last3 = require("lodash/last");
    var reject = require("lodash/reject");
    var tail = require("lodash/tail");
    var toArray2 = require("lodash/toArray");
    var saveAsyncStack = require_save_async_stack();
    var { isBoolean: isBoolean2, isNumber: isNumber2, isObject, isString: isString2 } = require_is();
    var { lockMode, waitMode } = require_constants2();
    function OnConflictBuilder(builder, columns) {
      this.builder = builder;
      this._columns = columns;
    }
    assign(OnConflictBuilder.prototype, {
      // Sets insert query to ignore conflicts
      ignore() {
        this.builder._single.onConflict = this._columns;
        this.builder._single.ignore = true;
        return this.builder;
      },
      // Sets insert query to update on conflict
      merge(updates) {
        this.builder._single.onConflict = this._columns;
        this.builder._single.merge = { updates };
        return this.builder;
      },
      // Prevent
      then() {
        throw new Error(
          "Incomplete onConflict clause. .onConflict() must be diretly followed by either .merge() or .ignore()"
        );
      }
    });
    function Builder(client) {
      this.client = client;
      this.and = this;
      this._single = {};
      this._statements = [];
      this._method = "select";
      if (client.config) {
        saveAsyncStack(this, 5);
        this._debug = client.config.debug;
      }
      this._joinFlag = "inner";
      this._boolFlag = "and";
      this._notFlag = false;
      this._asColumnFlag = false;
    }
    inherits(Builder, EventEmitter);
    var validateWithArgs = function(alias, statement, method) {
      if (typeof alias !== "string") {
        throw new Error(`${method}() first argument must be a string`);
      }
      if (typeof statement === "function" || statement instanceof Builder || statement instanceof Raw) {
        return;
      }
      throw new Error(
        `${method}() second argument must be a function / QueryBuilder or a raw`
      );
    };
    assign(Builder.prototype, {
      toString() {
        return this.toQuery();
      },
      // Convert the current query "toSQL"
      toSQL(method, tz) {
        return this.client.queryCompiler(this).toSQL(method || this._method, tz);
      },
      // Create a shallow clone of the current query builder.
      clone() {
        const cloned = new this.constructor(this.client);
        cloned._method = this._method;
        cloned._single = clone(this._single);
        cloned._statements = clone(this._statements);
        cloned._debug = this._debug;
        if (this._options !== void 0) {
          cloned._options = clone(this._options);
        }
        if (this._queryContext !== void 0) {
          cloned._queryContext = clone(this._queryContext);
        }
        if (this._connection !== void 0) {
          cloned._connection = this._connection;
        }
        return cloned;
      },
      timeout(ms, { cancel } = {}) {
        if (isNumber2(ms) && ms > 0) {
          this._timeout = ms;
          if (cancel) {
            this.client.assertCanCancelQuery();
            this._cancelOnTimeout = true;
          }
        }
        return this;
      },
      // With
      // ------
      with(alias, statement) {
        validateWithArgs(alias, statement, "with");
        return this.withWrapped(alias, statement);
      },
      // Helper for compiling any advanced `with` queries.
      withWrapped(alias, query) {
        this._statements.push({
          grouping: "with",
          type: "withWrapped",
          alias,
          value: query
        });
        return this;
      },
      // With Recursive
      // ------
      withRecursive(alias, statement) {
        validateWithArgs(alias, statement, "withRecursive");
        return this.withRecursiveWrapped(alias, statement);
      },
      // Helper for compiling any advanced `withRecursive` queries.
      withRecursiveWrapped(alias, query) {
        this.withWrapped(alias, query);
        this._statements[this._statements.length - 1].recursive = true;
        return this;
      },
      // Select
      // ------
      // Adds a column or columns to the list of "columns"
      // being selected on the query.
      columns(column) {
        if (!column && column !== 0)
          return this;
        this._statements.push({
          grouping: "columns",
          value: helpers.normalizeArr.apply(null, arguments)
        });
        return this;
      },
      // Allow for a sub-select to be explicitly aliased as a column,
      // without needing to compile the query in a where.
      as(column) {
        this._single.as = column;
        return this;
      },
      // Adds a single hint or an array of hits to the list of "hintComments" on the query.
      hintComment(hints) {
        hints = Array.isArray(hints) ? hints : [hints];
        if (hints.some((hint) => !isString2(hint))) {
          throw new Error("Hint comment must be a string");
        }
        if (hints.some((hint) => hint.includes("/*") || hint.includes("*/"))) {
          throw new Error('Hint comment cannot include "/*" or "*/"');
        }
        if (hints.some((hint) => hint.includes("?"))) {
          throw new Error('Hint comment cannot include "?"');
        }
        this._statements.push({
          grouping: "hintComments",
          value: hints
        });
        return this;
      },
      // Prepends the `schemaName` on `tableName` defined by `.table` and `.join`.
      withSchema(schemaName) {
        this._single.schema = schemaName;
        return this;
      },
      // Sets the `tableName` on the query.
      // Alias to "from" for select and "into" for insert statements
      // e.g. builder.insert({a: value}).into('tableName')
      // `options`: options object containing keys:
      //   - `only`: whether the query should use SQL's ONLY to not return
      //           inheriting table data. Defaults to false.
      table(tableName, options = {}) {
        this._single.table = tableName;
        this._single.only = options.only === true;
        return this;
      },
      // Adds a `distinct` clause to the query.
      distinct() {
        this._statements.push({
          grouping: "columns",
          value: helpers.normalizeArr.apply(null, arguments),
          distinct: true
        });
        return this;
      },
      distinctOn() {
        const value2 = helpers.normalizeArr.apply(null, arguments);
        if (isEmpty2(value2)) {
          throw new Error("distinctOn requires atleast on argument");
        }
        this._statements.push({
          grouping: "columns",
          value: value2,
          distinctOn: true
        });
        return this;
      },
      // Adds a join clause to the query, allowing for advanced joins
      // with an anonymous function as the second argument.
      // function(table, first, operator, second)
      join(table, first3) {
        let join3;
        const { schema: schema2 } = this._single;
        const joinType = this._joinType();
        if (typeof first3 === "function") {
          join3 = new JoinClause(table, joinType, schema2);
          first3.call(join3, join3);
        } else if (joinType === "raw") {
          join3 = new JoinClause(this.client.raw(table, first3), "raw");
        } else {
          join3 = new JoinClause(
            table,
            joinType,
            table instanceof Builder ? void 0 : schema2
          );
          if (arguments.length > 1) {
            join3.on.apply(join3, toArray2(arguments).slice(1));
          }
        }
        this._statements.push(join3);
        return this;
      },
      // JOIN blocks:
      innerJoin() {
        return this._joinType("inner").join.apply(this, arguments);
      },
      leftJoin() {
        return this._joinType("left").join.apply(this, arguments);
      },
      leftOuterJoin() {
        return this._joinType("left outer").join.apply(this, arguments);
      },
      rightJoin() {
        return this._joinType("right").join.apply(this, arguments);
      },
      rightOuterJoin() {
        return this._joinType("right outer").join.apply(this, arguments);
      },
      outerJoin() {
        return this._joinType("outer").join.apply(this, arguments);
      },
      fullOuterJoin() {
        return this._joinType("full outer").join.apply(this, arguments);
      },
      crossJoin() {
        return this._joinType("cross").join.apply(this, arguments);
      },
      joinRaw() {
        return this._joinType("raw").join.apply(this, arguments);
      },
      // The where function can be used in several ways:
      // The most basic is `where(key, value)`, which expands to
      // where key = value.
      where(column, operator, value2) {
        if (column === false || column === true) {
          return this.where(1, "=", column ? 1 : 0);
        }
        if (typeof column === "function") {
          return this.whereWrapped(column);
        }
        if (column instanceof Raw && arguments.length === 1)
          return this.whereRaw(column);
        if (isObject(column) && !(column instanceof Raw))
          return this._objectWhere(column);
        if (arguments.length === 2) {
          value2 = operator;
          operator = "=";
          if (value2 === null) {
            return this.whereNull(column);
          }
        }
        const checkOperator = `${operator}`.toLowerCase().trim();
        if (arguments.length === 3) {
          if (checkOperator === "in" || checkOperator === "not in") {
            return this._not(checkOperator === "not in").whereIn(
              arguments[0],
              arguments[2]
            );
          }
          if (checkOperator === "between" || checkOperator === "not between") {
            return this._not(checkOperator === "not between").whereBetween(
              arguments[0],
              arguments[2]
            );
          }
        }
        if (value2 === null) {
          if (checkOperator === "is" || checkOperator === "is not") {
            return this._not(checkOperator === "is not").whereNull(column);
          }
        }
        this._statements.push({
          grouping: "where",
          type: "whereBasic",
          column,
          operator,
          value: value2,
          not: this._not(),
          bool: this._bool(),
          asColumn: this._asColumnFlag
        });
        return this;
      },
      whereColumn(column, operator, rightColumn) {
        this._asColumnFlag = true;
        this.where.apply(this, arguments);
        this._asColumnFlag = false;
        return this;
      },
      // Adds an `or where` clause to the query.
      orWhere() {
        this._bool("or");
        const obj = arguments[0];
        if (isObject(obj) && !(obj instanceof Raw)) {
          return this.whereWrapped(function() {
            for (const key in obj) {
              this.andWhere(key, obj[key]);
            }
          });
        }
        return this.where.apply(this, arguments);
      },
      orWhereColumn() {
        this._bool("or");
        const obj = arguments[0];
        if (isObject(obj) && !(obj instanceof Raw)) {
          return this.whereWrapped(function() {
            for (const key in obj) {
              this.andWhereColumn(key, "=", obj[key]);
            }
          });
        }
        return this.whereColumn.apply(this, arguments);
      },
      // Adds an `not where` clause to the query.
      whereNot() {
        if (arguments.length >= 2) {
          if (arguments[1] === "in" || arguments[1] === "between") {
            this.client.logger.warn(
              'whereNot is not suitable for "in" and "between" type subqueries. You should use "not in" and "not between" instead.'
            );
          }
        }
        return this._not(true).where.apply(this, arguments);
      },
      whereNotColumn() {
        return this._not(true).whereColumn.apply(this, arguments);
      },
      // Adds an `or not where` clause to the query.
      orWhereNot() {
        return this._bool("or").whereNot.apply(this, arguments);
      },
      orWhereNotColumn() {
        return this._bool("or").whereNotColumn.apply(this, arguments);
      },
      // Processes an object literal provided in a "where" clause.
      _objectWhere(obj) {
        const boolVal = this._bool();
        const notVal = this._not() ? "Not" : "";
        for (const key in obj) {
          this[boolVal + "Where" + notVal](key, obj[key]);
        }
        return this;
      },
      // Adds a raw `where` clause to the query.
      whereRaw(sql, bindings) {
        const raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "where",
          type: "whereRaw",
          value: raw,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      orWhereRaw(sql, bindings) {
        return this._bool("or").whereRaw(sql, bindings);
      },
      // Helper for compiling any advanced `where` queries.
      whereWrapped(callback) {
        this._statements.push({
          grouping: "where",
          type: "whereWrapped",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds a `where exists` clause to the query.
      whereExists(callback) {
        this._statements.push({
          grouping: "where",
          type: "whereExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds an `or where exists` clause to the query.
      orWhereExists(callback) {
        return this._bool("or").whereExists(callback);
      },
      // Adds a `where not exists` clause to the query.
      whereNotExists(callback) {
        return this._not(true).whereExists(callback);
      },
      // Adds a `or where not exists` clause to the query.
      orWhereNotExists(callback) {
        return this._bool("or").whereNotExists(callback);
      },
      // Adds a `where in` clause to the query.
      whereIn(column, values2) {
        if (Array.isArray(values2) && isEmpty2(values2))
          return this.where(this._not());
        this._statements.push({
          grouping: "where",
          type: "whereIn",
          column,
          value: values2,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds a `or where in` clause to the query.
      orWhereIn(column, values2) {
        return this._bool("or").whereIn(column, values2);
      },
      // Adds a `where not in` clause to the query.
      whereNotIn(column, values2) {
        return this._not(true).whereIn(column, values2);
      },
      // Adds a `or where not in` clause to the query.
      orWhereNotIn(column, values2) {
        return this._bool("or")._not(true).whereIn(column, values2);
      },
      // Adds a `where null` clause to the query.
      whereNull(column) {
        this._statements.push({
          grouping: "where",
          type: "whereNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds a `or where null` clause to the query.
      orWhereNull(column) {
        return this._bool("or").whereNull(column);
      },
      // Adds a `where not null` clause to the query.
      whereNotNull(column) {
        return this._not(true).whereNull(column);
      },
      // Adds a `or where not null` clause to the query.
      orWhereNotNull(column) {
        return this._bool("or").whereNotNull(column);
      },
      // Adds a `where between` clause to the query.
      whereBetween(column, values2) {
        assert(
          Array.isArray(values2),
          "The second argument to whereBetween must be an array."
        );
        assert(
          values2.length === 2,
          "You must specify 2 values for the whereBetween clause"
        );
        this._statements.push({
          grouping: "where",
          type: "whereBetween",
          column,
          value: values2,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds a `where not between` clause to the query.
      whereNotBetween(column, values2) {
        return this._not(true).whereBetween(column, values2);
      },
      // Adds a `or where between` clause to the query.
      orWhereBetween(column, values2) {
        return this._bool("or").whereBetween(column, values2);
      },
      // Adds a `or where not between` clause to the query.
      orWhereNotBetween(column, values2) {
        return this._bool("or").whereNotBetween(column, values2);
      },
      // Adds a `group by` clause to the query.
      groupBy(item) {
        if (item instanceof Raw) {
          return this.groupByRaw.apply(this, arguments);
        }
        this._statements.push({
          grouping: "group",
          type: "groupByBasic",
          value: helpers.normalizeArr.apply(null, arguments)
        });
        return this;
      },
      // Adds a raw `group by` clause to the query.
      groupByRaw(sql, bindings) {
        const raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "group",
          type: "groupByRaw",
          value: raw
        });
        return this;
      },
      // Adds a `order by` clause to the query.
      orderBy(column, direction) {
        if (Array.isArray(column)) {
          return this._orderByArray(column);
        }
        this._statements.push({
          grouping: "order",
          type: "orderByBasic",
          value: column,
          direction
        });
        return this;
      },
      // Adds a `order by` with multiple columns to the query.
      _orderByArray(columnDefs) {
        for (let i = 0; i < columnDefs.length; i++) {
          const columnInfo = columnDefs[i];
          if (isObject(columnInfo)) {
            this._statements.push({
              grouping: "order",
              type: "orderByBasic",
              value: columnInfo["column"],
              direction: columnInfo["order"]
            });
          } else if (isString2(columnInfo)) {
            this._statements.push({
              grouping: "order",
              type: "orderByBasic",
              value: columnInfo
            });
          }
        }
        return this;
      },
      // Add a raw `order by` clause to the query.
      orderByRaw(sql, bindings) {
        const raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "order",
          type: "orderByRaw",
          value: raw
        });
        return this;
      },
      _union(clause, args) {
        let callbacks = args[0];
        let wrap = args[1];
        if (args.length === 1 || args.length === 2 && isBoolean2(wrap)) {
          if (!Array.isArray(callbacks)) {
            callbacks = [callbacks];
          }
          for (let i = 0, l = callbacks.length; i < l; i++) {
            this._statements.push({
              grouping: "union",
              clause,
              value: callbacks[i],
              wrap: wrap || false
            });
          }
        } else {
          callbacks = toArray2(args).slice(0, args.length - 1);
          wrap = args[args.length - 1];
          if (!isBoolean2(wrap)) {
            callbacks.push(wrap);
            wrap = false;
          }
          this._union(clause, [callbacks, wrap]);
        }
        return this;
      },
      // Add a union statement to the query.
      union(...args) {
        return this._union("union", args);
      },
      // Adds a union all statement to the query.
      unionAll(...args) {
        return this._union("union all", args);
      },
      // Adds an intersect statement to the query
      intersect(callbacks, wrap) {
        if (arguments.length === 1 || arguments.length === 2 && isBoolean2(wrap)) {
          if (!Array.isArray(callbacks)) {
            callbacks = [callbacks];
          }
          for (let i = 0, l = callbacks.length; i < l; i++) {
            this._statements.push({
              grouping: "union",
              clause: "intersect",
              value: callbacks[i],
              wrap: wrap || false
            });
          }
        } else {
          callbacks = toArray2(arguments).slice(0, arguments.length - 1);
          wrap = arguments[arguments.length - 1];
          if (!isBoolean2(wrap)) {
            callbacks.push(wrap);
            wrap = false;
          }
          this.intersect(callbacks, wrap);
        }
        return this;
      },
      // Adds a `having` clause to the query.
      having(column, operator, value2) {
        if (column instanceof Raw && arguments.length === 1) {
          return this.havingRaw(column);
        }
        if (typeof column === "function") {
          return this.havingWrapped(column);
        }
        this._statements.push({
          grouping: "having",
          type: "havingBasic",
          column,
          operator,
          value: value2,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      },
      orHaving: function orHaving() {
        this._bool("or");
        const obj = arguments[0];
        if (isObject(obj) && !(obj instanceof Raw)) {
          return this.havingWrapped(function() {
            for (const key in obj) {
              this.andHaving(key, obj[key]);
            }
          });
        }
        return this.having.apply(this, arguments);
      },
      // Helper for compiling any advanced `having` queries.
      havingWrapped(callback) {
        this._statements.push({
          grouping: "having",
          type: "havingWrapped",
          value: callback,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      },
      havingNull(column) {
        this._statements.push({
          grouping: "having",
          type: "havingNull",
          column,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      orHavingNull(callback) {
        return this._bool("or").havingNull(callback);
      },
      havingNotNull(callback) {
        return this._not(true).havingNull(callback);
      },
      orHavingNotNull(callback) {
        return this._not(true)._bool("or").havingNull(callback);
      },
      havingExists(callback) {
        this._statements.push({
          grouping: "having",
          type: "havingExists",
          value: callback,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      orHavingExists(callback) {
        return this._bool("or").havingExists(callback);
      },
      havingNotExists(callback) {
        return this._not(true).havingExists(callback);
      },
      orHavingNotExists(callback) {
        return this._not(true)._bool("or").havingExists(callback);
      },
      havingBetween(column, values2) {
        assert(
          Array.isArray(values2),
          "The second argument to havingBetween must be an array."
        );
        assert(
          values2.length === 2,
          "You must specify 2 values for the havingBetween clause"
        );
        this._statements.push({
          grouping: "having",
          type: "havingBetween",
          column,
          value: values2,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      orHavingBetween(column, values2) {
        return this._bool("or").havingBetween(column, values2);
      },
      havingNotBetween(column, values2) {
        return this._not(true).havingBetween(column, values2);
      },
      orHavingNotBetween(column, values2) {
        return this._not(true)._bool("or").havingBetween(column, values2);
      },
      havingIn(column, values2) {
        if (Array.isArray(values2) && isEmpty2(values2))
          return this.where(this._not());
        this._statements.push({
          grouping: "having",
          type: "havingIn",
          column,
          value: values2,
          not: this._not(),
          bool: this._bool()
        });
        return this;
      },
      // Adds a `or where in` clause to the query.
      orHavingIn(column, values2) {
        return this._bool("or").havingIn(column, values2);
      },
      // Adds a `where not in` clause to the query.
      havingNotIn(column, values2) {
        return this._not(true).havingIn(column, values2);
      },
      // Adds a `or where not in` clause to the query.
      orHavingNotIn(column, values2) {
        return this._bool("or")._not(true).havingIn(column, values2);
      },
      // Adds a raw `having` clause to the query.
      havingRaw(sql, bindings) {
        const raw = sql instanceof Raw ? sql : this.client.raw(sql, bindings);
        this._statements.push({
          grouping: "having",
          type: "havingRaw",
          value: raw,
          bool: this._bool(),
          not: this._not()
        });
        return this;
      },
      orHavingRaw(sql, bindings) {
        return this._bool("or").havingRaw(sql, bindings);
      },
      // Only allow a single "offset" to be set for the current query.
      offset(value2) {
        if (value2 == null || value2 instanceof Raw || value2 instanceof Builder) {
          this._single.offset = value2;
        } else {
          const val = parseInt(value2, 10);
          if (isNaN(val)) {
            this.client.logger.warn("A valid integer must be provided to offset");
          } else {
            this._single.offset = val;
          }
        }
        return this;
      },
      // Only allow a single "limit" to be set for the current query.
      limit(value2) {
        const val = parseInt(value2, 10);
        if (isNaN(val)) {
          this.client.logger.warn("A valid integer must be provided to limit");
        } else {
          this._single.limit = val;
        }
        return this;
      },
      // Retrieve the "count" result of the query.
      count(column, options) {
        return this._aggregate("count", column || "*", options);
      },
      // Retrieve the minimum value of a given column.
      min(column, options) {
        return this._aggregate("min", column, options);
      },
      // Retrieve the maximum value of a given column.
      max(column, options) {
        return this._aggregate("max", column, options);
      },
      // Retrieve the sum of the values of a given column.
      sum(column, options) {
        return this._aggregate("sum", column, options);
      },
      // Retrieve the average of the values of a given column.
      avg(column, options) {
        return this._aggregate("avg", column, options);
      },
      // Retrieve the "count" of the distinct results of the query.
      countDistinct() {
        let columns = helpers.normalizeArr.apply(null, arguments);
        let options;
        if (columns.length > 1 && isPlainObject4(last3(columns))) {
          [options] = columns.splice(columns.length - 1, 1);
        }
        if (!columns.length) {
          columns = "*";
        } else if (columns.length === 1) {
          columns = columns[0];
        }
        return this._aggregate("count", columns, { ...options, distinct: true });
      },
      // Retrieve the sum of the distinct values of a given column.
      sumDistinct(column, options) {
        return this._aggregate("sum", column, { ...options, distinct: true });
      },
      // Retrieve the vg of the distinct results of the query.
      avgDistinct(column, options) {
        return this._aggregate("avg", column, { ...options, distinct: true });
      },
      // Increments a column's value by the specified amount.
      increment(column, amount = 1) {
        if (isObject(column)) {
          for (const key in column) {
            this._counter(key, column[key]);
          }
          return this;
        }
        return this._counter(column, amount);
      },
      // Decrements a column's value by the specified amount.
      decrement(column, amount = 1) {
        if (isObject(column)) {
          for (const key in column) {
            this._counter(key, -column[key]);
          }
          return this;
        }
        return this._counter(column, -amount);
      },
      // Clears increments/decrements
      clearCounters() {
        this._single.counter = {};
        return this;
      },
      // Sets the values for a `select` query, informing that only the first
      // row should be returned (limit 1).
      first() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .first() on "${this._method}" query!`);
        }
        const args = new Array(arguments.length);
        for (let i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        this.select.apply(this, args);
        this._method = "first";
        this.limit(1);
        return this;
      },
      // Use existing connection to execute the query
      // Same value that client.acquireConnection() for an according client returns should be passed
      connection(_connection) {
        this._connection = _connection;
        return this;
      },
      // Pluck a column from a query.
      pluck(column) {
        this._method = "pluck";
        this._single.pluck = column;
        this._statements.push({
          grouping: "columns",
          type: "pluck",
          value: column
        });
        return this;
      },
      // Deprecated. Remove everything from select clause
      clearSelect() {
        this._clearGrouping("columns");
        return this;
      },
      // Deprecated. Remove everything from where clause
      clearWhere() {
        this._clearGrouping("where");
        return this;
      },
      // Deprecated. Remove everything from group clause
      clearGroup() {
        this._clearGrouping("group");
        return this;
      },
      // Deprecated. Remove everything from order clause
      clearOrder() {
        this._clearGrouping("order");
        return this;
      },
      // Deprecated. Remove everything from having clause
      clearHaving() {
        this._clearGrouping("having");
        return this;
      },
      // Remove everything from statement clause
      clear(statement) {
        if (!["with", "select", "columns", "hintComments", "where", "union", "join", "group", "order", "having", "limit", "offset", "counter", "counters"].includes(statement))
          throw new Error(`Knex Error: unknown statement '${statement}'`);
        if (statement.startsWith("counter"))
          return this.clearCounters();
        if (statement === "select") {
          statement = "columns";
        }
        this._clearGrouping(statement);
        return this;
      },
      // Insert & Update
      // ------
      // Sets the values for an `insert` query.
      insert(values2, returning, options) {
        this._method = "insert";
        if (!isEmpty2(returning))
          this.returning(returning, options);
        this._single.insert = values2;
        return this;
      },
      // Sets the values for an `update`, allowing for both
      // `.update(key, value, [returning])` and `.update(obj, [returning])` syntaxes.
      update(values2, returning, options) {
        let ret;
        const obj = this._single.update || {};
        this._method = "update";
        if (isString2(values2)) {
          obj[values2] = returning;
          if (arguments.length > 2) {
            ret = arguments[2];
          }
        } else {
          const keys2 = Object.keys(values2);
          if (this._single.update) {
            this.client.logger.warn("Update called multiple times with objects.");
          }
          let i = -1;
          while (++i < keys2.length) {
            obj[keys2[i]] = values2[keys2[i]];
          }
          ret = arguments[1];
        }
        if (!isEmpty2(ret))
          this.returning(ret, options);
        this._single.update = obj;
        return this;
      },
      // Sets the returning value for the query.
      returning(returning, options) {
        this._single.returning = returning;
        this._single.options = options;
        return this;
      },
      onConflict(columns) {
        if (typeof columns === "string") {
          columns = [columns];
        }
        return new OnConflictBuilder(this, columns || true);
      },
      // Delete
      // ------
      // Executes a delete statement on the query;
      delete(ret, options) {
        this._method = "del";
        if (!isEmpty2(ret))
          this.returning(ret, options);
        return this;
      },
      // Truncates a table, ends the query chain.
      truncate(tableName) {
        this._method = "truncate";
        if (tableName) {
          this._single.table = tableName;
        }
        return this;
      },
      // Retrieves columns for the table specified by `knex(tableName)`
      columnInfo(column) {
        this._method = "columnInfo";
        this._single.columnInfo = column;
        return this;
      },
      // Set a lock for update constraint.
      forUpdate() {
        this._single.lock = lockMode.forUpdate;
        this._single.lockTables = helpers.normalizeArr.apply(null, arguments);
        return this;
      },
      // Set a lock for share constraint.
      forShare() {
        this._single.lock = lockMode.forShare;
        this._single.lockTables = helpers.normalizeArr.apply(null, arguments);
        return this;
      },
      // Skips locked rows when using a lock constraint.
      skipLocked() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .skipLocked() on "${this._method}" query!`);
        }
        if (!this._hasLockMode()) {
          throw new Error(
            ".skipLocked() can only be used after a call to .forShare() or .forUpdate()!"
          );
        }
        if (this._single.waitMode === waitMode.noWait) {
          throw new Error(".skipLocked() cannot be used together with .noWait()!");
        }
        this._single.waitMode = waitMode.skipLocked;
        return this;
      },
      // Causes error when acessing a locked row instead of waiting for it to be released.
      noWait() {
        if (!this._isSelectQuery()) {
          throw new Error(`Cannot chain .noWait() on "${this._method}" query!`);
        }
        if (!this._hasLockMode()) {
          throw new Error(
            ".noWait() can only be used after a call to .forShare() or .forUpdate()!"
          );
        }
        if (this._single.waitMode === waitMode.skipLocked) {
          throw new Error(".noWait() cannot be used together with .skipLocked()!");
        }
        this._single.waitMode = waitMode.noWait;
        return this;
      },
      // Takes a JS object of methods to call and calls them
      fromJS(obj) {
        each(obj, (val, key) => {
          if (typeof this[key] !== "function") {
            this.client.logger.warn(`Knex Error: unknown key ${key}`);
          }
          if (Array.isArray(val)) {
            this[key].apply(this, val);
          } else {
            this[key](val);
          }
        });
        return this;
      },
      // Passes query to provided callback function, useful for e.g. composing
      // domain-specific helpers
      modify(callback) {
        callback.apply(this, [this].concat(tail(arguments)));
        return this;
      },
      // ----------------------------------------------------------------------
      // Helper for the incrementing/decrementing queries.
      _counter(column, amount) {
        amount = parseFloat(amount);
        this._method = "update";
        this._single.counter = this._single.counter || {};
        this._single.counter[column] = amount;
        return this;
      },
      // Helper to get or set the "boolFlag" value.
      _bool(val) {
        if (arguments.length === 1) {
          this._boolFlag = val;
          return this;
        }
        const ret = this._boolFlag;
        this._boolFlag = "and";
        return ret;
      },
      // Helper to get or set the "notFlag" value.
      _not(val) {
        if (arguments.length === 1) {
          this._notFlag = val;
          return this;
        }
        const ret = this._notFlag;
        this._notFlag = false;
        return ret;
      },
      // Helper to get or set the "joinFlag" value.
      _joinType(val) {
        if (arguments.length === 1) {
          this._joinFlag = val;
          return this;
        }
        const ret = this._joinFlag || "inner";
        this._joinFlag = "inner";
        return ret;
      },
      // Helper for compiling any aggregate queries.
      _aggregate(method, column, options = {}) {
        this._statements.push({
          grouping: "columns",
          type: column instanceof Raw ? "aggregateRaw" : "aggregate",
          method,
          value: column,
          aggregateDistinct: options.distinct || false,
          alias: options.as
        });
        return this;
      },
      // Helper function for clearing or reseting a grouping type from the builder
      _clearGrouping(grouping) {
        if (grouping in this._single) {
          this._single[grouping] = void 0;
        } else {
          this._statements = reject(this._statements, { grouping });
        }
      },
      // Helper function that checks if the builder will emit a select query
      _isSelectQuery() {
        return ["pluck", "first", "select"].includes(this._method);
      },
      // Helper function that checks if the query has a lock mode set
      _hasLockMode() {
        return [lockMode.forShare, lockMode.forUpdate].includes(this._single.lock);
      }
    });
    Object.defineProperty(Builder.prototype, "or", {
      get() {
        return this._bool("or");
      }
    });
    Object.defineProperty(Builder.prototype, "not", {
      get() {
        return this._not(true);
      }
    });
    Builder.prototype.select = Builder.prototype.columns;
    Builder.prototype.column = Builder.prototype.columns;
    Builder.prototype.andWhereNot = Builder.prototype.whereNot;
    Builder.prototype.andWhereNotColumn = Builder.prototype.whereNotColumn;
    Builder.prototype.andWhere = Builder.prototype.where;
    Builder.prototype.andWhereColumn = Builder.prototype.whereColumn;
    Builder.prototype.andWhereRaw = Builder.prototype.whereRaw;
    Builder.prototype.andWhereBetween = Builder.prototype.whereBetween;
    Builder.prototype.andWhereNotBetween = Builder.prototype.whereNotBetween;
    Builder.prototype.andHaving = Builder.prototype.having;
    Builder.prototype.andHavingIn = Builder.prototype.havingIn;
    Builder.prototype.andHavingNotIn = Builder.prototype.havingNotIn;
    Builder.prototype.andHavingNull = Builder.prototype.havingNull;
    Builder.prototype.andHavingNotNull = Builder.prototype.havingNotNull;
    Builder.prototype.andHavingExists = Builder.prototype.havingExists;
    Builder.prototype.andHavingNotExists = Builder.prototype.havingNotExists;
    Builder.prototype.andHavingBetween = Builder.prototype.havingBetween;
    Builder.prototype.andHavingNotBetween = Builder.prototype.havingNotBetween;
    Builder.prototype.from = Builder.prototype.table;
    Builder.prototype.into = Builder.prototype.table;
    Builder.prototype.del = Builder.prototype.delete;
    require_interface()(Builder);
    helpers.addQueryContext(Builder);
    Builder.extend = (methodName, fn) => {
      if (Object.prototype.hasOwnProperty.call(Builder.prototype, methodName)) {
        throw new Error(
          `Can't extend QueryBuilder with existing method ('${methodName}').`
        );
      }
      assign(Builder.prototype, { [methodName]: fn });
    };
    module2.exports = Builder;
  }
});

// ../node_modules/knex/lib/formatter.js
var require_formatter = __commonJS({
  "../node_modules/knex/lib/formatter.js"(exports, module2) {
    "use strict";
    var QueryBuilder = require_builder();
    var Raw = require_raw();
    var transform = require("lodash/transform");
    var orderBys = ["asc", "desc"];
    var operators = transform(
      [
        "=",
        "<",
        ">",
        "<=",
        ">=",
        "<>",
        "!=",
        "like",
        "not like",
        "between",
        "not between",
        "ilike",
        "not ilike",
        "exists",
        "not exist",
        "rlike",
        "not rlike",
        "regexp",
        "not regexp",
        "&",
        "|",
        "^",
        "<<",
        ">>",
        "~",
        "~*",
        "!~",
        "!~*",
        "#",
        "&&",
        "@>",
        "<@",
        "||",
        "&<",
        "&>",
        "-|-",
        "@@",
        "!!",
        ["?", "\\?"],
        ["?|", "\\?|"],
        ["?&", "\\?&"]
      ],
      (result, key) => {
        if (Array.isArray(key)) {
          result[key[0]] = key[1];
        } else {
          result[key] = key;
        }
      },
      {}
    );
    var Formatter = class {
      constructor(client, builder) {
        this.client = client;
        this.builder = builder;
        this.bindings = [];
      }
      // Accepts a string or array of columns to wrap as appropriate.
      columnize(target) {
        const columns = Array.isArray(target) ? target : [target];
        let str = "", i = -1;
        while (++i < columns.length) {
          if (i > 0)
            str += ", ";
          str += this.wrap(columns[i]);
        }
        return str;
      }
      // Turns a list of values into a list of ?'s, joining them with commas unless
      // a "joining" value is specified (e.g. ' and ')
      parameterize(values2, notSetValue) {
        if (typeof values2 === "function")
          return this.parameter(values2);
        values2 = Array.isArray(values2) ? values2 : [values2];
        let str = "", i = -1;
        while (++i < values2.length) {
          if (i > 0)
            str += ", ";
          str += this.parameter(values2[i] === void 0 ? notSetValue : values2[i]);
        }
        return str;
      }
      // Formats `values` into a parenthesized list of parameters for a `VALUES`
      // clause.
      //
      // [1, 2]                  -> '(?, ?)'
      // [[1, 2], [3, 4]]        -> '((?, ?), (?, ?))'
      // knex('table')           -> '(select * from "table")'
      // knex.raw('select ?', 1) -> '(select ?)'
      //
      values(values2) {
        if (Array.isArray(values2)) {
          if (Array.isArray(values2[0])) {
            return `(${values2.map((value2) => `(${this.parameterize(value2)})`).join(", ")})`;
          }
          return `(${this.parameterize(values2)})`;
        }
        if (values2 instanceof Raw) {
          return `(${this.parameter(values2)})`;
        }
        return this.parameter(values2);
      }
      // Checks whether a value is a function... if it is, we compile it
      // otherwise we check whether it's a raw
      parameter(value2) {
        if (typeof value2 === "function") {
          return this.outputQuery(this.compileCallback(value2), true);
        }
        return this.unwrapRaw(value2, true) || "?";
      }
      unwrapRaw(value2, isParameter) {
        let query;
        if (value2 instanceof QueryBuilder) {
          query = this.client.queryCompiler(value2).toSQL();
          if (query.bindings) {
            this.bindings = this.bindings.concat(query.bindings);
          }
          return this.outputQuery(query, isParameter);
        }
        if (value2 instanceof Raw) {
          value2.client = this.client;
          if (this.builder._queryContext) {
            value2.queryContext = () => {
              return this.builder._queryContext;
            };
          }
          query = value2.toSQL();
          if (query.bindings) {
            this.bindings = this.bindings.concat(query.bindings);
          }
          return query.sql;
        }
        if (isParameter) {
          this.bindings.push(value2);
        }
      }
      /**
       * Creates SQL for a parameter, which might be passed to where() or .with() or
       * pretty much anywhere in API.
       *
       * @param query Callback (for where or complete builder), Raw or QueryBuilder
       * @param method Optional at least 'select' or 'update' are valid
       */
      rawOrFn(value2, method) {
        if (typeof value2 === "function") {
          return this.outputQuery(this.compileCallback(value2, method));
        }
        return this.unwrapRaw(value2) || "";
      }
      // Puts the appropriate wrapper around a value depending on the database
      // engine, unless it's a knex.raw value, in which case it's left alone.
      wrap(value2, isParameter) {
        const raw = this.unwrapRaw(value2, isParameter);
        if (raw)
          return raw;
        switch (typeof value2) {
          case "function":
            return this.outputQuery(this.compileCallback(value2), true);
          case "object":
            return this.parseObject(value2);
          case "number":
            return value2;
          default:
            return this.wrapString(value2 + "");
        }
      }
      wrapAsIdentifier(value2) {
        const queryContext = this.builder.queryContext();
        return this.client.wrapIdentifier((value2 || "").trim(), queryContext);
      }
      alias(first3, second) {
        return first3 + " as " + second;
      }
      operator(value2) {
        const raw = this.unwrapRaw(value2);
        if (raw)
          return raw;
        const operator = operators[(value2 || "").toLowerCase()];
        if (!operator) {
          throw new TypeError(`The operator "${value2}" is not permitted`);
        }
        return operator;
      }
      // Specify the direction of the ordering.
      direction(value2) {
        const raw = this.unwrapRaw(value2);
        if (raw)
          return raw;
        return orderBys.indexOf((value2 || "").toLowerCase()) !== -1 ? value2 : "asc";
      }
      // Compiles a callback using the query builder.
      compileCallback(callback, method) {
        const { client } = this;
        const builder = client.queryBuilder();
        callback.call(builder, builder);
        const compiler = client.queryCompiler(builder);
        compiler.formatter = this;
        return compiler.toSQL(method || builder._method || "select");
      }
      // Ensures the query is aliased if necessary.
      outputQuery(compiled, isParameter) {
        let sql = compiled.sql || "";
        if (sql) {
          if ((compiled.method === "select" || compiled.method === "first") && (isParameter || compiled.as)) {
            sql = `(${sql})`;
            if (compiled.as)
              return this.alias(sql, this.wrap(compiled.as));
          }
        }
        return sql;
      }
      // Key-value notation for alias
      parseObject(obj) {
        const ret = [];
        for (const alias in obj) {
          const queryOrIdentifier = obj[alias];
          if (typeof queryOrIdentifier === "function") {
            const compiled = this.compileCallback(queryOrIdentifier);
            compiled.as = alias;
            ret.push(this.outputQuery(compiled, true));
          } else if (queryOrIdentifier instanceof QueryBuilder) {
            ret.push(
              this.alias(
                `(${this.wrap(queryOrIdentifier)})`,
                this.wrapAsIdentifier(alias)
              )
            );
          } else {
            ret.push(
              this.alias(this.wrap(queryOrIdentifier), this.wrapAsIdentifier(alias))
            );
          }
        }
        return ret.join(", ");
      }
      // Coerce to string to prevent strange errors when it's not a string.
      wrapString(value2) {
        const asIndex = value2.toLowerCase().indexOf(" as ");
        if (asIndex !== -1) {
          const first3 = value2.slice(0, asIndex);
          const second = value2.slice(asIndex + 4);
          return this.alias(this.wrap(first3), this.wrapAsIdentifier(second));
        }
        const wrapped = [];
        let i = -1;
        const segments = value2.split(".");
        while (++i < segments.length) {
          value2 = segments[i];
          if (i === 0 && segments.length > 1) {
            wrapped.push(this.wrap((value2 || "").trim()));
          } else {
            wrapped.push(this.wrapAsIdentifier(value2));
          }
        }
        return wrapped.join(".");
      }
    };
    module2.exports = Formatter;
  }
});

// ../node_modules/knex/lib/migrate/table-resolver.js
var require_table_resolver = __commonJS({
  "../node_modules/knex/lib/migrate/table-resolver.js"(exports, module2) {
    "use strict";
    function getTableName(tableName, schemaName) {
      return schemaName ? `${schemaName}.${tableName}` : tableName;
    }
    function getTable(trxOrKnex, tableName, schemaName) {
      return schemaName ? trxOrKnex(tableName).withSchema(schemaName) : trxOrKnex(tableName);
    }
    function getLockTableName(tableName) {
      return tableName + "_lock";
    }
    function getLockTableNameWithSchema(tableName, schemaName) {
      return schemaName ? schemaName + "." + getLockTableName(tableName) : getLockTableName(tableName);
    }
    module2.exports = {
      getLockTableName,
      getLockTableNameWithSchema,
      getTable,
      getTableName
    };
  }
});

// ../node_modules/knex/lib/migrate/table-creator.js
var require_table_creator = __commonJS({
  "../node_modules/knex/lib/migrate/table-creator.js"(exports, module2) {
    "use strict";
    var {
      getTable,
      getLockTableName,
      getLockTableNameWithSchema,
      getTableName
    } = require_table_resolver();
    function ensureTable(tableName, schemaName, trxOrKnex) {
      const lockTable = getLockTableName(tableName);
      const lockTableWithSchema = getLockTableNameWithSchema(tableName, schemaName);
      return getSchemaBuilder(trxOrKnex, schemaName).hasTable(tableName).then((exists) => {
        return !exists && _createMigrationTable(tableName, schemaName, trxOrKnex);
      }).then(() => {
        return getSchemaBuilder(trxOrKnex, schemaName).hasTable(lockTable);
      }).then((exists) => {
        return !exists && _createMigrationLockTable(lockTable, schemaName, trxOrKnex);
      }).then(() => {
        return getTable(trxOrKnex, lockTable, schemaName).select("*");
      }).then((data) => {
        return !data.length && trxOrKnex.into(lockTableWithSchema).insert({ is_locked: 0 });
      });
    }
    function _createMigrationTable(tableName, schemaName, trxOrKnex) {
      return getSchemaBuilder(trxOrKnex, schemaName).createTable(
        getTableName(tableName),
        function(t2) {
          t2.increments();
          t2.string("name");
          t2.integer("batch");
          t2.timestamp("migration_time");
        }
      );
    }
    function _createMigrationLockTable(tableName, schemaName, trxOrKnex) {
      return getSchemaBuilder(trxOrKnex, schemaName).createTable(
        tableName,
        function(t2) {
          t2.increments("index").primary();
          t2.integer("is_locked");
        }
      );
    }
    function getSchemaBuilder(trxOrKnex, schemaName) {
      return schemaName ? trxOrKnex.schema.withSchema(schemaName) : trxOrKnex.schema;
    }
    module2.exports = {
      ensureTable,
      getSchemaBuilder
    };
  }
});

// ../node_modules/knex/lib/migrate/migration-list-resolver.js
var require_migration_list_resolver = __commonJS({
  "../node_modules/knex/lib/migrate/migration-list-resolver.js"(exports, module2) {
    "use strict";
    var { getTableName } = require_table_resolver();
    var { ensureTable } = require_table_creator();
    function listAll(migrationSource, loadExtensions) {
      return migrationSource.getMigrations(loadExtensions);
    }
    async function listCompleted(tableName, schemaName, trxOrKnex) {
      await ensureTable(tableName, schemaName, trxOrKnex);
      const completedMigrations = await trxOrKnex.from(getTableName(tableName, schemaName)).orderBy("id").select("name");
      return completedMigrations.map((migration) => {
        return migration.name;
      });
    }
    function listAllAndCompleted(config2, trxOrKnex) {
      return Promise.all([
        listAll(config2.migrationSource, config2.loadExtensions),
        listCompleted(config2.tableName, config2.schemaName, trxOrKnex)
      ]);
    }
    module2.exports = {
      listAll,
      listAllAndCompleted,
      listCompleted
    };
  }
});

// ../node_modules/knex/lib/util/fs.js
var require_fs = __commonJS({
  "../node_modules/knex/lib/util/fs.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var flatten3 = require("lodash/flatten");
    var os = require("os");
    var path = require("path");
    var { promisify } = require("util");
    var stat = promisify(fs.stat);
    var readFile = promisify(fs.readFile);
    var writeFile = promisify(fs.writeFile);
    var readdir = promisify(fs.readdir);
    var mkdir = promisify(fs.mkdir);
    function createTemp() {
      return promisify(fs.mkdtemp)(`${os.tmpdir()}${path.sep}`);
    }
    function ensureDirectoryExists(dir) {
      return stat(dir).catch(() => mkdir(dir, { recursive: true }));
    }
    async function getFilepathsInFolder(dir, recursive = false) {
      const pathsList = await readdir(dir);
      return flatten3(
        await Promise.all(
          pathsList.sort().map(async (currentPath) => {
            const currentFile = path.resolve(dir, currentPath);
            const statFile = await stat(currentFile);
            if (statFile && statFile.isDirectory()) {
              if (recursive) {
                return await getFilepathsInFolder(currentFile, true);
              }
              return [];
            }
            return [currentFile];
          })
        )
      );
    }
    module2.exports = {
      stat,
      readdir,
      readFile,
      writeFile,
      createTemp,
      ensureDirectoryExists,
      getFilepathsInFolder
    };
  }
});

// ../node_modules/knex/lib/util/template.js
var require_template = __commonJS({
  "../node_modules/knex/lib/util/template.js"(exports, module2) {
    "use strict";
    var template = require("lodash/template");
    var { readFile, writeFile } = require_fs();
    var jsSourceTemplate = (content, options) => template(content, {
      interpolate: /<%=([\s\S]+?)%>/g,
      ...options
    });
    var jsFileTemplate = async (filePath, options) => {
      const contentBuffer = await readFile(filePath);
      return jsSourceTemplate(contentBuffer.toString(), options);
    };
    var writeJsFileUsingTemplate = async (targetFilePath, sourceFilePath, options, variables) => writeFile(
      targetFilePath,
      (await jsFileTemplate(sourceFilePath, options))(variables)
    );
    module2.exports = {
      jsSourceTemplate,
      jsFileTemplate,
      writeJsFileUsingTemplate
    };
  }
});

// ../node_modules/knex/lib/util/is-module-type.js
var require_is_module_type = __commonJS({
  "../node_modules/knex/lib/util/is-module-type.js"(exports, module2) {
    "use strict";
    var { readFile } = require_fs();
    module2.exports = async function isModuleType(filepath) {
      if (process.env.npm_package_json) {
        const packageJson = JSON.parse(
          await readFile(process.env.npm_package_json, "utf-8")
        );
        if (packageJson.type === "module") {
          return true;
        }
      }
      return process.env.npm_package_type === "module" || filepath.endsWith(".mjs");
    };
  }
});

// ../node_modules/knex/lib/util/import-file.js
var require_import_file = __commonJS({
  "../node_modules/knex/lib/util/import-file.js"(exports, module2) {
    "use strict";
    var isModuleType = require_is_module_type();
    module2.exports = async function importFile(filepath) {
      return await isModuleType(filepath) ? import(require("url").pathToFileURL(filepath)) : require(filepath);
    };
  }
});

// ../node_modules/knex/lib/migrate/sources/fs-migrations.js
var require_fs_migrations = __commonJS({
  "../node_modules/knex/lib/migrate/sources/fs-migrations.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var sortBy2 = require("lodash/sortBy");
    var { readdir } = require_fs();
    var DEFAULT_LOAD_EXTENSIONS = Object.freeze([
      ".co",
      ".coffee",
      ".eg",
      ".iced",
      ".js",
      ".cjs",
      ".litcoffee",
      ".ls",
      ".ts"
    ]);
    var FsMigrations = class {
      constructor(migrationDirectories, sortDirsSeparately, loadExtensions) {
        this.sortDirsSeparately = sortDirsSeparately;
        if (!Array.isArray(migrationDirectories)) {
          migrationDirectories = [migrationDirectories];
        }
        this.migrationsPaths = migrationDirectories;
        this.loadExtensions = loadExtensions || DEFAULT_LOAD_EXTENSIONS;
      }
      /**
       * Gets the migration names
       * @returns Promise<string[]>
       */
      getMigrations(loadExtensions) {
        const readMigrationsPromises = this.migrationsPaths.map((configDir) => {
          const absoluteDir = path.resolve(process.cwd(), configDir);
          return readdir(absoluteDir).then((files) => ({
            files,
            configDir,
            absoluteDir
          }));
        });
        return Promise.all(readMigrationsPromises).then((allMigrations) => {
          const migrations = allMigrations.reduce((acc, migrationDirectory) => {
            if (this.sortDirsSeparately) {
              migrationDirectory.files = migrationDirectory.files.sort();
            }
            migrationDirectory.files.forEach(
              (file) => acc.push({ file, directory: migrationDirectory.configDir })
            );
            return acc;
          }, []);
          if (this.sortDirsSeparately) {
            return filterMigrations(
              this,
              migrations,
              loadExtensions || this.loadExtensions
            );
          }
          return filterMigrations(
            this,
            sortBy2(migrations, "file"),
            loadExtensions || this.loadExtensions
          );
        });
      }
      getMigrationName(migration) {
        return migration.file;
      }
      getMigration(migration) {
        const absoluteDir = path.resolve(process.cwd(), migration.directory);
        const _path = path.join(absoluteDir, migration.file);
        const importFile = require_import_file();
        return importFile(_path);
      }
    };
    function filterMigrations(migrationSource, migrations, loadExtensions) {
      return migrations.filter((migration) => {
        const migrationName = migrationSource.getMigrationName(migration);
        const extension = path.extname(migrationName);
        return loadExtensions.includes(extension);
      });
    }
    module2.exports = {
      DEFAULT_LOAD_EXTENSIONS,
      FsMigrations
    };
  }
});

// ../node_modules/colorette/index.cjs
var require_colorette = __commonJS({
  "../node_modules/colorette/index.cjs"(exports) {
    "use strict";
    var enabled = !("NO_COLOR" in process.env) && ("FORCE_COLOR" in process.env || process.platform === "win32" || process.stdout != null && process.stdout.isTTY && process.env.TERM && process.env.TERM !== "dumb");
    var raw = (open, close, searchRegex, replaceValue) => (s) => enabled ? open + (~(s += "").indexOf(close, 4) ? s.replace(searchRegex, replaceValue) : s) + close : s;
    var init = (open, close) => {
      return raw(
        `\x1B[${open}m`,
        `\x1B[${close}m`,
        new RegExp(`\\x1b\\[${close}m`, "g"),
        `\x1B[${open}m`
      );
    };
    exports.options = Object.defineProperty({}, "enabled", {
      get: () => enabled,
      set: (value2) => enabled = value2
    });
    exports.reset = init(0, 0);
    exports.bold = raw("\x1B[1m", "\x1B[22m", /\x1b\[22m/g, "\x1B[22m\x1B[1m");
    exports.dim = raw("\x1B[2m", "\x1B[22m", /\x1b\[22m/g, "\x1B[22m\x1B[2m");
    exports.italic = init(3, 23);
    exports.underline = init(4, 24);
    exports.inverse = init(7, 27);
    exports.hidden = init(8, 28);
    exports.strikethrough = init(9, 29);
    exports.black = init(30, 39);
    exports.red = init(31, 39);
    exports.green = init(32, 39);
    exports.yellow = init(33, 39);
    exports.blue = init(34, 39);
    exports.magenta = init(35, 39);
    exports.cyan = init(36, 39);
    exports.white = init(37, 39);
    exports.gray = init(90, 39);
    exports.bgBlack = init(40, 49);
    exports.bgRed = init(41, 49);
    exports.bgGreen = init(42, 49);
    exports.bgYellow = init(43, 49);
    exports.bgBlue = init(44, 49);
    exports.bgMagenta = init(45, 49);
    exports.bgCyan = init(46, 49);
    exports.bgWhite = init(47, 49);
    exports.blackBright = init(90, 39);
    exports.redBright = init(91, 39);
    exports.greenBright = init(92, 39);
    exports.yellowBright = init(93, 39);
    exports.blueBright = init(94, 39);
    exports.magentaBright = init(95, 39);
    exports.cyanBright = init(96, 39);
    exports.whiteBright = init(97, 39);
    exports.bgBlackBright = init(100, 49);
    exports.bgRedBright = init(101, 49);
    exports.bgGreenBright = init(102, 49);
    exports.bgYellowBright = init(103, 49);
    exports.bgBlueBright = init(104, 49);
    exports.bgMagentaBright = init(105, 49);
    exports.bgCyanBright = init(106, 49);
    exports.bgWhiteBright = init(107, 49);
  }
});

// ../node_modules/knex/lib/logger.js
var require_logger = __commonJS({
  "../node_modules/knex/lib/logger.js"(exports, module2) {
    "use strict";
    var color = require_colorette();
    var { inspect } = require("util");
    var { isString: isString2, isFunction } = require_is();
    var Logger = class {
      constructor(config2 = {}) {
        const {
          log: {
            debug,
            warn,
            error,
            deprecate,
            inspectionDepth,
            enableColors
          } = {}
        } = config2;
        this._inspectionDepth = inspectionDepth || 5;
        this._enableColors = resolveIsEnabledColors(enableColors);
        this._debug = debug;
        this._warn = warn;
        this._error = error;
        this._deprecate = deprecate;
      }
      _log(message, userFn, colorFn) {
        if (userFn != null && !isFunction(userFn)) {
          throw new TypeError("Extensions to knex logger must be functions!");
        }
        if (isFunction(userFn)) {
          userFn(message);
          return;
        }
        if (!isString2(message)) {
          message = inspect(message, {
            depth: this._inspectionDepth,
            colors: this._enableColors
          });
        }
        console.log(colorFn ? colorFn(message) : message);
      }
      debug(message) {
        this._log(message, this._debug);
      }
      warn(message) {
        this._log(message, this._warn, color.yellow);
      }
      error(message) {
        this._log(message, this._error, color.red);
      }
      deprecate(method, alternative) {
        const message = `${method} is deprecated, please use ${alternative}`;
        this._log(message, this._deprecate, color.yellow);
      }
    };
    function resolveIsEnabledColors(enableColorsParam) {
      if (enableColorsParam != null) {
        return enableColorsParam;
      }
      if (process && process.stdout) {
        return process.stdout.isTTY;
      }
      return false;
    }
    module2.exports = Logger;
  }
});

// ../node_modules/knex/lib/migrate/configuration-merger.js
var require_configuration_merger = __commonJS({
  "../node_modules/knex/lib/migrate/configuration-merger.js"(exports, module2) {
    "use strict";
    var {
      FsMigrations,
      DEFAULT_LOAD_EXTENSIONS
    } = require_fs_migrations();
    var Logger = require_logger();
    var defaultLogger = new Logger();
    var CONFIG_DEFAULT = Object.freeze({
      extension: "js",
      loadExtensions: DEFAULT_LOAD_EXTENSIONS,
      tableName: "knex_migrations",
      schemaName: null,
      directory: "./migrations",
      disableTransactions: false,
      disableMigrationsListValidation: false,
      sortDirsSeparately: false
    });
    function getMergedConfig(config2, currentConfig, logger = defaultLogger) {
      const mergedConfig = Object.assign(
        {},
        CONFIG_DEFAULT,
        currentConfig || {},
        config2
      );
      if (config2 && // If user specifies any FS related config,
      // clear specified migrationSource to avoid ambiguity
      (config2.directory || config2.sortDirsSeparately !== void 0 || config2.loadExtensions)) {
        if (config2.migrationSource) {
          logger.warn(
            "FS-related option specified for migration configuration. This resets migrationSource to default FsMigrations"
          );
        }
        mergedConfig.migrationSource = null;
      }
      if (!mergedConfig.migrationSource) {
        mergedConfig.migrationSource = new FsMigrations(
          mergedConfig.directory,
          mergedConfig.sortDirsSeparately,
          mergedConfig.loadExtensions
        );
      }
      return mergedConfig;
    }
    module2.exports = {
      getMergedConfig
    };
  }
});

// ../node_modules/knex/lib/util/timestamp.js
var require_timestamp = __commonJS({
  "../node_modules/knex/lib/util/timestamp.js"(exports, module2) {
    "use strict";
    function yyyymmddhhmmss() {
      const d = /* @__PURE__ */ new Date();
      return d.getFullYear().toString() + (d.getMonth() + 1).toString().padStart(2, "0") + d.getDate().toString().padStart(2, "0") + d.getHours().toString().padStart(2, "0") + d.getMinutes().toString().padStart(2, "0") + d.getSeconds().toString().padStart(2, "0");
    }
    module2.exports = { yyyymmddhhmmss };
  }
});

// ../node_modules/knex/lib/migrate/MigrationGenerator.js
var require_MigrationGenerator = __commonJS({
  "../node_modules/knex/lib/migrate/MigrationGenerator.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var { writeJsFileUsingTemplate } = require_template();
    var { getMergedConfig } = require_configuration_merger();
    var { ensureDirectoryExists } = require_fs();
    var { yyyymmddhhmmss } = require_timestamp();
    var MigrationGenerator = class {
      constructor(migrationConfig, logger) {
        this.config = getMergedConfig(migrationConfig, void 0, logger);
      }
      // Creates a new migration, with a given name.
      async make(name, config2, logger) {
        this.config = getMergedConfig(config2, this.config, logger);
        if (!name) {
          return Promise.reject(
            new Error("A name must be specified for the generated migration")
          );
        }
        await this._ensureFolder();
        const createdMigrationFilePath = await this._writeNewMigration(name);
        return createdMigrationFilePath;
      }
      // Ensures a folder for the migrations exist, dependent on the migration
      // config settings.
      _ensureFolder() {
        const dirs = this._absoluteConfigDirs();
        const promises = dirs.map(ensureDirectoryExists);
        return Promise.all(promises);
      }
      _getStubPath() {
        return this.config.stub || path.join(__dirname, "stub", this.config.extension + ".stub");
      }
      _getNewMigrationName(name) {
        if (name[0] === "-")
          name = name.slice(1);
        return yyyymmddhhmmss() + "_" + name + "." + this.config.extension;
      }
      _getNewMigrationPath(name) {
        const fileName = this._getNewMigrationName(name);
        const dirs = this._absoluteConfigDirs();
        const dir = dirs.slice(-1)[0];
        return path.join(dir, fileName);
      }
      // Write a new migration to disk, using the config and generated filename,
      // passing any `variables` given in the config to the template.
      async _writeNewMigration(name) {
        const migrationPath = this._getNewMigrationPath(name);
        await writeJsFileUsingTemplate(
          migrationPath,
          this._getStubPath(),
          { variable: "d" },
          this.config.variables || {}
        );
        return migrationPath;
      }
      _absoluteConfigDirs() {
        const directories = Array.isArray(this.config.directory) ? this.config.directory : [this.config.directory];
        return directories.map((directory) => {
          if (!directory) {
            console.warn(
              "Failed to resolve config file, knex cannot determine where to generate migrations"
            );
          }
          return path.resolve(process.cwd(), directory);
        });
      }
    };
    module2.exports = MigrationGenerator;
  }
});

// ../node_modules/knex/lib/migrate/Migrator.js
var require_Migrator = __commonJS({
  "../node_modules/knex/lib/migrate/Migrator.js"(exports, module2) {
    "use strict";
    var differenceWith = require("lodash/differenceWith");
    var get11 = require("lodash/get");
    var isEmpty2 = require("lodash/isEmpty");
    var max2 = require("lodash/max");
    var { inherits } = require("util");
    var {
      getLockTableName,
      getTable,
      getTableName
    } = require_table_resolver();
    var { getSchemaBuilder } = require_table_creator();
    var migrationListResolver = require_migration_list_resolver();
    var MigrationGenerator = require_MigrationGenerator();
    var { getMergedConfig } = require_configuration_merger();
    var { isBoolean: isBoolean2, isFunction } = require_is();
    function LockError(msg) {
      this.name = "MigrationLocked";
      this.message = msg;
    }
    inherits(LockError, Error);
    var Migrator = class {
      constructor(knex) {
        if (isFunction(knex)) {
          if (!knex.isTransaction) {
            this.knex = knex.withUserParams({
              ...knex.userParams
            });
          } else {
            this.knex = knex;
          }
        } else {
          this.knex = Object.assign({}, knex);
          this.knex.userParams = this.knex.userParams || {};
        }
        this.config = getMergedConfig(
          this.knex.client.config.migrations,
          void 0,
          this.knex.client.logger
        );
        this.generator = new MigrationGenerator(
          this.knex.client.config.migrations,
          this.knex.client.logger
        );
        this._activeMigration = {
          fileName: null
        };
      }
      // Migrators to the latest configuration.
      async latest(config2) {
        this._disableProcessing();
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        const allAndCompleted = await migrationListResolver.listAllAndCompleted(
          this.config,
          this.knex
        );
        if (!this.config.disableMigrationsListValidation) {
          validateMigrationList(this.config.migrationSource, allAndCompleted);
        }
        const [all, completed] = allAndCompleted;
        const migrations = getNewMigrations(
          this.config.migrationSource,
          all,
          completed
        );
        const transactionForAll = !this.config.disableTransactions && !(await Promise.all(
          migrations.map(async (migration) => {
            const migrationContents = await this.config.migrationSource.getMigration(
              migration
            );
            return !this._useTransaction(migrationContents);
          })
        )).some((isTransactionUsed) => isTransactionUsed);
        if (transactionForAll) {
          return this.knex.transaction((trx) => {
            return this._runBatch(migrations, "up", trx);
          });
        } else {
          return this._runBatch(migrations, "up");
        }
      }
      // Runs the next migration that has not yet been run
      up(config2) {
        this._disableProcessing();
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        return migrationListResolver.listAllAndCompleted(this.config, this.knex).then((value2) => {
          if (!this.config.disableMigrationsListValidation) {
            validateMigrationList(this.config.migrationSource, value2);
          }
          return value2;
        }).then(([all, completed]) => {
          const newMigrations = getNewMigrations(
            this.config.migrationSource,
            all,
            completed
          );
          let migrationToRun;
          const name = this.config.name;
          if (name) {
            if (!completed.includes(name)) {
              migrationToRun = newMigrations.find((migration) => {
                return this.config.migrationSource.getMigrationName(migration) === name;
              });
              if (!migrationToRun) {
                throw new Error(`Migration "${name}" not found.`);
              }
            }
          } else {
            migrationToRun = newMigrations[0];
          }
          return {
            migrationToRun,
            useTransaction: !migrationToRun || this._useTransaction(
              this.config.migrationSource.getMigration(migrationToRun)
            )
          };
        }).then(({ migrationToRun, useTransaction }) => {
          const migrationsToRun = [];
          if (migrationToRun) {
            migrationsToRun.push(migrationToRun);
          }
          const transactionForAll = !this.config.disableTransactions && (!migrationToRun || useTransaction);
          if (transactionForAll) {
            return this.knex.transaction((trx) => {
              return this._runBatch(migrationsToRun, "up", trx);
            });
          } else {
            return this._runBatch(migrationsToRun, "up");
          }
        });
      }
      // Rollback the last "batch", or all, of migrations that were run.
      rollback(config2, all = false) {
        this._disableProcessing();
        return new Promise((resolve, reject) => {
          try {
            this.config = getMergedConfig(
              config2,
              this.config,
              this.knex.client.logger
            );
          } catch (e) {
            reject(e);
          }
          migrationListResolver.listAllAndCompleted(this.config, this.knex).then((value2) => {
            if (!this.config.disableMigrationsListValidation) {
              validateMigrationList(this.config.migrationSource, value2);
            }
            return value2;
          }).then((val) => {
            const [allMigrations, completedMigrations] = val;
            return all ? allMigrations.filter((migration) => {
              return completedMigrations.includes(
                this.config.migrationSource.getMigrationName(migration)
              );
            }).reverse() : this._getLastBatch(val);
          }).then((migrations) => {
            return this._runBatch(migrations, "down");
          }).then(resolve, reject);
        });
      }
      down(config2) {
        this._disableProcessing();
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        return migrationListResolver.listAllAndCompleted(this.config, this.knex).then((value2) => {
          if (!this.config.disableMigrationsListValidation) {
            validateMigrationList(this.config.migrationSource, value2);
          }
          return value2;
        }).then(([all, completed]) => {
          const completedMigrations = all.filter((migration) => {
            return completed.includes(
              this.config.migrationSource.getMigrationName(migration)
            );
          });
          let migrationToRun;
          const name = this.config.name;
          if (name) {
            migrationToRun = completedMigrations.find((migration) => {
              return this.config.migrationSource.getMigrationName(migration) === name;
            });
            if (!migrationToRun) {
              throw new Error(`Migration "${name}" was not run.`);
            }
          } else {
            migrationToRun = completedMigrations[completedMigrations.length - 1];
          }
          const migrationsToRun = [];
          if (migrationToRun) {
            migrationsToRun.push(migrationToRun);
          }
          return this._runBatch(migrationsToRun, "down");
        });
      }
      status(config2) {
        this._disableProcessing();
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        return Promise.all([
          getTable(this.knex, this.config.tableName, this.config.schemaName).select(
            "*"
          ),
          migrationListResolver.listAll(this.config.migrationSource)
        ]).then(([db, code]) => db.length - code.length);
      }
      // Retrieves and returns the current migration version we're on, as a promise.
      // If no migrations have been run yet, return "none".
      currentVersion(config2) {
        this._disableProcessing();
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        return migrationListResolver.listCompleted(this.config.tableName, this.config.schemaName, this.knex).then((completed) => {
          const val = max2(completed.map((value2) => value2.split("_")[0]));
          return val === void 0 ? "none" : val;
        });
      }
      // list all migrations
      async list(config2) {
        this._disableProcessing();
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        const [all, completed] = await migrationListResolver.listAllAndCompleted(
          this.config,
          this.knex
        );
        if (!this.config.disableMigrationsListValidation) {
          validateMigrationList(this.config.migrationSource, [all, completed]);
        }
        const newMigrations = getNewMigrations(
          this.config.migrationSource,
          all,
          completed
        );
        return [completed, newMigrations];
      }
      async forceFreeMigrationsLock(config2) {
        this.config = getMergedConfig(config2, this.config, this.knex.client.logger);
        const { schemaName, tableName } = this.config;
        const lockTableName = getLockTableName(tableName);
        const { knex } = this;
        const getLockTable = () => getTable(knex, lockTableName, schemaName);
        const tableExists = await getSchemaBuilder(knex, schemaName).hasTable(
          lockTableName
        );
        if (tableExists) {
          await getLockTable().del();
          await getLockTable().insert({
            is_locked: 0
          });
        }
      }
      // Creates a new migration, with a given name.
      make(name, config2) {
        return this.generator.make(name, config2, this.knex.client.logger);
      }
      _disableProcessing() {
        if (this.knex.disableProcessing) {
          this.knex.disableProcessing();
        }
      }
      _lockMigrations(trx) {
        const tableName = getLockTableName(this.config.tableName);
        return getTable(this.knex, tableName, this.config.schemaName).transacting(trx).where("is_locked", "=", 0).update({ is_locked: 1 }).then((rowCount) => {
          if (rowCount != 1) {
            throw new Error("Migration table is already locked");
          }
        });
      }
      _getLock(trx) {
        const transact = trx ? (fn) => fn(trx) : (fn) => this.knex.transaction(fn);
        return transact((trx2) => {
          return this._lockMigrations(trx2);
        }).catch((err) => {
          throw new LockError(err.message);
        });
      }
      _freeLock(trx = this.knex) {
        const tableName = getLockTableName(this.config.tableName);
        return getTable(trx, tableName, this.config.schemaName).update({
          is_locked: 0
        });
      }
      // Run a batch of current migrations, in sequence.
      _runBatch(migrations, direction, trx) {
        return this._getLock(trx).then(
          () => trx ? migrationListResolver.listCompleted(
            this.config.tableName,
            this.config.schemaName,
            trx
          ) : []
        ).then(
          (completed) => migrations = getNewMigrations(
            this.config.migrationSource,
            migrations,
            completed
          )
        ).then(
          () => Promise.all(
            migrations.map(this._validateMigrationStructure.bind(this))
          )
        ).then(() => this._latestBatchNumber(trx)).then((batchNo) => {
          if (direction === "up")
            batchNo++;
          return batchNo;
        }).then((batchNo) => {
          return this._waterfallBatch(batchNo, migrations, direction, trx);
        }).then(async (res) => {
          await this._freeLock(trx);
          return res;
        }).catch(async (error) => {
          let cleanupReady = Promise.resolve();
          if (error instanceof LockError) {
            this.knex.client.logger.warn(
              `Can't take lock to run migrations: ${error.message}`
            );
            this.knex.client.logger.warn(
              "If you are sure migrations are not running you can release the lock manually by running 'knex migrate:unlock'"
            );
          } else {
            if (this._activeMigration.fileName) {
              this.knex.client.logger.warn(
                `migration file "${this._activeMigration.fileName}" failed`
              );
            }
            this.knex.client.logger.warn(
              `migration failed with error: ${error.message}`
            );
            cleanupReady = this._freeLock(trx);
          }
          try {
            await cleanupReady;
          } catch (e) {
          }
          throw error;
        });
      }
      // Validates some migrations by requiring and checking for an `up` and `down`
      // function.
      async _validateMigrationStructure(migration) {
        const migrationName = this.config.migrationSource.getMigrationName(
          migration
        );
        const migrationContent = await this.config.migrationSource.getMigration(
          migration
        );
        if (typeof migrationContent.up !== "function" || typeof migrationContent.down !== "function") {
          throw new Error(
            `Invalid migration: ${migrationName} must have both an up and down function`
          );
        }
        return migration;
      }
      // Get the last batch of migrations, by name, ordered by insert id in reverse
      // order.
      async _getLastBatch([allMigrations]) {
        const { tableName, schemaName } = this.config;
        const migrationNames = await getTable(this.knex, tableName, schemaName).where("batch", function(qb) {
          qb.max("batch").from(getTableName(tableName, schemaName));
        }).orderBy("id", "desc");
        const lastBatchMigrations = migrationNames.map((migration) => {
          return allMigrations.find((entry) => {
            return this.config.migrationSource.getMigrationName(entry) === migration.name;
          });
        });
        return Promise.all(lastBatchMigrations);
      }
      // Returns the latest batch number.
      _latestBatchNumber(trx = this.knex) {
        return trx.from(getTableName(this.config.tableName, this.config.schemaName)).max("batch as max_batch").then((obj) => obj[0].max_batch || 0);
      }
      // If transaction config for a single migration is defined, use that.
      // Otherwise, rely on the common config. This allows enabling/disabling
      // transaction for a single migration at will, regardless of the common
      // config.
      _useTransaction(migrationContent, allTransactionsDisabled) {
        const singleTransactionValue = get11(migrationContent, "config.transaction");
        return isBoolean2(singleTransactionValue) ? singleTransactionValue : !allTransactionsDisabled;
      }
      // Runs a batch of `migrations` in a specified `direction`, saving the
      // appropriate database information as the migrations are run.
      _waterfallBatch(batchNo, migrations, direction, trx) {
        const trxOrKnex = trx || this.knex;
        const { tableName, schemaName, disableTransactions } = this.config;
        let current = Promise.resolve();
        const log = [];
        migrations.forEach((migration) => {
          const name = this.config.migrationSource.getMigrationName(migration);
          this._activeMigration.fileName = name;
          const migrationContent = this.config.migrationSource.getMigration(
            migration
          );
          current = current.then(async () => await migrationContent).then((migrationContent2) => {
            this._activeMigration.fileName = name;
            if (!trx && this._useTransaction(migrationContent2, disableTransactions)) {
              this.knex.enableProcessing();
              return this._transaction(
                this.knex,
                migrationContent2,
                direction,
                name
              );
            }
            trxOrKnex.enableProcessing();
            return checkPromise(
              this.knex.client.logger,
              migrationContent2[direction](trxOrKnex),
              name
            );
          }).then(() => {
            trxOrKnex.disableProcessing();
            this.knex.disableProcessing();
            log.push(name);
            if (direction === "up") {
              return trxOrKnex.into(getTableName(tableName, schemaName)).insert({
                name,
                batch: batchNo,
                migration_time: /* @__PURE__ */ new Date()
              });
            }
            if (direction === "down") {
              return trxOrKnex.from(getTableName(tableName, schemaName)).where({ name }).del();
            }
          });
        });
        return current.then(() => [batchNo, log]);
      }
      _transaction(knex, migrationContent, direction, name) {
        return knex.transaction((trx) => {
          return checkPromise(
            knex.client.logger,
            migrationContent[direction](trx),
            name,
            () => {
              trx.commit();
            }
          );
        });
      }
    };
    function validateMigrationList(migrationSource, migrations) {
      const [all, completed] = migrations;
      const diff = getMissingMigrations(migrationSource, completed, all);
      if (!isEmpty2(diff)) {
        throw new Error(
          `The migration directory is corrupt, the following files are missing: ${diff.join(
            ", "
          )}`
        );
      }
    }
    function getMissingMigrations(migrationSource, completed, all) {
      return differenceWith(completed, all, (completedMigration, allMigration) => {
        return completedMigration === migrationSource.getMigrationName(allMigration);
      });
    }
    function getNewMigrations(migrationSource, all, completed) {
      return differenceWith(all, completed, (allMigration, completedMigration) => {
        return completedMigration === migrationSource.getMigrationName(allMigration);
      });
    }
    function checkPromise(logger, migrationPromise, name, commitFn) {
      if (!migrationPromise || typeof migrationPromise.then !== "function") {
        logger.warn(`migration ${name} did not return a promise`);
        if (commitFn) {
          commitFn();
        }
      }
      return migrationPromise;
    }
    module2.exports = {
      Migrator
    };
  }
});

// ../node_modules/knex/lib/seed/Seeder.js
var require_Seeder = __commonJS({
  "../node_modules/knex/lib/seed/Seeder.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var flatten3 = require("lodash/flatten");
    var extend = require("lodash/extend");
    var includes4 = require("lodash/includes");
    var { ensureDirectoryExists, getFilepathsInFolder } = require_fs();
    var { writeJsFileUsingTemplate } = require_template();
    var { yyyymmddhhmmss } = require_timestamp();
    var filterByLoadExtensions = (extensions) => (value2) => {
      const extension = path.extname(value2);
      return includes4(extensions, extension);
    };
    var Seeder = class {
      constructor(knex) {
        this.knex = knex;
        this.config = this.setConfig(knex.client.config.seeds);
      }
      // Runs seed files for the given environment.
      async run(config2) {
        this.config = this.setConfig(config2);
        let files = await this._listAll();
        if (config2 && config2.specific) {
          files = files.filter((file) => path.basename(file) === config2.specific);
          if (files.length === 0) {
            throw new Error(
              `Invalid argument provided: the specific seed "${config2.specific}" does not exist.`
            );
          }
        }
        return this._runSeeds(files);
      }
      // Creates a new seed file, with a given name.
      async make(name, config2) {
        this.config = this.setConfig(config2);
        if (!name)
          throw new Error("A name must be specified for the generated seed");
        await this._ensureFolder(config2);
        const seedPath = await this._writeNewSeed(name);
        return seedPath;
      }
      // Lists all available seed files as a sorted array.
      async _listAll(config2) {
        this.config = this.setConfig(config2);
        const { loadExtensions, recursive } = this.config;
        const seeds = flatten3(
          await Promise.all(
            this._absoluteConfigDirs().map(
              (d) => getFilepathsInFolder(d, recursive)
            )
          )
        );
        if (this.config.sortDirsSeparately) {
          return seeds.filter(filterByLoadExtensions(loadExtensions));
        } else {
          return seeds.filter(filterByLoadExtensions(loadExtensions)).sort();
        }
      }
      // Ensures a folder for the seeds exist, dependent on the
      // seed config settings.
      _ensureFolder() {
        const dirs = this._absoluteConfigDirs();
        const promises = dirs.map(ensureDirectoryExists);
        return Promise.all(promises);
      }
      // Run seed files, in sequence.
      _runSeeds(seeds) {
        seeds.forEach((seed) => this._validateSeedStructure(seed));
        return this._waterfallBatch(seeds);
      }
      // Validates seed files by requiring and checking for a `seed` function.
      async _validateSeedStructure(filepath) {
        const importFile = require_import_file();
        const seed = await importFile(filepath);
        if (typeof seed.seed !== "function") {
          throw new Error(
            `Invalid seed file: ${filepath} must have a seed function`
          );
        }
        return filepath;
      }
      _getStubPath() {
        return this.config.stub || path.join(__dirname, "stub", this.config.extension + ".stub");
      }
      _getNewStubFileName(name) {
        if (name[0] === "-")
          name = name.slice(1);
        if (this.config.timestampFilenamePrefix === true) {
          name = `${yyyymmddhhmmss()}_${name}`;
        }
        return `${name}.${this.config.extension}`;
      }
      _getNewStubFilePath(name) {
        const fileName = this._getNewStubFileName(name);
        const dirs = this._absoluteConfigDirs();
        const dir = dirs.slice(-1)[0];
        return path.join(dir, fileName);
      }
      // Write a new seed to disk, using the config and generated filename,
      // passing any `variables` given in the config to the template.
      async _writeNewSeed(name) {
        const seedPath = this._getNewStubFilePath(name);
        await writeJsFileUsingTemplate(
          seedPath,
          this._getStubPath(),
          { variable: "d" },
          this.config.variables || {}
        );
        return seedPath;
      }
      // Runs a batch of seed files.
      async _waterfallBatch(seeds) {
        const { knex } = this;
        const log = [];
        for (const seedPath of seeds) {
          const importFile = require_import_file();
          const seed = await importFile(seedPath);
          try {
            await seed.seed(knex);
            log.push(seedPath);
          } catch (originalError) {
            const error = new Error(
              `Error while executing "${seedPath}" seed: ${originalError.message}`
            );
            error.original = originalError;
            error.stack = error.stack.split("\n").slice(0, 2).join("\n") + "\n" + originalError.stack;
            throw error;
          }
        }
        return [log];
      }
      /**
       * Return all the config directories
       * @returns {string[]}
       */
      _absoluteConfigDirs() {
        const directories = Array.isArray(this.config.directory) ? this.config.directory : [this.config.directory];
        return directories.map((directory) => {
          if (!directory) {
            console.warn(
              "Failed to resolve config file, knex cannot determine where to run or make seeds"
            );
          }
          return path.resolve(process.cwd(), directory);
        });
      }
      setConfig(config2) {
        return extend(
          {
            extension: "js",
            directory: "./seeds",
            loadExtensions: [
              ".co",
              ".coffee",
              ".eg",
              ".iced",
              ".js",
              ".litcoffee",
              ".ls",
              ".ts"
            ],
            timestampFilenamePrefix: false,
            sortDirsSeparately: false,
            recursive: false
          },
          this.config || {},
          config2
        );
      }
    };
    module2.exports = Seeder;
  }
});

// ../node_modules/knex/lib/functionhelper.js
var require_functionhelper = __commonJS({
  "../node_modules/knex/lib/functionhelper.js"(exports, module2) {
    "use strict";
    function FunctionHelper(client) {
      this.client = client;
    }
    FunctionHelper.prototype.now = function(precision) {
      if (typeof precision === "number") {
        return this.client.raw(`CURRENT_TIMESTAMP(${precision})`);
      }
      return this.client.raw("CURRENT_TIMESTAMP");
    };
    module2.exports = FunctionHelper;
  }
});

// ../node_modules/knex/lib/query/methods.js
var require_methods = __commonJS({
  "../node_modules/knex/lib/query/methods.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "with",
      "withRecursive",
      "select",
      "as",
      "columns",
      "column",
      "from",
      "fromJS",
      "into",
      "withSchema",
      "table",
      "distinct",
      "join",
      "joinRaw",
      "innerJoin",
      "leftJoin",
      "leftOuterJoin",
      "rightJoin",
      "rightOuterJoin",
      "outerJoin",
      "fullOuterJoin",
      "crossJoin",
      "where",
      "andWhere",
      "orWhere",
      "whereNot",
      "orWhereNot",
      "whereRaw",
      "whereWrapped",
      "havingWrapped",
      "orWhereRaw",
      "whereExists",
      "orWhereExists",
      "whereNotExists",
      "orWhereNotExists",
      "whereIn",
      "orWhereIn",
      "whereNotIn",
      "orWhereNotIn",
      "whereNull",
      "orWhereNull",
      "whereNotNull",
      "orWhereNotNull",
      "whereBetween",
      "whereNotBetween",
      "andWhereBetween",
      "andWhereNotBetween",
      "orWhereBetween",
      "orWhereNotBetween",
      "groupBy",
      "groupByRaw",
      "orderBy",
      "orderByRaw",
      "union",
      "unionAll",
      "intersect",
      "having",
      "havingRaw",
      "orHaving",
      "orHavingRaw",
      "offset",
      "limit",
      "count",
      "countDistinct",
      "min",
      "max",
      "sum",
      "sumDistinct",
      "avg",
      "avgDistinct",
      "increment",
      "decrement",
      "first",
      "debug",
      "pluck",
      "clearSelect",
      "clearWhere",
      "clearGroup",
      "clearOrder",
      "clearHaving",
      "insert",
      "update",
      "returning",
      "del",
      "delete",
      "truncate",
      "transacting",
      "connection"
    ];
  }
});

// ../node_modules/knex/lib/util/delay.js
var require_delay = __commonJS({
  "../node_modules/knex/lib/util/delay.js"(exports, module2) {
    "use strict";
    module2.exports = (delay) => new Promise((resolve) => setTimeout(resolve, delay));
  }
});

// ../node_modules/knex/lib/util/batchInsert.js
var require_batchInsert = __commonJS({
  "../node_modules/knex/lib/util/batchInsert.js"(exports, module2) {
    "use strict";
    var chunk = require("lodash/chunk");
    var flatten3 = require("lodash/flatten");
    var delay = require_delay();
    var { isNumber: isNumber2 } = require_is();
    module2.exports = function batchInsert(client, tableName, batch, chunkSize = 1e3) {
      let returning = void 0;
      let transaction = null;
      const runInTransaction = (cb) => {
        if (transaction) {
          return cb(transaction);
        }
        return client.transaction(cb);
      };
      return Object.assign(
        Promise.resolve().then(async () => {
          if (!isNumber2(chunkSize) || chunkSize < 1) {
            throw new TypeError(`Invalid chunkSize: ${chunkSize}`);
          }
          if (!Array.isArray(batch)) {
            throw new TypeError(
              `Invalid batch: Expected array, got ${typeof batch}`
            );
          }
          const chunks = chunk(batch, chunkSize);
          await delay(1);
          return runInTransaction(async (tr) => {
            const chunksResults = [];
            for (const items of chunks) {
              chunksResults.push(await tr(tableName).insert(items, returning));
            }
            return flatten3(chunksResults);
          });
        }),
        {
          returning(columns) {
            returning = columns;
            return this;
          },
          transacting(tr) {
            transaction = tr;
            return this;
          }
        }
      );
    };
  }
});

// ../node_modules/knex/lib/util/make-knex.js
var require_make_knex = __commonJS({
  "../node_modules/knex/lib/util/make-knex.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var { Migrator } = require_Migrator();
    var Seeder = require_Seeder();
    var FunctionHelper = require_functionhelper();
    var QueryInterface = require_methods();
    var merge2 = require("lodash/merge");
    var batchInsert = require_batchInsert();
    var KNEX_PROPERTY_DEFINITIONS = {
      client: {
        get() {
          return this.context.client;
        },
        set(client) {
          this.context.client = client;
        },
        configurable: true
      },
      userParams: {
        get() {
          return this.context.userParams;
        },
        set(userParams) {
          this.context.userParams = userParams;
        },
        configurable: true
      },
      schema: {
        get() {
          return this.client.schemaBuilder();
        },
        configurable: true
      },
      migrate: {
        get() {
          return new Migrator(this);
        },
        configurable: true
      },
      seed: {
        get() {
          return new Seeder(this);
        },
        configurable: true
      },
      fn: {
        get() {
          return new FunctionHelper(this.client);
        },
        configurable: true
      }
    };
    var CONTEXT_METHODS = [
      "raw",
      "batchInsert",
      "transaction",
      "transactionProvider",
      "initialize",
      "destroy",
      "ref",
      "withUserParams",
      "queryBuilder",
      "disableProcessing",
      "enableProcessing"
    ];
    for (const m of CONTEXT_METHODS) {
      KNEX_PROPERTY_DEFINITIONS[m] = {
        value: function(...args) {
          return this.context[m](...args);
        },
        configurable: true
      };
    }
    function makeKnex(client) {
      function knex(tableName, options) {
        return createQueryBuilder(knex.context, tableName, options);
      }
      redefineProperties(knex, client);
      return knex;
    }
    function initContext(knexFn) {
      const knexContext = knexFn.context || {};
      Object.assign(knexContext, {
        queryBuilder() {
          return this.client.queryBuilder();
        },
        raw() {
          return this.client.raw.apply(this.client, arguments);
        },
        batchInsert(table, batch, chunkSize = 1e3) {
          return batchInsert(this, table, batch, chunkSize);
        },
        // Creates a new transaction.
        // If container is provided, returns a promise for when the transaction is resolved.
        // If container is not provided, returns a promise with a transaction that is resolved
        // when transaction is ready to be used.
        transaction(container, _config) {
          const config2 = Object.assign({}, _config);
          config2.userParams = this.userParams || {};
          if (config2.doNotRejectOnRollback === void 0) {
            config2.doNotRejectOnRollback = !container;
          }
          return this._transaction(container, config2);
        },
        // Internal method that actually establishes the Transaction.  It makes no assumptions
        // about the `config` or `outerTx`, and expects the caller to handle these details.
        _transaction(container, config2, outerTx = null) {
          if (container) {
            const trx = this.client.transaction(container, config2, outerTx);
            return trx;
          } else {
            return new Promise((resolve, reject) => {
              const trx = this.client.transaction(resolve, config2, outerTx);
              trx.catch(reject);
            });
          }
        },
        transactionProvider(config2) {
          let trx;
          return () => {
            if (!trx) {
              trx = this.transaction(void 0, config2);
            }
            return trx;
          };
        },
        // Typically never needed, initializes the pool for a knex client.
        initialize(config2) {
          return this.client.initializePool(config2);
        },
        // Convenience method for tearing down the pool.
        destroy(callback) {
          return this.client.destroy(callback);
        },
        ref(ref) {
          return this.client.ref(ref);
        },
        // Do not document this as public API until naming and API is improved for general consumption
        // This method exists to disable processing of internal queries in migrations
        disableProcessing() {
          if (this.userParams.isProcessingDisabled) {
            return;
          }
          this.userParams.wrapIdentifier = this.client.config.wrapIdentifier;
          this.userParams.postProcessResponse = this.client.config.postProcessResponse;
          this.client.config.wrapIdentifier = null;
          this.client.config.postProcessResponse = null;
          this.userParams.isProcessingDisabled = true;
        },
        // Do not document this as public API until naming and API is improved for general consumption
        // This method exists to enable execution of non-internal queries with consistent identifier naming in migrations
        enableProcessing() {
          if (!this.userParams.isProcessingDisabled) {
            return;
          }
          this.client.config.wrapIdentifier = this.userParams.wrapIdentifier;
          this.client.config.postProcessResponse = this.userParams.postProcessResponse;
          this.userParams.isProcessingDisabled = false;
        },
        withUserParams(params) {
          const knexClone = shallowCloneFunction(knexFn);
          if (this.client) {
            knexClone.client = Object.create(this.client.constructor.prototype);
            merge2(knexClone.client, this.client);
            knexClone.client.config = Object.assign({}, this.client.config);
          }
          redefineProperties(knexClone, knexClone.client);
          _copyEventListeners("query", knexFn, knexClone);
          _copyEventListeners("query-error", knexFn, knexClone);
          _copyEventListeners("query-response", knexFn, knexClone);
          _copyEventListeners("start", knexFn, knexClone);
          knexClone.userParams = params;
          return knexClone;
        }
      });
      if (!knexFn.context) {
        knexFn.context = knexContext;
      }
    }
    function _copyEventListeners(eventName, sourceKnex, targetKnex) {
      const listeners = sourceKnex.listeners(eventName);
      listeners.forEach((listener) => {
        targetKnex.on(eventName, listener);
      });
    }
    function redefineProperties(knex, client) {
      QueryInterface.forEach(function(method) {
        knex[method] = function() {
          const builder = this.queryBuilder();
          return builder[method].apply(builder, arguments);
        };
      });
      Object.defineProperties(knex, KNEX_PROPERTY_DEFINITIONS);
      initContext(knex);
      knex.client = client;
      knex.client.makeKnex = makeKnex;
      knex.userParams = {};
      const ee = new EventEmitter();
      for (const key in ee) {
        knex[key] = ee[key];
      }
      if (knex._internalListeners) {
        knex._internalListeners.forEach(({ eventName, listener }) => {
          knex.client.removeListener(eventName, listener);
        });
      }
      knex._internalListeners = [];
      _addInternalListener(knex, "start", (obj) => {
        knex.emit("start", obj);
      });
      _addInternalListener(knex, "query", (obj) => {
        knex.emit("query", obj);
      });
      _addInternalListener(knex, "query-error", (err, obj) => {
        knex.emit("query-error", err, obj);
      });
      _addInternalListener(knex, "query-response", (response, obj, builder) => {
        knex.emit("query-response", response, obj, builder);
      });
    }
    function _addInternalListener(knex, eventName, listener) {
      knex.client.on(eventName, listener);
      knex._internalListeners.push({
        eventName,
        listener
      });
    }
    function createQueryBuilder(knexContext, tableName, options) {
      const qb = knexContext.queryBuilder();
      if (!tableName)
        knexContext.client.logger.warn(
          "calling knex without a tableName is deprecated. Use knex.queryBuilder() instead."
        );
      return tableName ? qb.table(tableName, options) : qb;
    }
    function shallowCloneFunction(originalFunction) {
      const fnContext = Object.create(
        Object.getPrototypeOf(originalFunction),
        Object.getOwnPropertyDescriptors(originalFunction)
      );
      const knexContext = {};
      const knexFnWrapper = (tableName, options) => {
        return createQueryBuilder(knexContext, tableName, options);
      };
      const clonedFunction = knexFnWrapper.bind(fnContext);
      Object.assign(clonedFunction, originalFunction);
      clonedFunction.context = knexContext;
      return clonedFunction;
    }
    module2.exports = makeKnex;
  }
});

// ../node_modules/knex/lib/transaction.js
var require_transaction = __commonJS({
  "../node_modules/knex/lib/transaction.js"(exports, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var Debug = require_src();
    var uniqueId = require("lodash/uniqueId");
    var { callbackify } = require("util");
    var makeKnex = require_make_knex();
    var { timeout, KnexTimeoutError } = require_timeout();
    var finallyMixin = require_finally_mixin();
    var debug = Debug("knex:tx");
    function DEFAULT_CONFIG() {
      return {
        userParams: {},
        doNotRejectOnRollback: true
      };
    }
    var Transaction = class extends EventEmitter {
      constructor(client, container, config2 = DEFAULT_CONFIG(), outerTx = null) {
        super();
        this.userParams = config2.userParams;
        this.doNotRejectOnRollback = config2.doNotRejectOnRollback;
        const txid = this.txid = uniqueId("trx");
        this.client = client;
        this.logger = client.logger;
        this.outerTx = outerTx;
        this.trxClient = void 0;
        this._completed = false;
        this._debug = client.config && client.config.debug;
        debug(
          "%s: Starting %s transaction",
          txid,
          outerTx ? "nested" : "top level"
        );
        this._lastChild = Promise.resolve();
        const _previousSibling = outerTx ? outerTx._lastChild : Promise.resolve();
        const basePromise = _previousSibling.then(
          () => this._evaluateContainer(config2, container)
        );
        this._promise = basePromise.then((x) => x);
        if (outerTx) {
          outerTx._lastChild = basePromise.catch(() => {
          });
        }
      }
      isCompleted() {
        return this._completed || this.outerTx && this.outerTx.isCompleted() || false;
      }
      begin(conn) {
        return this.query(conn, "BEGIN;");
      }
      savepoint(conn) {
        return this.query(conn, `SAVEPOINT ${this.txid};`);
      }
      commit(conn, value2) {
        return this.query(conn, "COMMIT;", 1, value2);
      }
      release(conn, value2) {
        return this.query(conn, `RELEASE SAVEPOINT ${this.txid};`, 1, value2);
      }
      rollback(conn, error) {
        return timeout(this.query(conn, "ROLLBACK", 2, error), 5e3).catch(
          (err) => {
            if (!(err instanceof KnexTimeoutError)) {
              return Promise.reject(err);
            }
            this._rejecter(error);
          }
        );
      }
      rollbackTo(conn, error) {
        return timeout(
          this.query(conn, `ROLLBACK TO SAVEPOINT ${this.txid}`, 2, error),
          5e3
        ).catch((err) => {
          if (!(err instanceof KnexTimeoutError)) {
            return Promise.reject(err);
          }
          this._rejecter(error);
        });
      }
      query(conn, sql, status, value2) {
        const q = this.trxClient.query(conn, sql).catch((err) => {
          status = 2;
          value2 = err;
          this._completed = true;
          debug("%s error running transaction query", this.txid);
        }).then((res) => {
          if (status === 1) {
            this._resolver(value2);
          }
          if (status === 2) {
            if (value2 === void 0) {
              if (this.doNotRejectOnRollback && /^ROLLBACK\b/i.test(sql)) {
                this._resolver();
                return;
              }
              value2 = new Error(`Transaction rejected with non-error: ${value2}`);
            }
            this._rejecter(value2);
          }
          return res;
        });
        if (status === 1 || status === 2) {
          this._completed = true;
        }
        return q;
      }
      debug(enabled) {
        this._debug = arguments.length ? enabled : true;
        return this;
      }
      async _evaluateContainer(config2, container) {
        return this.acquireConnection(config2, (connection) => {
          const trxClient = this.trxClient = makeTxClient(
            this,
            this.client,
            connection
          );
          const init = this.client.transacting ? this.savepoint(connection) : this.begin(connection);
          const executionPromise = new Promise((resolver, rejecter) => {
            this._resolver = resolver;
            this._rejecter = rejecter;
          });
          init.then(() => {
            return makeTransactor(this, connection, trxClient);
          }).then((transactor) => {
            transactor.executionPromise = executionPromise;
            let result;
            try {
              result = container(transactor);
            } catch (err) {
              result = Promise.reject(err);
            }
            if (result && result.then && typeof result.then === "function") {
              result.then((val) => {
                return transactor.commit(val);
              }).catch((err) => {
                return transactor.rollback(err);
              });
            }
            return null;
          }).catch((e) => {
            return this._rejecter(e);
          });
          return executionPromise;
        });
      }
      // Acquire a connection and create a disposer - either using the one passed
      // via config or getting one off the client. The disposer will be called once
      // the original promise is marked completed.
      async acquireConnection(config2, cb) {
        const configConnection = config2 && config2.connection;
        const connection = configConnection || await this.client.acquireConnection();
        try {
          connection.__knexTxId = this.txid;
          return await cb(connection);
        } finally {
          if (!configConnection) {
            debug("%s: releasing connection", this.txid);
            this.client.releaseConnection(connection);
          } else {
            debug("%s: not releasing external connection", this.txid);
          }
        }
      }
      then(onResolve, onReject) {
        return this._promise.then(onResolve, onReject);
      }
      catch(onReject) {
        return this._promise.catch(onReject);
      }
      asCallback(cb) {
        callbackify(() => this._promise)(cb);
        return this._promise;
      }
    };
    finallyMixin(Transaction.prototype);
    function makeTransactor(trx, connection, trxClient) {
      const transactor = makeKnex(trxClient);
      transactor.context.withUserParams = () => {
        throw new Error(
          "Cannot set user params on a transaction - it can only inherit params from main knex instance"
        );
      };
      transactor.isTransaction = true;
      transactor.userParams = trx.userParams || {};
      transactor.context.transaction = function(container, options) {
        if (!options) {
          options = { doNotRejectOnRollback: true };
        } else if (options.doNotRejectOnRollback === void 0) {
          options.doNotRejectOnRollback = true;
        }
        return this._transaction(container, options, trx);
      };
      transactor.savepoint = function(container, options) {
        return transactor.transaction(container, options);
      };
      if (trx.client.transacting) {
        transactor.commit = (value2) => trx.release(connection, value2);
        transactor.rollback = (error) => trx.rollbackTo(connection, error);
      } else {
        transactor.commit = (value2) => trx.commit(connection, value2);
        transactor.rollback = (error) => trx.rollback(connection, error);
      }
      transactor.isCompleted = () => trx.isCompleted();
      return transactor;
    }
    function makeTxClient(trx, client, connection) {
      const trxClient = Object.create(client.constructor.prototype);
      trxClient.version = client.version;
      trxClient.config = client.config;
      trxClient.driver = client.driver;
      trxClient.connectionSettings = client.connectionSettings;
      trxClient.transacting = true;
      trxClient.valueForUndefined = client.valueForUndefined;
      trxClient.logger = client.logger;
      trxClient.on("start", function(arg) {
        trx.emit("start", arg);
        client.emit("start", arg);
      });
      trxClient.on("query", function(arg) {
        trx.emit("query", arg);
        client.emit("query", arg);
      });
      trxClient.on("query-error", function(err, obj) {
        trx.emit("query-error", err, obj);
        client.emit("query-error", err, obj);
      });
      trxClient.on("query-response", function(response, obj, builder) {
        trx.emit("query-response", response, obj, builder);
        client.emit("query-response", response, obj, builder);
      });
      const _query = trxClient.query;
      trxClient.query = function(conn, obj) {
        const completed = trx.isCompleted();
        return new Promise(function(resolve, reject) {
          try {
            if (conn !== connection)
              throw new Error("Invalid connection for transaction query.");
            if (completed)
              completedError(trx, obj);
            resolve(_query.call(trxClient, conn, obj));
          } catch (e) {
            reject(e);
          }
        });
      };
      const _stream = trxClient.stream;
      trxClient.stream = function(conn, obj, stream, options) {
        const completed = trx.isCompleted();
        return new Promise(function(resolve, reject) {
          try {
            if (conn !== connection)
              throw new Error("Invalid connection for transaction query.");
            if (completed)
              completedError(trx, obj);
            resolve(_stream.call(trxClient, conn, obj, stream, options));
          } catch (e) {
            reject(e);
          }
        });
      };
      trxClient.acquireConnection = function() {
        return Promise.resolve(connection);
      };
      trxClient.releaseConnection = function() {
        return Promise.resolve();
      };
      return trxClient;
    }
    function completedError(trx, obj) {
      const sql = typeof obj === "string" ? obj : obj && obj.sql;
      debug("%s: Transaction completed: %s", trx.txid, sql);
      throw new Error(
        "Transaction query already complete, run with DEBUG=knex:tx for more info"
      );
    }
    module2.exports = Transaction;
  }
});

// ../node_modules/knex/lib/query/compiler.js
var require_compiler = __commonJS({
  "../node_modules/knex/lib/query/compiler.js"(exports, module2) {
    "use strict";
    var helpers = require_helpers();
    var Raw = require_raw();
    var QueryBuilder = require_builder();
    var JoinClause = require_joinclause();
    var debug = require_src();
    var assign = require("lodash/assign");
    var bind = require("lodash/bind");
    var compact = require("lodash/compact");
    var groupBy2 = require("lodash/groupBy");
    var has5 = require("lodash/has");
    var isEmpty2 = require("lodash/isEmpty");
    var map2 = require("lodash/map");
    var omitBy = require("lodash/omitBy");
    var reduce2 = require("lodash/reduce");
    var { nanoid } = require_nanoid();
    var { isString: isString2, isUndefined: isUndefined3 } = require_is();
    var debugBindings = debug("knex:bindings");
    var components = [
      "columns",
      "join",
      "where",
      "union",
      "group",
      "having",
      "order",
      "limit",
      "offset",
      "lock",
      "waitMode"
    ];
    var QueryCompiler = class {
      constructor(client, builder) {
        this.client = client;
        this.method = builder._method || "select";
        this.options = builder._options;
        this.single = builder._single;
        this.timeout = builder._timeout || false;
        this.cancelOnTimeout = builder._cancelOnTimeout || false;
        this.grouped = groupBy2(builder._statements, "grouping");
        this.formatter = client.formatter(builder);
        this._emptyInsertValue = "default values";
        this.first = this.select;
      }
      // Collapse the builder into a single object
      toSQL(method, tz) {
        this._undefinedInWhereClause = false;
        this.undefinedBindingsInfo = [];
        method = method || this.method;
        const val = this[method]() || "";
        const query = {
          method,
          options: reduce2(this.options, assign, {}),
          timeout: this.timeout,
          cancelOnTimeout: this.cancelOnTimeout,
          bindings: this.formatter.bindings || [],
          __knexQueryUid: nanoid()
        };
        Object.defineProperties(query, {
          toNative: {
            value: () => {
              return {
                sql: this.client.positionBindings(query.sql),
                bindings: this.client.prepBindings(query.bindings)
              };
            },
            enumerable: false
          }
        });
        if (isString2(val)) {
          query.sql = val;
        } else {
          assign(query, val);
        }
        if (method === "select" || method === "first") {
          if (this.single.as) {
            query.as = this.single.as;
          }
        }
        if (this._undefinedInWhereClause) {
          debugBindings(query.bindings);
          throw new Error(
            `Undefined binding(s) detected when compiling ${method.toUpperCase()}. Undefined column(s): [${this.undefinedBindingsInfo.join(
              ", "
            )}] query: ${query.sql}`
          );
        }
        return query;
      }
      // Compiles the `select` statement, or nested sub-selects by calling each of
      // the component compilers, trimming out the empties, and returning a
      // generated query string.
      select() {
        let sql = this.with();
        const statements = components.map((component) => this[component](this));
        sql += compact(statements).join(" ");
        return sql;
      }
      pluck() {
        let toPluck = this.single.pluck;
        if (toPluck.indexOf(".") !== -1) {
          toPluck = toPluck.split(".").slice(-1)[0];
        }
        return {
          sql: this.select(),
          pluck: toPluck
        };
      }
      // Compiles an "insert" query, allowing for multiple
      // inserts using a single query statement.
      insert() {
        const insertValues = this.single.insert || [];
        let sql = this.with() + `insert into ${this.tableName} `;
        if (Array.isArray(insertValues)) {
          if (insertValues.length === 0) {
            return "";
          }
        } else if (typeof insertValues === "object" && isEmpty2(insertValues)) {
          return sql + this._emptyInsertValue;
        }
        const insertData = this._prepInsert(insertValues);
        if (typeof insertData === "string") {
          sql += insertData;
        } else {
          if (insertData.columns.length) {
            sql += `(${this.formatter.columnize(insertData.columns)}`;
            sql += ") values (";
            let i = -1;
            while (++i < insertData.values.length) {
              if (i !== 0)
                sql += "), (";
              sql += this.formatter.parameterize(
                insertData.values[i],
                this.client.valueForUndefined
              );
            }
            sql += ")";
          } else if (insertValues.length === 1 && insertValues[0]) {
            sql += this._emptyInsertValue;
          } else {
            sql = "";
          }
        }
        return sql;
      }
      // Compiles the "update" query.
      update() {
        const withSQL = this.with();
        const { tableName } = this;
        const updateData = this._prepUpdate(this.single.update);
        const wheres = this.where();
        return withSQL + `update ${this.single.only ? "only " : ""}${tableName} set ` + updateData.join(", ") + (wheres ? ` ${wheres}` : "");
      }
      _hintComments() {
        let hints = this.grouped.hintComments || [];
        hints = hints.map((hint) => compact(hint.value).join(" "));
        hints = compact(hints).join(" ");
        return hints ? `/*+ ${hints} */ ` : "";
      }
      // Compiles the columns in the query, specifying if an item was distinct.
      columns() {
        let distinctClause = "";
        if (this.onlyUnions())
          return "";
        const hints = this._hintComments();
        const columns = this.grouped.columns || [];
        let i = -1, sql = [];
        if (columns) {
          while (++i < columns.length) {
            const stmt = columns[i];
            if (stmt.distinct)
              distinctClause = "distinct ";
            if (stmt.distinctOn) {
              distinctClause = this.distinctOn(stmt.value);
              continue;
            }
            if (stmt.type === "aggregate") {
              sql.push(...this.aggregate(stmt));
            } else if (stmt.type === "aggregateRaw") {
              sql.push(this.aggregateRaw(stmt));
            } else if (stmt.value && stmt.value.length > 0) {
              sql.push(this.formatter.columnize(stmt.value));
            }
          }
        }
        if (sql.length === 0)
          sql = ["*"];
        return `select ${hints}${distinctClause}` + sql.join(", ") + (this.tableName ? ` from ${this.single.only ? "only " : ""}${this.tableName}` : "");
      }
      _aggregate(stmt, { aliasSeparator = " as ", distinctParentheses } = {}) {
        const value2 = stmt.value;
        const method = stmt.method;
        const distinct = stmt.aggregateDistinct ? "distinct " : "";
        const wrap = (identifier) => this.formatter.wrap(identifier);
        const addAlias = (value3, alias2) => {
          if (alias2) {
            return value3 + aliasSeparator + wrap(alias2);
          }
          return value3;
        };
        const aggregateArray = (value3, alias2) => {
          let columns = value3.map(wrap).join(", ");
          if (distinct) {
            const openParen = distinctParentheses ? "(" : " ";
            const closeParen = distinctParentheses ? ")" : "";
            columns = distinct.trim() + openParen + columns + closeParen;
          }
          const aggregated = `${method}(${columns})`;
          return addAlias(aggregated, alias2);
        };
        const aggregateString = (value3, alias2) => {
          const aggregated = `${method}(${distinct + wrap(value3)})`;
          return addAlias(aggregated, alias2);
        };
        if (Array.isArray(value2)) {
          return [aggregateArray(value2)];
        }
        if (typeof value2 === "object") {
          if (stmt.alias) {
            throw new Error("When using an object explicit alias can not be used");
          }
          return Object.entries(value2).map(([alias2, column2]) => {
            if (Array.isArray(column2)) {
              return aggregateArray(column2, alias2);
            }
            return aggregateString(column2, alias2);
          });
        }
        const splitOn = value2.toLowerCase().indexOf(" as ");
        let column = value2;
        let { alias } = stmt;
        if (splitOn !== -1) {
          column = value2.slice(0, splitOn);
          if (alias) {
            throw new Error(`Found multiple aliases for same column: ${column}`);
          }
          alias = value2.slice(splitOn + 4);
        }
        return [aggregateString(column, alias)];
      }
      aggregate(stmt) {
        return this._aggregate(stmt);
      }
      aggregateRaw(stmt) {
        const distinct = stmt.aggregateDistinct ? "distinct " : "";
        return `${stmt.method}(${distinct + this.formatter.unwrapRaw(stmt.value)})`;
      }
      // Compiles all each of the `join` clauses on the query,
      // including any nested join queries.
      join() {
        let sql = "";
        let i = -1;
        const joins = this.grouped.join;
        if (!joins)
          return "";
        while (++i < joins.length) {
          const join3 = joins[i];
          const table = join3.schema ? `${join3.schema}.${join3.table}` : join3.table;
          if (i > 0)
            sql += " ";
          if (join3.joinType === "raw") {
            sql += this.formatter.unwrapRaw(join3.table);
          } else {
            sql += join3.joinType + " join " + this.formatter.wrap(table);
            let ii = -1;
            while (++ii < join3.clauses.length) {
              const clause = join3.clauses[ii];
              if (ii > 0) {
                sql += ` ${clause.bool} `;
              } else {
                sql += ` ${clause.type === "onUsing" ? "using" : "on"} `;
              }
              const val = this[clause.type].call(this, clause);
              if (val) {
                sql += val;
              }
            }
          }
        }
        return sql;
      }
      onBetween(statement) {
        return this.formatter.wrap(statement.column) + " " + this._not(statement, "between") + " " + map2(statement.value, bind(this.formatter.parameter, this.formatter)).join(
          " and "
        );
      }
      onNull(statement) {
        return this.formatter.wrap(statement.column) + " is " + this._not(statement, "null");
      }
      onExists(statement) {
        return this._not(statement, "exists") + " (" + this.formatter.rawOrFn(statement.value) + ")";
      }
      onIn(statement) {
        if (Array.isArray(statement.column))
          return this.multiOnIn(statement);
        return this.formatter.wrap(statement.column) + " " + this._not(statement, "in ") + this.wrap(this.formatter.parameterize(statement.value));
      }
      multiOnIn(statement) {
        let i = -1, sql = `(${this.formatter.columnize(statement.column)}) `;
        sql += this._not(statement, "in ") + "((";
        while (++i < statement.value.length) {
          if (i !== 0)
            sql += "),(";
          sql += this.formatter.parameterize(statement.value[i]);
        }
        return sql + "))";
      }
      // Compiles all `where` statements on the query.
      where() {
        const wheres = this.grouped.where;
        if (!wheres)
          return;
        const sql = [];
        let i = -1;
        while (++i < wheres.length) {
          const stmt = wheres[i];
          if (Object.prototype.hasOwnProperty.call(stmt, "value") && helpers.containsUndefined(stmt.value)) {
            this.undefinedBindingsInfo.push(stmt.column);
            this._undefinedInWhereClause = true;
          }
          const val = this[stmt.type](stmt);
          if (val) {
            if (sql.length === 0) {
              sql[0] = "where";
            } else {
              sql.push(stmt.bool);
            }
            sql.push(val);
          }
        }
        return sql.length > 1 ? sql.join(" ") : "";
      }
      group() {
        return this._groupsOrders("group");
      }
      order() {
        return this._groupsOrders("order");
      }
      // Compiles the `having` statements.
      having() {
        const havings = this.grouped.having;
        if (!havings)
          return "";
        const sql = ["having"];
        for (let i = 0, l = havings.length; i < l; i++) {
          const s = havings[i];
          const val = this[s.type](s);
          if (val) {
            if (sql.length === 0) {
              sql[0] = "where";
            }
            if (sql.length > 1 || sql.length === 1 && sql[0] !== "having") {
              sql.push(s.bool);
            }
            sql.push(val);
          }
        }
        return sql.length > 1 ? sql.join(" ") : "";
      }
      havingRaw(statement) {
        return this._not(statement, "") + this.formatter.unwrapRaw(statement.value);
      }
      havingWrapped(statement) {
        const val = this.formatter.rawOrFn(statement.value, "where");
        return val && this._not(statement, "") + "(" + val.slice(6) + ")" || "";
      }
      havingBasic(statement) {
        return this._not(statement, "") + this.formatter.wrap(statement.column) + " " + this.formatter.operator(statement.operator) + " " + this.formatter.parameter(statement.value);
      }
      havingNull(statement) {
        return this.formatter.wrap(statement.column) + " is " + this._not(statement, "null");
      }
      havingExists(statement) {
        return this._not(statement, "exists") + " (" + this.formatter.rawOrFn(statement.value) + ")";
      }
      havingBetween(statement) {
        return this.formatter.wrap(statement.column) + " " + this._not(statement, "between") + " " + map2(statement.value, bind(this.formatter.parameter, this.formatter)).join(
          " and "
        );
      }
      havingIn(statement) {
        if (Array.isArray(statement.column))
          return this.multiHavingIn(statement);
        return this.formatter.wrap(statement.column) + " " + this._not(statement, "in ") + this.wrap(this.formatter.parameterize(statement.value));
      }
      multiHavingIn(statement) {
        let i = -1, sql = `(${this.formatter.columnize(statement.column)}) `;
        sql += this._not(statement, "in ") + "((";
        while (++i < statement.value.length) {
          if (i !== 0)
            sql += "),(";
          sql += this.formatter.parameterize(statement.value[i]);
        }
        return sql + "))";
      }
      // Compile the "union" queries attached to the main query.
      union() {
        const onlyUnions = this.onlyUnions();
        const unions = this.grouped.union;
        if (!unions)
          return "";
        let sql = "";
        for (let i = 0, l = unions.length; i < l; i++) {
          const union = unions[i];
          if (i > 0)
            sql += " ";
          if (i > 0 || !onlyUnions)
            sql += union.clause + " ";
          const statement = this.formatter.rawOrFn(union.value);
          if (statement) {
            if (union.wrap)
              sql += "(";
            sql += statement;
            if (union.wrap)
              sql += ")";
          }
        }
        return sql;
      }
      // If we haven't specified any columns or a `tableName`, we're assuming this
      // is only being used for unions.
      onlyUnions() {
        return !this.grouped.columns && this.grouped.union && !this.tableName;
      }
      limit() {
        const noLimit = !this.single.limit && this.single.limit !== 0;
        if (noLimit)
          return "";
        return `limit ${this.formatter.parameter(this.single.limit)}`;
      }
      offset() {
        if (!this.single.offset)
          return "";
        return `offset ${this.formatter.parameter(this.single.offset)}`;
      }
      // Compiles a `delete` query.
      del() {
        const { tableName } = this;
        const withSQL = this.with();
        const wheres = this.where();
        return withSQL + `delete from ${this.single.only ? "only " : ""}${tableName}` + (wheres ? ` ${wheres}` : "");
      }
      // Compiles a `truncate` query.
      truncate() {
        return `truncate ${this.tableName}`;
      }
      // Compiles the "locks".
      lock() {
        if (this.single.lock) {
          return this[this.single.lock]();
        }
      }
      // Compiles the wait mode on the locks.
      waitMode() {
        if (this.single.waitMode) {
          return this[this.single.waitMode]();
        }
      }
      // Fail on unsupported databases
      skipLocked() {
        throw new Error(
          ".skipLocked() is currently only supported on MySQL 8.0+ and PostgreSQL 9.5+"
        );
      }
      // Fail on unsupported databases
      noWait() {
        throw new Error(
          ".noWait() is currently only supported on MySQL 8.0+, MariaDB 10.3.0+ and PostgreSQL 9.5+"
        );
      }
      distinctOn(value2) {
        throw new Error(".distinctOn() is currently only supported on PostgreSQL");
      }
      // On Clause
      // ------
      onWrapped(clause) {
        const self = this;
        const wrapJoin = new JoinClause();
        clause.value.call(wrapJoin, wrapJoin);
        let sql = "";
        wrapJoin.clauses.forEach(function(wrapClause, ii) {
          if (ii > 0) {
            sql += ` ${wrapClause.bool} `;
          }
          const val = self[wrapClause.type](wrapClause);
          if (val) {
            sql += val;
          }
        });
        if (sql.length) {
          return `(${sql})`;
        }
        return "";
      }
      onBasic(clause) {
        return this.formatter.wrap(clause.column) + " " + this.formatter.operator(clause.operator) + " " + this.formatter.wrap(clause.value);
      }
      onVal(clause) {
        return this.formatter.wrap(clause.column) + " " + this.formatter.operator(clause.operator) + " " + this.formatter.parameter(clause.value);
      }
      onRaw(clause) {
        return this.formatter.unwrapRaw(clause.value);
      }
      onUsing(clause) {
        return "(" + this.formatter.columnize(clause.column) + ")";
      }
      // Where Clause
      // ------
      whereIn(statement) {
        let columns = null;
        if (Array.isArray(statement.column)) {
          columns = `(${this.formatter.columnize(statement.column)})`;
        } else {
          columns = this.formatter.wrap(statement.column);
        }
        const values2 = this.formatter.values(statement.value);
        return `${columns} ${this._not(statement, "in ")}${values2}`;
      }
      whereNull(statement) {
        return this.formatter.wrap(statement.column) + " is " + this._not(statement, "null");
      }
      // Compiles a basic "where" clause.
      whereBasic(statement) {
        return this._not(statement, "") + this.formatter.wrap(statement.column) + " " + this.formatter.operator(statement.operator) + " " + (statement.asColumn ? this.formatter.wrap(statement.value) : this.formatter.parameter(statement.value));
      }
      whereExists(statement) {
        return this._not(statement, "exists") + " (" + this.formatter.rawOrFn(statement.value) + ")";
      }
      whereWrapped(statement) {
        const val = this.formatter.rawOrFn(statement.value, "where");
        return val && this._not(statement, "") + "(" + val.slice(6) + ")" || "";
      }
      whereBetween(statement) {
        return this.formatter.wrap(statement.column) + " " + this._not(statement, "between") + " " + map2(statement.value, bind(this.formatter.parameter, this.formatter)).join(
          " and "
        );
      }
      // Compiles a "whereRaw" query.
      whereRaw(statement) {
        return this._not(statement, "") + this.formatter.unwrapRaw(statement.value);
      }
      wrap(str) {
        if (str.charAt(0) !== "(")
          return `(${str})`;
        return str;
      }
      // Compiles all `with` statements on the query.
      with() {
        if (!this.grouped.with || !this.grouped.with.length) {
          return "";
        }
        const withs = this.grouped.with;
        if (!withs)
          return;
        const sql = [];
        let i = -1;
        let isRecursive = false;
        while (++i < withs.length) {
          const stmt = withs[i];
          if (stmt.recursive) {
            isRecursive = true;
          }
          const val = this[stmt.type](stmt);
          sql.push(val);
        }
        return `with ${isRecursive ? "recursive " : ""}${sql.join(", ")} `;
      }
      withWrapped(statement) {
        const val = this.formatter.rawOrFn(statement.value);
        return val && this.formatter.columnize(statement.alias) + " as (" + val + ")" || "";
      }
      // Determines whether to add a "not" prefix to the where clause.
      _not(statement, str) {
        if (statement.not)
          return `not ${str}`;
        return str;
      }
      _prepInsert(data) {
        const isRaw = this.formatter.rawOrFn(data);
        if (isRaw)
          return isRaw;
        let columns = [];
        const values2 = [];
        if (!Array.isArray(data))
          data = data ? [data] : [];
        let i = -1;
        while (++i < data.length) {
          if (data[i] == null)
            break;
          if (i === 0)
            columns = Object.keys(data[i]).sort();
          const row = new Array(columns.length);
          const keys2 = Object.keys(data[i]);
          let j = -1;
          while (++j < keys2.length) {
            const key = keys2[j];
            let idx = columns.indexOf(key);
            if (idx === -1) {
              columns = columns.concat(key).sort();
              idx = columns.indexOf(key);
              let k = -1;
              while (++k < values2.length) {
                values2[k].splice(idx, 0, void 0);
              }
              row.splice(idx, 0, void 0);
            }
            row[idx] = data[i][key];
          }
          values2.push(row);
        }
        return {
          columns,
          values: values2
        };
      }
      // "Preps" the update.
      _prepUpdate(data = {}) {
        const { counter = {} } = this.single;
        for (const column of Object.keys(counter)) {
          if (has5(data, column)) {
            this.client.logger.warn(
              `increment/decrement called for a column that has already been specified in main .update() call. Ignoring increment/decrement and using value from .update() call.`
            );
            continue;
          }
          let value2 = counter[column];
          const symbol = value2 < 0 ? "-" : "+";
          if (symbol === "-") {
            value2 = -value2;
          }
          data[column] = this.client.raw(`?? ${symbol} ?`, [column, value2]);
        }
        data = omitBy(data, isUndefined3);
        const vals = [];
        const columns = Object.keys(data);
        let i = -1;
        while (++i < columns.length) {
          vals.push(
            this.formatter.wrap(columns[i]) + " = " + this.formatter.parameter(data[columns[i]])
          );
        }
        if (isEmpty2(vals)) {
          throw new Error(
            [
              "Empty .update() call detected!",
              "Update data does not contain any values to update.",
              "This will result in a faulty query.",
              this.single.table ? `Table: ${this.single.table}.` : "",
              this.single.update ? `Columns: ${Object.keys(this.single.update)}.` : ""
            ].join(" ")
          );
        }
        return vals;
      }
      _formatGroupsItemValue(value2) {
        const { formatter } = this;
        if (value2 instanceof Raw) {
          return formatter.unwrapRaw(value2);
        } else if (value2 instanceof QueryBuilder) {
          return "(" + formatter.columnize(value2) + ")";
        } else {
          return formatter.columnize(value2);
        }
      }
      // Compiles the `order by` statements.
      _groupsOrders(type) {
        const items = this.grouped[type];
        if (!items)
          return "";
        const { formatter } = this;
        const sql = items.map((item) => {
          const column = this._formatGroupsItemValue(item.value);
          const direction = type === "order" && item.type !== "orderByRaw" ? ` ${formatter.direction(item.direction)}` : "";
          return column + direction;
        });
        return sql.length ? type + " by " + sql.join(", ") : "";
      }
      // Get the table name, wrapping it if necessary.
      // Implemented as a property to prevent ordering issues as described in #704.
      get tableName() {
        if (!this._tableName) {
          let tableName = this.single.table;
          const schemaName = this.single.schema;
          if (tableName && schemaName)
            tableName = `${schemaName}.${tableName}`;
          this._tableName = tableName ? (
            // Wrap subQuery with parenthesis, #3485
            this.formatter.wrap(tableName, tableName instanceof QueryBuilder)
          ) : "";
        }
        return this._tableName;
      }
    };
    module2.exports = QueryCompiler;
  }
});

// ../node_modules/knex/lib/schema/builder.js
var require_builder2 = __commonJS({
  "../node_modules/knex/lib/schema/builder.js"(exports, module2) {
    "use strict";
    var { inherits } = require("util");
    var { EventEmitter } = require("events");
    var toArray2 = require("lodash/toArray");
    var { addQueryContext } = require_helpers();
    var saveAsyncStack = require_save_async_stack();
    function SchemaBuilder(client) {
      this.client = client;
      this._sequence = [];
      if (client.config) {
        this._debug = client.config.debug;
        saveAsyncStack(this, 4);
      }
    }
    inherits(SchemaBuilder, EventEmitter);
    [
      "createTable",
      "createTableIfNotExists",
      "createSchema",
      "createSchemaIfNotExists",
      "dropSchema",
      "dropSchemaIfExists",
      "createExtension",
      "createExtensionIfNotExists",
      "dropExtension",
      "dropExtensionIfExists",
      "table",
      "alterTable",
      "hasTable",
      "hasColumn",
      "dropTable",
      "renameTable",
      "dropTableIfExists",
      "raw"
    ].forEach(function(method) {
      SchemaBuilder.prototype[method] = function() {
        if (method === "createTableIfNotExists") {
          this.client.logger.warn(
            [
              "Use async .hasTable to check if table exists and then use plain .createTable. Since ",
              '.createTableIfNotExists actually just generates plain "CREATE TABLE IF NOT EXIST..." ',
              "query it will not work correctly if there are any alter table queries generated for ",
              "columns afterwards. To not break old migrations this function is left untouched for now",
              ", but it should not be used when writing new code and it is removed from documentation."
            ].join("")
          );
        }
        if (method === "table")
          method = "alterTable";
        this._sequence.push({
          method,
          args: toArray2(arguments)
        });
        return this;
      };
    });
    require_interface()(SchemaBuilder);
    addQueryContext(SchemaBuilder);
    SchemaBuilder.prototype.withSchema = function(schemaName) {
      this._schema = schemaName;
      return this;
    };
    SchemaBuilder.prototype.toString = function() {
      return this.toQuery();
    };
    SchemaBuilder.prototype.toSQL = function() {
      return this.client.schemaCompiler(this).toSQL();
    };
    module2.exports = SchemaBuilder;
  }
});

// ../node_modules/knex/lib/schema/helpers.js
var require_helpers2 = __commonJS({
  "../node_modules/knex/lib/schema/helpers.js"(exports, module2) {
    "use strict";
    var tail = require("lodash/tail");
    var { isString: isString2 } = require_is();
    function pushQuery(query) {
      if (!query)
        return;
      if (isString2(query)) {
        query = { sql: query };
      }
      if (!query.bindings) {
        query.bindings = this.formatter.bindings;
      }
      this.sequence.push(query);
      this.formatter = this.client.formatter(this._commonBuilder);
    }
    function pushAdditional(fn) {
      const child = new this.constructor(
        this.client,
        this.tableCompiler,
        this.columnBuilder
      );
      fn.call(child, tail(arguments));
      this.sequence.additional = (this.sequence.additional || []).concat(
        child.sequence
      );
    }
    function unshiftQuery(query) {
      if (!query)
        return;
      if (isString2(query)) {
        query = { sql: query };
      }
      if (!query.bindings) {
        query.bindings = this.formatter.bindings;
      }
      this.sequence.unshift(query);
      this.formatter = this.client.formatter(this._commonBuilder);
    }
    module2.exports = {
      pushAdditional,
      pushQuery,
      unshiftQuery
    };
  }
});

// ../node_modules/knex/lib/schema/compiler.js
var require_compiler2 = __commonJS({
  "../node_modules/knex/lib/schema/compiler.js"(exports, module2) {
    "use strict";
    var { pushQuery, pushAdditional, unshiftQuery } = require_helpers2();
    function SchemaCompiler(client, builder) {
      this.builder = builder;
      this._commonBuilder = this.builder;
      this.client = client;
      this.schema = builder._schema;
      this.formatter = client.formatter(builder);
      this.sequence = [];
    }
    function throwOnlyPGError(operationName) {
      throw new Error(
        `${operationName} is not supported for this dialect (only PostgreSQL supports it currently).`
      );
    }
    Object.assign(SchemaCompiler.prototype, {
      pushQuery,
      pushAdditional,
      unshiftQuery,
      createTable: buildTable("create"),
      createTableIfNotExists: buildTable("createIfNot"),
      createSchema: () => {
        throwOnlyPGError("createSchema");
      },
      createSchemaIfNotExists: () => {
        throwOnlyPGError("createSchemaIfNotExists");
      },
      dropSchema: () => {
        throwOnlyPGError("dropSchema");
      },
      dropSchemaIfExists: () => {
        throwOnlyPGError("dropSchemaIfExists");
      },
      alterTable: buildTable("alter"),
      dropTablePrefix: "drop table ",
      dropTable(tableName) {
        this.pushQuery(
          this.dropTablePrefix + this.formatter.wrap(prefixedTableName(this.schema, tableName))
        );
      },
      dropTableIfExists(tableName) {
        this.pushQuery(
          this.dropTablePrefix + "if exists " + this.formatter.wrap(prefixedTableName(this.schema, tableName))
        );
      },
      raw(sql, bindings) {
        this.sequence.push(this.client.raw(sql, bindings).toSQL());
      },
      toSQL() {
        const sequence = this.builder._sequence;
        for (let i = 0, l = sequence.length; i < l; i++) {
          const query = sequence[i];
          this[query.method].apply(this, query.args);
        }
        return this.sequence;
      }
    });
    function buildTable(type) {
      return function(tableName, fn) {
        const builder = this.client.tableBuilder(type, tableName, fn);
        const queryContext = this.builder.queryContext();
        if (queryContext !== void 0 && builder.queryContext() === void 0) {
          builder.queryContext(queryContext);
        }
        builder.setSchema(this.schema);
        const sql = builder.toSQL();
        for (let i = 0, l = sql.length; i < l; i++) {
          this.sequence.push(sql[i]);
        }
      };
    }
    function prefixedTableName(prefix, table) {
      return prefix ? `${prefix}.${table}` : table;
    }
    module2.exports = SchemaCompiler;
  }
});

// ../node_modules/knex/lib/schema/tablebuilder.js
var require_tablebuilder = __commonJS({
  "../node_modules/knex/lib/schema/tablebuilder.js"(exports, module2) {
    "use strict";
    var each = require("lodash/each");
    var extend = require("lodash/extend");
    var toArray2 = require("lodash/toArray");
    var helpers = require_helpers();
    var { isString: isString2, isFunction } = require_is();
    function TableBuilder(client, method, tableName, fn) {
      this.client = client;
      this._fn = fn;
      this._method = method;
      this._schemaName = void 0;
      this._tableName = tableName;
      this._statements = [];
      this._single = {};
      if (!isFunction(this._fn)) {
        throw new TypeError(
          "A callback function must be supplied to calls against `.createTable` and `.table`"
        );
      }
    }
    TableBuilder.prototype.setSchema = function(schemaName) {
      this._schemaName = schemaName;
    };
    TableBuilder.prototype.toSQL = function() {
      if (this._method === "alter") {
        extend(this, AlterMethods);
      }
      this._fn.call(this, this);
      return this.client.tableCompiler(this).toSQL();
    };
    each(
      [
        // Each of the index methods can be called individually, with the
        // column name to be used, e.g. table.unique('column').
        "index",
        "primary",
        "unique",
        // Key specific
        "dropPrimary",
        "dropUnique",
        "dropIndex",
        "dropForeign"
      ],
      function(method) {
        TableBuilder.prototype[method] = function() {
          this._statements.push({
            grouping: "alterTable",
            method,
            args: toArray2(arguments)
          });
          return this;
        };
      }
    );
    var specialMethods = {
      mysql: ["engine", "charset", "collate"],
      postgresql: ["inherits"]
    };
    each(specialMethods, function(methods, dialect) {
      methods.forEach(function(method) {
        TableBuilder.prototype[method] = function(value2) {
          if (this.client.dialect !== dialect) {
            throw new Error(
              `Knex only supports ${method} statement with ${dialect}.`
            );
          }
          if (this._method === "alter") {
            throw new Error(
              `Knex does not support altering the ${method} outside of create table, please use knex.raw statement.`
            );
          }
          this._single[method] = value2;
        };
      });
    });
    helpers.addQueryContext(TableBuilder);
    var columnTypes = [
      // Numeric
      "tinyint",
      "smallint",
      "mediumint",
      "int",
      "bigint",
      "decimal",
      "float",
      "double",
      "real",
      "bit",
      "boolean",
      "serial",
      // Date / Time
      "date",
      "datetime",
      "timestamp",
      "time",
      "year",
      // String
      "char",
      "varchar",
      "tinytext",
      "tinyText",
      "text",
      "mediumtext",
      "mediumText",
      "longtext",
      "longText",
      "binary",
      "varbinary",
      "tinyblob",
      "tinyBlob",
      "mediumblob",
      "mediumBlob",
      "blob",
      "longblob",
      "longBlob",
      "enum",
      "set",
      // Increments, Aliases, and Additional
      "bool",
      "dateTime",
      "increments",
      "bigincrements",
      "bigIncrements",
      "integer",
      "biginteger",
      "bigInteger",
      "string",
      "json",
      "jsonb",
      "uuid",
      "enu",
      "specificType"
    ];
    each(columnTypes, function(type) {
      TableBuilder.prototype[type] = function() {
        const args = toArray2(arguments);
        const builder = this.client.columnBuilder(this, type, args);
        this._statements.push({
          grouping: "columns",
          builder
        });
        return builder;
      };
    });
    TableBuilder.prototype.timestamps = function timestamps() {
      const method = arguments[0] === true ? "timestamp" : "datetime";
      const createdAt = this[method]("created_at");
      const updatedAt = this[method]("updated_at");
      if (arguments[1] === true) {
        const now = this.client.raw("CURRENT_TIMESTAMP");
        createdAt.notNullable().defaultTo(now);
        updatedAt.notNullable().defaultTo(now);
      }
      return;
    };
    TableBuilder.prototype.comment = function(value2) {
      if (typeof value2 !== "string") {
        throw new TypeError("Table comment must be string");
      }
      this._single.comment = value2;
    };
    TableBuilder.prototype.foreign = function(column, keyName) {
      const foreignData = { column, keyName };
      this._statements.push({
        grouping: "alterTable",
        method: "foreign",
        args: [foreignData]
      });
      let returnObj = {
        references(tableColumn) {
          let pieces;
          if (isString2(tableColumn)) {
            pieces = tableColumn.split(".");
          }
          if (!pieces || pieces.length === 1) {
            foreignData.references = pieces ? pieces[0] : tableColumn;
            return {
              on(tableName) {
                if (typeof tableName !== "string") {
                  throw new TypeError(
                    `Expected tableName to be a string, got: ${typeof tableName}`
                  );
                }
                foreignData.inTable = tableName;
                return returnObj;
              },
              inTable() {
                return this.on.apply(this, arguments);
              }
            };
          }
          foreignData.inTable = pieces[0];
          foreignData.references = pieces[1];
          return returnObj;
        },
        withKeyName(keyName2) {
          foreignData.keyName = keyName2;
          return returnObj;
        },
        onUpdate(statement) {
          foreignData.onUpdate = statement;
          return returnObj;
        },
        onDelete(statement) {
          foreignData.onDelete = statement;
          return returnObj;
        },
        _columnBuilder(builder) {
          extend(builder, returnObj);
          returnObj = builder;
          return builder;
        }
      };
      return returnObj;
    };
    var AlterMethods = {
      // Renames the current column `from` the current
      // TODO: this.column(from).rename(to)
      renameColumn(from, to) {
        this._statements.push({
          grouping: "alterTable",
          method: "renameColumn",
          args: [from, to]
        });
        return this;
      },
      dropTimestamps() {
        return this.dropColumns(["created_at", "updated_at"]);
      }
      // TODO: changeType
    };
    AlterMethods.dropColumn = AlterMethods.dropColumns = function() {
      this._statements.push({
        grouping: "alterTable",
        method: "dropColumn",
        args: toArray2(arguments)
      });
      return this;
    };
    module2.exports = TableBuilder;
  }
});

// ../node_modules/knex/lib/schema/tablecompiler.js
var require_tablecompiler = __commonJS({
  "../node_modules/knex/lib/schema/tablecompiler.js"(exports, module2) {
    "use strict";
    var { pushAdditional, pushQuery, unshiftQuery } = require_helpers2();
    var helpers = require_helpers();
    var groupBy2 = require("lodash/groupBy");
    var indexOf2 = require("lodash/indexOf");
    var isEmpty2 = require("lodash/isEmpty");
    var tail = require("lodash/tail");
    function TableCompiler(client, tableBuilder) {
      this.client = client;
      this.tableBuilder = tableBuilder;
      this._commonBuilder = this.tableBuilder;
      this.method = tableBuilder._method;
      this.schemaNameRaw = tableBuilder._schemaName;
      this.tableNameRaw = tableBuilder._tableName;
      this.single = tableBuilder._single;
      this.grouped = groupBy2(tableBuilder._statements, "grouping");
      this.formatter = client.formatter(tableBuilder);
      this.sequence = [];
      this._formatting = client.config && client.config.formatting;
    }
    TableCompiler.prototype.pushQuery = pushQuery;
    TableCompiler.prototype.pushAdditional = pushAdditional;
    TableCompiler.prototype.unshiftQuery = unshiftQuery;
    TableCompiler.prototype.toSQL = function() {
      this[this.method]();
      return this.sequence;
    };
    TableCompiler.prototype.lowerCase = true;
    TableCompiler.prototype.createAlterTableMethods = null;
    TableCompiler.prototype.create = function(ifNot) {
      const columnBuilders = this.getColumns();
      const columns = columnBuilders.map((col) => col.toSQL());
      const columnTypes = this.getColumnTypes(columns);
      if (this.createAlterTableMethods) {
        this.alterTableForCreate(columnTypes);
      }
      this.createQuery(columnTypes, ifNot);
      this.columnQueries(columns);
      delete this.single.comment;
      this.alterTable();
    };
    TableCompiler.prototype.createIfNot = function() {
      this.create(true);
    };
    TableCompiler.prototype.alter = function() {
      const addColBuilders = this.getColumns();
      const addColumns = addColBuilders.map((col) => col.toSQL());
      const alterColBuilders = this.getColumns("alter");
      const alterColumns = alterColBuilders.map((col) => col.toSQL());
      const addColumnTypes = this.getColumnTypes(addColumns);
      const alterColumnTypes = this.getColumnTypes(alterColumns);
      this.addColumns(addColumnTypes);
      this.alterColumns(alterColumnTypes, alterColBuilders);
      this.columnQueries(addColumns);
      this.columnQueries(alterColumns);
      this.alterTable();
    };
    TableCompiler.prototype.foreign = function(foreignData) {
      if (foreignData.inTable && foreignData.references) {
        const keyName = foreignData.keyName ? this.formatter.wrap(foreignData.keyName) : this._indexCommand("foreign", this.tableNameRaw, foreignData.column);
        const column = this.formatter.columnize(foreignData.column);
        const references = this.formatter.columnize(foreignData.references);
        const inTable = this.formatter.wrap(foreignData.inTable);
        const onUpdate = foreignData.onUpdate ? (this.lowerCase ? " on update " : " ON UPDATE ") + foreignData.onUpdate : "";
        const onDelete = foreignData.onDelete ? (this.lowerCase ? " on delete " : " ON DELETE ") + foreignData.onDelete : "";
        if (this.lowerCase) {
          this.pushQuery(
            (!this.forCreate ? `alter table ${this.tableName()} add ` : "") + "constraint " + keyName + " foreign key (" + column + ") references " + inTable + " (" + references + ")" + onUpdate + onDelete
          );
        } else {
          this.pushQuery(
            (!this.forCreate ? `ALTER TABLE ${this.tableName()} ADD ` : "") + "CONSTRAINT " + keyName + " FOREIGN KEY (" + column + ") REFERENCES " + inTable + " (" + references + ")" + onUpdate + onDelete
          );
        }
      }
    };
    TableCompiler.prototype.getColumnTypes = (columns) => columns.reduce(
      function(memo, columnSQL) {
        const column = columnSQL[0];
        memo.sql.push(column.sql);
        memo.bindings.concat(column.bindings);
        return memo;
      },
      { sql: [], bindings: [] }
    );
    TableCompiler.prototype.columnQueries = function(columns) {
      const queries = columns.reduce(function(memo, columnSQL) {
        const column = tail(columnSQL);
        if (!isEmpty2(column))
          return memo.concat(column);
        return memo;
      }, []);
      for (const q of queries) {
        this.pushQuery(q);
      }
    };
    TableCompiler.prototype.addColumnsPrefix = "add column ";
    TableCompiler.prototype.addColumns = function(columns, prefix) {
      prefix = prefix || this.addColumnsPrefix;
      if (columns.sql.length > 0) {
        const columnSql = columns.sql.map((column) => {
          return prefix + column;
        });
        this.pushQuery({
          sql: (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + columnSql.join(", "),
          bindings: columns.bindings
        });
      }
    };
    TableCompiler.prototype.alterColumnsPrefix = "alter column ";
    TableCompiler.prototype.alterColumns = function(columns, colBuilders) {
      if (columns.sql.length > 0) {
        this.addColumns(columns, this.alterColumnsPrefix, colBuilders);
      }
    };
    TableCompiler.prototype.getColumns = function(method) {
      const columns = this.grouped.columns || [];
      method = method || "add";
      const queryContext = this.tableBuilder.queryContext();
      return columns.filter((column) => column.builder._method === method).map((column) => {
        if (queryContext !== void 0 && column.builder.queryContext() === void 0) {
          column.builder.queryContext(queryContext);
        }
        return this.client.columnCompiler(this, column.builder);
      });
    };
    TableCompiler.prototype.tableName = function() {
      const name = this.schemaNameRaw ? `${this.schemaNameRaw}.${this.tableNameRaw}` : this.tableNameRaw;
      return this.formatter.wrap(name);
    };
    TableCompiler.prototype.alterTable = function() {
      const alterTable = this.grouped.alterTable || [];
      for (let i = 0, l = alterTable.length; i < l; i++) {
        const statement = alterTable[i];
        if (this[statement.method]) {
          this[statement.method].apply(this, statement.args);
        } else {
          this.client.logger.error(`Debug: ${statement.method} does not exist`);
        }
      }
      for (const item in this.single) {
        if (typeof this[item] === "function")
          this[item](this.single[item]);
      }
    };
    TableCompiler.prototype.alterTableForCreate = function(columnTypes) {
      this.forCreate = true;
      const savedSequence = this.sequence;
      const alterTable = this.grouped.alterTable || [];
      this.grouped.alterTable = [];
      for (let i = 0, l = alterTable.length; i < l; i++) {
        const statement = alterTable[i];
        if (indexOf2(this.createAlterTableMethods, statement.method) < 0) {
          this.grouped.alterTable.push(statement);
          continue;
        }
        if (this[statement.method]) {
          this.sequence = [];
          this[statement.method].apply(this, statement.args);
          columnTypes.sql.push(this.sequence[0].sql);
        } else {
          this.client.logger.error(`Debug: ${statement.method} does not exist`);
        }
      }
      this.sequence = savedSequence;
      this.forCreate = false;
    };
    TableCompiler.prototype.dropIndex = function(value2) {
      this.pushQuery(`drop index${value2}`);
    };
    TableCompiler.prototype.dropUnique = TableCompiler.prototype.dropForeign = function() {
      throw new Error("Method implemented in the dialect driver");
    };
    TableCompiler.prototype.dropColumnPrefix = "drop column ";
    TableCompiler.prototype.dropColumn = function() {
      const columns = helpers.normalizeArr.apply(null, arguments);
      const drops = (Array.isArray(columns) ? columns : [columns]).map((column) => {
        return this.dropColumnPrefix + this.formatter.wrap(column);
      });
      this.pushQuery(
        (this.lowerCase ? "alter table " : "ALTER TABLE ") + this.tableName() + " " + drops.join(", ")
      );
    };
    TableCompiler.prototype._indexCommand = function(type, tableName, columns) {
      if (!Array.isArray(columns))
        columns = columns ? [columns] : [];
      const table = tableName.replace(/\.|-/g, "_");
      const indexName = (table + "_" + columns.join("_") + "_" + type).toLowerCase();
      return this.formatter.wrap(indexName);
    };
    module2.exports = TableCompiler;
  }
});

// ../node_modules/knex/lib/schema/columnbuilder.js
var require_columnbuilder = __commonJS({
  "../node_modules/knex/lib/schema/columnbuilder.js"(exports, module2) {
    "use strict";
    var extend = require("lodash/extend");
    var toArray2 = require("lodash/toArray");
    var { addQueryContext } = require_helpers();
    function ColumnBuilder(client, tableBuilder, type, args) {
      this.client = client;
      this._method = "add";
      this._single = {};
      this._modifiers = {};
      this._statements = [];
      this._type = columnAlias[type] || type;
      this._args = args;
      this._tableBuilder = tableBuilder;
      if (tableBuilder._method === "alter") {
        extend(this, AlterMethods);
      }
    }
    var modifiers = [
      "default",
      "defaultsTo",
      "defaultTo",
      "unsigned",
      "nullable",
      "first",
      "after",
      "comment",
      "collate"
    ];
    var aliasMethod = {
      default: "defaultTo",
      defaultsTo: "defaultTo"
    };
    modifiers.forEach(function(method) {
      const key = aliasMethod[method] || method;
      ColumnBuilder.prototype[method] = function() {
        this._modifiers[key] = toArray2(arguments);
        return this;
      };
    });
    addQueryContext(ColumnBuilder);
    ColumnBuilder.prototype.notNull = ColumnBuilder.prototype.notNullable = function notNullable() {
      return this.nullable(false);
    };
    ["index", "primary", "unique"].forEach(function(method) {
      ColumnBuilder.prototype[method] = function() {
        if (this._type.toLowerCase().indexOf("increments") === -1) {
          this._tableBuilder[method].apply(
            this._tableBuilder,
            [this._args[0]].concat(toArray2(arguments))
          );
        }
        return this;
      };
    });
    ColumnBuilder.prototype.references = function(value2) {
      return this._tableBuilder.foreign.call(this._tableBuilder, this._args[0], void 0, this)._columnBuilder(this).references(value2);
    };
    var AlterMethods = {};
    AlterMethods.drop = function() {
      this._single.drop = true;
      return this;
    };
    AlterMethods.alterType = function(type) {
      this._statements.push({
        grouping: "alterType",
        value: type
      });
      return this;
    };
    AlterMethods.alter = function() {
      this._method = "alter";
      return this;
    };
    var columnAlias = {
      float: "floating",
      enum: "enu",
      boolean: "bool",
      string: "varchar",
      bigint: "bigInteger"
    };
    module2.exports = ColumnBuilder;
  }
});

// ../node_modules/knex/lib/schema/columncompiler.js
var require_columncompiler = __commonJS({
  "../node_modules/knex/lib/schema/columncompiler.js"(exports, module2) {
    "use strict";
    var Raw = require_raw();
    var helpers = require_helpers2();
    var groupBy2 = require("lodash/groupBy");
    var first3 = require("lodash/first");
    var has5 = require("lodash/has");
    var tail = require("lodash/tail");
    var { isObject } = require_is();
    function ColumnCompiler(client, tableCompiler, columnBuilder) {
      this.client = client;
      this.tableCompiler = tableCompiler;
      this.columnBuilder = columnBuilder;
      this._commonBuilder = this.columnBuilder;
      this.args = columnBuilder._args;
      this.type = columnBuilder._type.toLowerCase();
      this.grouped = groupBy2(columnBuilder._statements, "grouping");
      this.modified = columnBuilder._modifiers;
      this.isIncrements = this.type.indexOf("increments") !== -1;
      this.formatter = client.formatter(columnBuilder);
      this.sequence = [];
      this.modifiers = [];
    }
    ColumnCompiler.prototype.pushQuery = helpers.pushQuery;
    ColumnCompiler.prototype.pushAdditional = helpers.pushAdditional;
    ColumnCompiler.prototype.unshiftQuery = helpers.unshiftQuery;
    ColumnCompiler.prototype._defaultMap = {
      columnName: function() {
        if (!this.isIncrements) {
          throw new Error(
            `You did not specify a column name for the ${this.type} column.`
          );
        }
        return "id";
      }
    };
    ColumnCompiler.prototype.defaults = function(label) {
      if (Object.prototype.hasOwnProperty.call(this._defaultMap, label)) {
        return this._defaultMap[label].bind(this)();
      } else {
        throw new Error(
          `There is no default for the specified identifier ${label}`
        );
      }
    };
    ColumnCompiler.prototype.toSQL = function() {
      this.pushQuery(this.compileColumn());
      if (this.sequence.additional) {
        this.sequence = this.sequence.concat(this.sequence.additional);
      }
      return this.sequence;
    };
    ColumnCompiler.prototype.compileColumn = function() {
      return this.formatter.wrap(this.getColumnName()) + " " + this.getColumnType() + this.getModifiers();
    };
    ColumnCompiler.prototype.getColumnName = function() {
      const value2 = first3(this.args);
      return value2 || this.defaults("columnName");
    };
    ColumnCompiler.prototype.getColumnType = function() {
      const type = this[this.type];
      return typeof type === "function" ? type.apply(this, tail(this.args)) : type;
    };
    ColumnCompiler.prototype.getModifiers = function() {
      const modifiers = [];
      for (let i = 0, l = this.modifiers.length; i < l; i++) {
        const modifier = this.modifiers[i];
        if (!this.isIncrements || this.isIncrements && modifier === "comment") {
          if (has5(this.modified, modifier)) {
            const val = this[modifier].apply(this, this.modified[modifier]);
            if (val)
              modifiers.push(val);
          }
        }
      }
      return modifiers.length > 0 ? ` ${modifiers.join(" ")}` : "";
    };
    ColumnCompiler.prototype.increments = "integer not null primary key autoincrement";
    ColumnCompiler.prototype.bigincrements = "integer not null primary key autoincrement";
    ColumnCompiler.prototype.integer = ColumnCompiler.prototype.smallint = ColumnCompiler.prototype.mediumint = "integer";
    ColumnCompiler.prototype.biginteger = "bigint";
    ColumnCompiler.prototype.varchar = function(length) {
      return `varchar(${this._num(length, 255)})`;
    };
    ColumnCompiler.prototype.text = "text";
    ColumnCompiler.prototype.tinyint = "tinyint";
    ColumnCompiler.prototype.floating = function(precision, scale) {
      return `float(${this._num(precision, 8)}, ${this._num(scale, 2)})`;
    };
    ColumnCompiler.prototype.decimal = function(precision, scale) {
      if (precision === null) {
        throw new Error(
          "Specifying no precision on decimal columns is not supported for that SQL dialect."
        );
      }
      return `decimal(${this._num(precision, 8)}, ${this._num(scale, 2)})`;
    };
    ColumnCompiler.prototype.binary = "blob";
    ColumnCompiler.prototype.bool = "boolean";
    ColumnCompiler.prototype.date = "date";
    ColumnCompiler.prototype.datetime = "datetime";
    ColumnCompiler.prototype.time = "time";
    ColumnCompiler.prototype.timestamp = "timestamp";
    ColumnCompiler.prototype.enu = "varchar";
    ColumnCompiler.prototype.bit = ColumnCompiler.prototype.json = "text";
    ColumnCompiler.prototype.uuid = "char(36)";
    ColumnCompiler.prototype.specifictype = (type) => type;
    ColumnCompiler.prototype.nullable = (nullable) => nullable === false ? "not null" : "null";
    ColumnCompiler.prototype.notNullable = function() {
      return this.nullable(false);
    };
    ColumnCompiler.prototype.defaultTo = function(value2) {
      if (value2 === void 0) {
        return "";
      } else if (value2 === null) {
        value2 = "null";
      } else if (value2 instanceof Raw) {
        value2 = value2.toQuery();
      } else if (this.type === "bool") {
        if (value2 === "false")
          value2 = 0;
        value2 = `'${value2 ? 1 : 0}'`;
      } else if ((this.type === "json" || this.type === "jsonb") && isObject(value2)) {
        value2 = `'${JSON.stringify(value2)}'`;
      } else {
        value2 = this.client._escapeBinding(value2.toString());
      }
      return `default ${value2}`;
    };
    ColumnCompiler.prototype._num = function(val, fallback) {
      if (val === void 0 || val === null)
        return fallback;
      const number = parseInt(val, 10);
      return isNaN(number) ? fallback : number;
    };
    module2.exports = ColumnCompiler;
  }
});

// ../node_modules/tarn/dist/TimeoutError.js
var require_TimeoutError = __commonJS({
  "../node_modules/tarn/dist/TimeoutError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError = class extends Error {
    };
    exports.TimeoutError = TimeoutError;
  }
});

// ../node_modules/tarn/dist/PromiseInspection.js
var require_PromiseInspection = __commonJS({
  "../node_modules/tarn/dist/PromiseInspection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection = class {
      constructor(args) {
        this._value = args.value;
        this._error = args.error;
      }
      value() {
        return this._value;
      }
      reason() {
        return this._error;
      }
      isRejected() {
        return !!this._error;
      }
      isFulfilled() {
        return !!this._value;
      }
    };
    exports.PromiseInspection = PromiseInspection;
  }
});

// ../node_modules/tarn/dist/utils.js
var require_utils = __commonJS({
  "../node_modules/tarn/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PromiseInspection_1 = require_PromiseInspection();
    function defer() {
      let resolve = null;
      let reject = null;
      const promise = new Promise((resolver, rejecter) => {
        resolve = resolver;
        reject = rejecter;
      });
      return {
        promise,
        resolve,
        reject
      };
    }
    exports.defer = defer;
    function now() {
      return Date.now();
    }
    exports.now = now;
    function duration(t1, t2) {
      return Math.abs(t2 - t1);
    }
    exports.duration = duration;
    function checkOptionalTime(time) {
      if (typeof time === "undefined") {
        return true;
      }
      return checkRequiredTime(time);
    }
    exports.checkOptionalTime = checkOptionalTime;
    function checkRequiredTime(time) {
      return typeof time === "number" && time === Math.round(time) && time > 0;
    }
    exports.checkRequiredTime = checkRequiredTime;
    function delay(millis) {
      return new Promise((resolve) => setTimeout(resolve, millis));
    }
    exports.delay = delay;
    function reflect(promise) {
      return promise.then((value2) => {
        return new PromiseInspection_1.PromiseInspection({ value: value2 });
      }).catch((error) => {
        return new PromiseInspection_1.PromiseInspection({ error });
      });
    }
    exports.reflect = reflect;
    function tryPromise(cb) {
      try {
        const result = cb();
        return Promise.resolve(result);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    exports.tryPromise = tryPromise;
  }
});

// ../node_modules/tarn/dist/PendingOperation.js
var require_PendingOperation = __commonJS({
  "../node_modules/tarn/dist/PendingOperation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TimeoutError_1 = require_TimeoutError();
    var utils_1 = require_utils();
    var PendingOperation = class {
      constructor(timeoutMillis) {
        this.timeoutMillis = timeoutMillis;
        this.deferred = utils_1.defer();
        this.possibleTimeoutCause = null;
        this.isRejected = false;
        this.promise = timeout(this.deferred.promise, timeoutMillis).catch((err) => {
          if (err instanceof TimeoutError_1.TimeoutError) {
            if (this.possibleTimeoutCause) {
              err = new TimeoutError_1.TimeoutError(this.possibleTimeoutCause.message);
            } else {
              err = new TimeoutError_1.TimeoutError("operation timed out for an unknown reason");
            }
          }
          this.isRejected = true;
          return Promise.reject(err);
        });
      }
      abort() {
        this.reject(new Error("aborted"));
      }
      reject(err) {
        this.deferred.reject(err);
      }
      resolve(value2) {
        this.deferred.resolve(value2);
      }
    };
    exports.PendingOperation = PendingOperation;
    function timeout(promise, time) {
      return new Promise((resolve, reject) => {
        const timeoutHandle = setTimeout(() => reject(new TimeoutError_1.TimeoutError()), time);
        promise.then((result) => {
          clearTimeout(timeoutHandle);
          resolve(result);
        }).catch((err) => {
          clearTimeout(timeoutHandle);
          reject(err);
        });
      });
    }
  }
});

// ../node_modules/tarn/dist/Resource.js
var require_Resource = __commonJS({
  "../node_modules/tarn/dist/Resource.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var utils_1 = require_utils();
    var Resource = class _Resource {
      constructor(resource) {
        this.resource = resource;
        this.resource = resource;
        this.timestamp = utils_1.now();
        this.deferred = utils_1.defer();
      }
      get promise() {
        return this.deferred.promise;
      }
      resolve() {
        this.deferred.resolve(void 0);
        return new _Resource(this.resource);
      }
    };
    exports.Resource = Resource;
  }
});

// ../node_modules/tarn/dist/Pool.js
var require_Pool = __commonJS({
  "../node_modules/tarn/dist/Pool.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var PendingOperation_1 = require_PendingOperation();
    var Resource_1 = require_Resource();
    var utils_1 = require_utils();
    var events_1 = require("events");
    var timers_1 = require("timers");
    var Pool = class {
      constructor(opt) {
        this.destroyed = false;
        this.emitter = new events_1.EventEmitter();
        opt = opt || {};
        if (!opt.create) {
          throw new Error("Tarn: opt.create function most be provided");
        }
        if (!opt.destroy) {
          throw new Error("Tarn: opt.destroy function most be provided");
        }
        if (typeof opt.min !== "number" || opt.min < 0 || opt.min !== Math.round(opt.min)) {
          throw new Error("Tarn: opt.min must be an integer >= 0");
        }
        if (typeof opt.max !== "number" || opt.max <= 0 || opt.max !== Math.round(opt.max)) {
          throw new Error("Tarn: opt.max must be an integer > 0");
        }
        if (opt.min > opt.max) {
          throw new Error("Tarn: opt.max is smaller than opt.min");
        }
        if (!utils_1.checkOptionalTime(opt.acquireTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.acquireTimeoutMillis " + JSON.stringify(opt.acquireTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.createTimeoutMillis " + JSON.stringify(opt.createTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.destroyTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.destroyTimeoutMillis " + JSON.stringify(opt.destroyTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.idleTimeoutMillis)) {
          throw new Error("Tarn: invalid opt.idleTimeoutMillis " + JSON.stringify(opt.idleTimeoutMillis));
        }
        if (!utils_1.checkOptionalTime(opt.reapIntervalMillis)) {
          throw new Error("Tarn: invalid opt.reapIntervalMillis " + JSON.stringify(opt.reapIntervalMillis));
        }
        if (!utils_1.checkOptionalTime(opt.createRetryIntervalMillis)) {
          throw new Error("Tarn: invalid opt.createRetryIntervalMillis " + JSON.stringify(opt.createRetryIntervalMillis));
        }
        const allowedKeys = {
          create: true,
          validate: true,
          destroy: true,
          log: true,
          min: true,
          max: true,
          acquireTimeoutMillis: true,
          createTimeoutMillis: true,
          destroyTimeoutMillis: true,
          idleTimeoutMillis: true,
          reapIntervalMillis: true,
          createRetryIntervalMillis: true,
          propagateCreateError: true
        };
        for (const key of Object.keys(opt)) {
          if (!allowedKeys[key]) {
            throw new Error(`Tarn: unsupported option opt.${key}`);
          }
        }
        this.creator = opt.create;
        this.destroyer = opt.destroy;
        this.validate = typeof opt.validate === "function" ? opt.validate : () => true;
        this.log = opt.log || (() => {
        });
        this.acquireTimeoutMillis = opt.acquireTimeoutMillis || 3e4;
        this.createTimeoutMillis = opt.createTimeoutMillis || 3e4;
        this.destroyTimeoutMillis = opt.destroyTimeoutMillis || 5e3;
        this.idleTimeoutMillis = opt.idleTimeoutMillis || 3e4;
        this.reapIntervalMillis = opt.reapIntervalMillis || 1e3;
        this.createRetryIntervalMillis = opt.createRetryIntervalMillis || 200;
        this.propagateCreateError = !!opt.propagateCreateError;
        this.min = opt.min;
        this.max = opt.max;
        this.used = [];
        this.free = [];
        this.pendingCreates = [];
        this.pendingAcquires = [];
        this.pendingDestroys = [];
        this.pendingValidations = [];
        this.destroyed = false;
        this.interval = null;
        this.eventId = 1;
      }
      numUsed() {
        return this.used.length;
      }
      numFree() {
        return this.free.length;
      }
      numPendingAcquires() {
        return this.pendingAcquires.length;
      }
      numPendingValidations() {
        return this.pendingValidations.length;
      }
      numPendingCreates() {
        return this.pendingCreates.length;
      }
      acquire() {
        const eventId = this.eventId++;
        this._executeEventHandlers("acquireRequest", eventId);
        const pendingAcquire = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
        this.pendingAcquires.push(pendingAcquire);
        pendingAcquire.promise = pendingAcquire.promise.then((resource) => {
          this._executeEventHandlers("acquireSuccess", eventId, resource);
          return resource;
        }).catch((err) => {
          this._executeEventHandlers("acquireFail", eventId, err);
          remove3(this.pendingAcquires, pendingAcquire);
          return Promise.reject(err);
        });
        this._tryAcquireOrCreate();
        return pendingAcquire;
      }
      release(resource) {
        this._executeEventHandlers("release", resource);
        for (let i = 0, l = this.used.length; i < l; ++i) {
          const used = this.used[i];
          if (used.resource === resource) {
            this.used.splice(i, 1);
            this.free.push(used.resolve());
            this._tryAcquireOrCreate();
            return true;
          }
        }
        return false;
      }
      isEmpty() {
        return [
          this.numFree(),
          this.numUsed(),
          this.numPendingAcquires(),
          this.numPendingValidations(),
          this.numPendingCreates()
        ].reduce((total, value2) => total + value2) === 0;
      }
      /**
       * Reaping cycle.
       */
      check() {
        const timestamp = utils_1.now();
        const newFree = [];
        const minKeep = this.min - this.used.length;
        const maxDestroy = this.free.length - minKeep;
        let numDestroyed = 0;
        this.free.forEach((free) => {
          if (utils_1.duration(timestamp, free.timestamp) >= this.idleTimeoutMillis && numDestroyed < maxDestroy) {
            numDestroyed++;
            this._destroy(free.resource);
          } else {
            newFree.push(free);
          }
        });
        this.free = newFree;
        if (this.isEmpty()) {
          this._stopReaping();
        }
      }
      destroy() {
        const eventId = this.eventId++;
        this._executeEventHandlers("poolDestroyRequest", eventId);
        this._stopReaping();
        this.destroyed = true;
        return utils_1.reflect(Promise.all(this.pendingCreates.map((create) => utils_1.reflect(create.promise))).then(() => {
          return new Promise((resolve, reject) => {
            if (this.numPendingValidations() === 0) {
              resolve();
              return;
            }
            const interval = setInterval(() => {
              if (this.numPendingValidations() === 0) {
                timers_1.clearInterval(interval);
                resolve();
              }
            }, 100);
          });
        }).then(() => {
          return Promise.all(this.used.map((used) => utils_1.reflect(used.promise)));
        }).then(() => {
          return Promise.all(this.pendingAcquires.map((acquire) => {
            acquire.abort();
            return utils_1.reflect(acquire.promise);
          }));
        }).then(() => {
          return Promise.all(this.free.map((free) => utils_1.reflect(this._destroy(free.resource))));
        }).then(() => {
          return Promise.all(this.pendingDestroys.map((pd) => pd.promise));
        }).then(() => {
          this.free = [];
          this.pendingAcquires = [];
        })).then((res) => {
          this._executeEventHandlers("poolDestroySuccess", eventId);
          this.emitter.removeAllListeners();
          return res;
        });
      }
      on(event, listener) {
        this.emitter.on(event, listener);
      }
      removeListener(event, listener) {
        this.emitter.removeListener(event, listener);
      }
      removeAllListeners(event) {
        this.emitter.removeAllListeners(event);
      }
      /**
       * The most important method that is called always when resources
       * are created / destroyed / acquired / released. In other words
       * every time when resources are moved from used to free or vice
       * versa.
       *
       * Either assigns free resources to pendingAcquires or creates new
       * resources if there is room for it in the pool.
       */
      _tryAcquireOrCreate() {
        if (this.destroyed) {
          return;
        }
        if (this._hasFreeResources()) {
          this._doAcquire();
        } else if (this._shouldCreateMoreResources()) {
          this._doCreate();
        }
      }
      _hasFreeResources() {
        return this.free.length > 0;
      }
      _doAcquire() {
        while (this._canAcquire()) {
          const pendingAcquire = this.pendingAcquires.shift();
          const free = this.free.pop();
          if (free === void 0 || pendingAcquire === void 0) {
            const errMessage = "this.free was empty while trying to acquire resource";
            this.log(`Tarn: ${errMessage}`, "warn");
            throw new Error(`Internal error, should never happen. ${errMessage}`);
          }
          this.pendingValidations.push(pendingAcquire);
          this.used.push(free);
          const abortAbleValidation = new PendingOperation_1.PendingOperation(this.acquireTimeoutMillis);
          pendingAcquire.promise.catch((err) => {
            abortAbleValidation.abort();
          });
          abortAbleValidation.promise.catch((err) => {
            this.log("Tarn: resource validator threw an exception " + err.stack, "warn");
            return false;
          }).then((validationSuccess) => {
            try {
              if (validationSuccess && !pendingAcquire.isRejected) {
                this._startReaping();
                pendingAcquire.resolve(free.resource);
              } else {
                remove3(this.used, free);
                if (!validationSuccess) {
                  this._destroy(free.resource);
                  setTimeout(() => {
                    this._tryAcquireOrCreate();
                  }, 0);
                } else {
                  this.free.push(free);
                }
                if (!pendingAcquire.isRejected) {
                  this.pendingAcquires.unshift(pendingAcquire);
                }
              }
            } finally {
              remove3(this.pendingValidations, pendingAcquire);
            }
          });
          this._validateResource(free.resource).then((validationSuccess) => {
            abortAbleValidation.resolve(validationSuccess);
          }).catch((err) => {
            abortAbleValidation.reject(err);
          });
        }
      }
      _canAcquire() {
        return this.free.length > 0 && this.pendingAcquires.length > 0;
      }
      _validateResource(resource) {
        try {
          return Promise.resolve(this.validate(resource));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _shouldCreateMoreResources() {
        return this.used.length + this.pendingCreates.length < this.max && this.pendingCreates.length < this.pendingAcquires.length;
      }
      _doCreate() {
        const pendingAcquiresBeforeCreate = this.pendingAcquires.slice();
        const pendingCreate = this._create();
        pendingCreate.promise.then(() => {
          this._tryAcquireOrCreate();
          return null;
        }).catch((err) => {
          if (this.propagateCreateError && this.pendingAcquires.length !== 0) {
            this.pendingAcquires[0].reject(err);
          }
          pendingAcquiresBeforeCreate.forEach((pendingAcquire) => {
            pendingAcquire.possibleTimeoutCause = err;
          });
          utils_1.delay(this.createRetryIntervalMillis).then(() => this._tryAcquireOrCreate());
        });
      }
      _create() {
        const eventId = this.eventId++;
        this._executeEventHandlers("createRequest", eventId);
        const pendingCreate = new PendingOperation_1.PendingOperation(this.createTimeoutMillis);
        pendingCreate.promise = pendingCreate.promise.catch((err) => {
          if (remove3(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          throw err;
        });
        this.pendingCreates.push(pendingCreate);
        callbackOrPromise(this.creator).then((resource) => {
          if (pendingCreate.isRejected) {
            this.destroyer(resource);
            return null;
          }
          remove3(this.pendingCreates, pendingCreate);
          this.free.push(new Resource_1.Resource(resource));
          pendingCreate.resolve(resource);
          this._executeEventHandlers("createSuccess", eventId, resource);
          return null;
        }).catch((err) => {
          if (pendingCreate.isRejected) {
            return null;
          }
          if (remove3(this.pendingCreates, pendingCreate)) {
            this._executeEventHandlers("createFail", eventId, err);
          }
          pendingCreate.reject(err);
          return null;
        });
        return pendingCreate;
      }
      _destroy(resource) {
        const eventId = this.eventId++;
        this._executeEventHandlers("destroyRequest", eventId, resource);
        const pendingDestroy = new PendingOperation_1.PendingOperation(this.destroyTimeoutMillis);
        const retVal = Promise.resolve().then(() => this.destroyer(resource));
        retVal.then(() => {
          pendingDestroy.resolve(resource);
        }).catch((err) => {
          pendingDestroy.reject(err);
        });
        this.pendingDestroys.push(pendingDestroy);
        return pendingDestroy.promise.then((res) => {
          this._executeEventHandlers("destroySuccess", eventId, resource);
          return res;
        }).catch((err) => this._logDestroyerError(eventId, resource, err)).then((res) => {
          const index = this.pendingDestroys.findIndex((pd) => pd === pendingDestroy);
          this.pendingDestroys.splice(index, 1);
          return res;
        });
      }
      _logDestroyerError(eventId, resource, err) {
        this._executeEventHandlers("destroyFail", eventId, resource, err);
        this.log("Tarn: resource destroyer threw an exception " + err.stack, "warn");
      }
      _startReaping() {
        if (!this.interval) {
          this._executeEventHandlers("startReaping");
          this.interval = setInterval(() => this.check(), this.reapIntervalMillis);
        }
      }
      _stopReaping() {
        if (this.interval !== null) {
          this._executeEventHandlers("stopReaping");
          timers_1.clearInterval(this.interval);
        }
        this.interval = null;
      }
      _executeEventHandlers(eventName, ...args) {
        const listeners = this.emitter.listeners(eventName);
        listeners.forEach((listener) => {
          try {
            listener(...args);
          } catch (err) {
            this.log(`Tarn: event handler "${eventName}" threw an exception ${err.stack}`, "warn");
          }
        });
      }
    };
    exports.Pool = Pool;
    function remove3(arr, item) {
      const idx = arr.indexOf(item);
      if (idx === -1) {
        return false;
      } else {
        arr.splice(idx, 1);
        return true;
      }
    }
    function callbackOrPromise(func) {
      return new Promise((resolve, reject) => {
        const callback = (err, resource) => {
          if (err) {
            reject(err);
          } else {
            resolve(resource);
          }
        };
        utils_1.tryPromise(() => func(callback)).then((res) => {
          if (res) {
            resolve(res);
          }
        }).catch((err) => {
          reject(err);
        });
      });
    }
  }
});

// ../node_modules/tarn/dist/tarn.js
var require_tarn = __commonJS({
  "../node_modules/tarn/dist/tarn.js"(exports, module2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Pool_1 = require_Pool();
    exports.Pool = Pool_1.Pool;
    var TimeoutError_1 = require_TimeoutError();
    exports.TimeoutError = TimeoutError_1.TimeoutError;
    module2.exports = {
      Pool: Pool_1.Pool,
      TimeoutError: TimeoutError_1.TimeoutError
    };
  }
});

// ../node_modules/knex/lib/query/string.js
var require_string = __commonJS({
  "../node_modules/knex/lib/query/string.js"(exports, module2) {
    "use strict";
    var charsRegex = /[\0\b\t\n\r\x1a"'\\]/g;
    var charsMap = {
      "\0": "\\0",
      "\b": "\\b",
      "	": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "": "\\Z",
      '"': '\\"',
      "'": "\\'",
      "\\": "\\\\"
    };
    function wrapEscape(escapeFn) {
      return function finalEscape(val, ctx = {}) {
        return escapeFn(val, finalEscape, ctx);
      };
    }
    function makeEscape(config2 = {}) {
      const finalEscapeDate = config2.escapeDate || dateToString;
      const finalEscapeArray = config2.escapeArray || arrayToList;
      const finalEscapeBuffer = config2.escapeBuffer || bufferToString;
      const finalEscapeString = config2.escapeString || escapeString;
      const finalEscapeObject = config2.escapeObject || escapeObject;
      const finalWrap = config2.wrap || wrapEscape;
      function escapeFn(val, finalEscape, ctx) {
        if (val === void 0 || val === null) {
          return "NULL";
        }
        switch (typeof val) {
          case "boolean":
            return val ? "true" : "false";
          case "number":
            return val + "";
          case "object":
            if (val instanceof Date) {
              val = finalEscapeDate(val, finalEscape, ctx);
            } else if (Array.isArray(val)) {
              return finalEscapeArray(val, finalEscape, ctx);
            } else if (Buffer.isBuffer(val)) {
              return finalEscapeBuffer(val, finalEscape, ctx);
            } else {
              return finalEscapeObject(val, finalEscape, ctx);
            }
        }
        return finalEscapeString(val, finalEscape, ctx);
      }
      return finalWrap ? finalWrap(escapeFn) : escapeFn;
    }
    function escapeObject(val, finalEscape, ctx) {
      if (val && typeof val.toSQL === "function") {
        return val.toSQL(ctx);
      } else {
        return JSON.stringify(val);
      }
    }
    function arrayToList(array, finalEscape, ctx) {
      let sql = "";
      for (let i = 0; i < array.length; i++) {
        const val = array[i];
        if (Array.isArray(val)) {
          sql += (i === 0 ? "" : ", ") + "(" + arrayToList(val, finalEscape, ctx) + ")";
        } else {
          sql += (i === 0 ? "" : ", ") + finalEscape(val, ctx);
        }
      }
      return sql;
    }
    function bufferToString(buffer) {
      return "X" + escapeString(buffer.toString("hex"));
    }
    function escapeString(val, finalEscape, ctx) {
      let chunkIndex = charsRegex.lastIndex = 0;
      let escapedVal = "";
      let match;
      while (match = charsRegex.exec(val)) {
        escapedVal += val.slice(chunkIndex, match.index) + charsMap[match[0]];
        chunkIndex = charsRegex.lastIndex;
      }
      if (chunkIndex === 0) {
        return "'" + val + "'";
      }
      if (chunkIndex < val.length) {
        return "'" + escapedVal + val.slice(chunkIndex) + "'";
      }
      return "'" + escapedVal + "'";
    }
    function dateToString(date, finalEscape, ctx = {}) {
      const timeZone = ctx.timeZone || "local";
      const dt = new Date(date);
      let year;
      let month;
      let day;
      let hour;
      let minute;
      let second;
      let millisecond;
      if (timeZone === "local") {
        year = dt.getFullYear();
        month = dt.getMonth() + 1;
        day = dt.getDate();
        hour = dt.getHours();
        minute = dt.getMinutes();
        second = dt.getSeconds();
        millisecond = dt.getMilliseconds();
      } else {
        const tz = convertTimezone(timeZone);
        if (tz !== false && tz !== 0) {
          dt.setTime(dt.getTime() + tz * 6e4);
        }
        year = dt.getUTCFullYear();
        month = dt.getUTCMonth() + 1;
        day = dt.getUTCDate();
        hour = dt.getUTCHours();
        minute = dt.getUTCMinutes();
        second = dt.getUTCSeconds();
        millisecond = dt.getUTCMilliseconds();
      }
      return zeroPad(year, 4) + "-" + zeroPad(month, 2) + "-" + zeroPad(day, 2) + " " + zeroPad(hour, 2) + ":" + zeroPad(minute, 2) + ":" + zeroPad(second, 2) + "." + zeroPad(millisecond, 3);
    }
    function zeroPad(number, length) {
      number = number.toString();
      while (number.length < length) {
        number = "0" + number;
      }
      return number;
    }
    function convertTimezone(tz) {
      if (tz === "Z") {
        return 0;
      }
      const m = tz.match(/([+\-\s])(\d\d):?(\d\d)?/);
      if (m) {
        return (m[1] == "-" ? -1 : 1) * (parseInt(m[2], 10) + (m[3] ? parseInt(m[3], 10) : 0) / 60) * 60;
      }
      return false;
    }
    module2.exports = {
      arrayToList,
      bufferToString,
      dateToString,
      escapeString,
      charsRegex,
      charsMap,
      escapeObject,
      makeEscape
    };
  }
});

// ../node_modules/knex/lib/client.js
var require_client = __commonJS({
  "../node_modules/knex/lib/client.js"(exports, module2) {
    "use strict";
    var Raw = require_raw();
    var Ref = require_ref();
    var Runner = require_runner();
    var Formatter = require_formatter();
    var Transaction = require_transaction();
    var QueryBuilder = require_builder();
    var QueryCompiler = require_compiler();
    var SchemaBuilder = require_builder2();
    var SchemaCompiler = require_compiler2();
    var TableBuilder = require_tablebuilder();
    var TableCompiler = require_tablecompiler();
    var ColumnBuilder = require_columnbuilder();
    var ColumnCompiler = require_columncompiler();
    var { Pool, TimeoutError } = require_tarn();
    var { EventEmitter } = require("events");
    var { promisify, inherits } = require("util");
    var { makeEscape } = require_string();
    var cloneDeep = require("lodash/cloneDeep");
    var defaults = require("lodash/defaults");
    var uniqueId = require("lodash/uniqueId");
    var Logger = require_logger();
    var { KnexTimeoutError } = require_timeout();
    var debug = require_src()("knex:client");
    var _debugQuery = require_src()("knex:query");
    var debugBindings = require_src()("knex:bindings");
    var debugQuery = (sql, txId) => _debugQuery(sql.replace(/%/g, "%%"), txId);
    var { POOL_CONFIG_OPTIONS } = require_constants();
    function Client(config2 = {}) {
      this.config = config2;
      this.logger = new Logger(config2);
      if (this.dialect && !this.config.client) {
        this.logger.warn(
          `Using 'this.dialect' to identify the client is deprecated and support for it will be removed in the future. Please use configuration option 'client' instead.`
        );
      }
      const dbClient = this.config.client || this.dialect;
      if (!dbClient) {
        throw new Error(`knex: Required configuration option 'client' is missing.`);
      }
      if (config2.version) {
        this.version = config2.version;
      }
      if (config2.connection && config2.connection instanceof Function) {
        this.connectionConfigProvider = config2.connection;
        this.connectionConfigExpirationChecker = () => true;
      } else {
        this.connectionSettings = cloneDeep(config2.connection || {});
        this.connectionConfigExpirationChecker = null;
      }
      if (this.driverName && config2.connection) {
        this.initializeDriver();
        if (!config2.pool || config2.pool && config2.pool.max !== 0) {
          this.initializePool(config2);
        }
      }
      this.valueForUndefined = this.raw("DEFAULT");
      if (config2.useNullAsDefault) {
        this.valueForUndefined = null;
      }
    }
    inherits(Client, EventEmitter);
    Object.assign(Client.prototype, {
      formatter(builder) {
        return new Formatter(this, builder);
      },
      queryBuilder() {
        return new QueryBuilder(this);
      },
      queryCompiler(builder) {
        return new QueryCompiler(this, builder);
      },
      schemaBuilder() {
        return new SchemaBuilder(this);
      },
      schemaCompiler(builder) {
        return new SchemaCompiler(this, builder);
      },
      tableBuilder(type, tableName, fn) {
        return new TableBuilder(this, type, tableName, fn);
      },
      tableCompiler(tableBuilder) {
        return new TableCompiler(this, tableBuilder);
      },
      columnBuilder(tableBuilder, type, args) {
        return new ColumnBuilder(this, tableBuilder, type, args);
      },
      columnCompiler(tableBuilder, columnBuilder) {
        return new ColumnCompiler(this, tableBuilder, columnBuilder);
      },
      runner(builder) {
        return new Runner(this, builder);
      },
      transaction(container, config2, outerTx) {
        return new Transaction(this, container, config2, outerTx);
      },
      raw() {
        return new Raw(this).set(...arguments);
      },
      ref() {
        return new Ref(this, ...arguments);
      },
      _formatQuery(sql, bindings, timeZone) {
        bindings = bindings == null ? [] : [].concat(bindings);
        let index = 0;
        return sql.replace(/\\?\?/g, (match) => {
          if (match === "\\?") {
            return "?";
          }
          if (index === bindings.length) {
            return match;
          }
          const value2 = bindings[index++];
          return this._escapeBinding(value2, { timeZone });
        });
      },
      _escapeBinding: makeEscape({
        escapeString(str) {
          return `'${str.replace(/'/g, "''")}'`;
        }
      }),
      query(connection, obj) {
        if (typeof obj === "string")
          obj = { sql: obj };
        obj.bindings = this.prepBindings(obj.bindings);
        const { __knexUid, __knexTxId } = connection;
        this.emit("query", Object.assign({ __knexUid, __knexTxId }, obj));
        debugQuery(obj.sql, __knexTxId);
        debugBindings(obj.bindings, __knexTxId);
        obj.sql = this.positionBindings(obj.sql);
        return this._query(connection, obj).catch((err) => {
          err.message = this._formatQuery(obj.sql, obj.bindings) + " - " + err.message;
          this.emit(
            "query-error",
            err,
            Object.assign({ __knexUid, __knexTxId }, obj)
          );
          throw err;
        });
      },
      stream(connection, obj, stream, options) {
        if (typeof obj === "string")
          obj = { sql: obj };
        obj.bindings = this.prepBindings(obj.bindings);
        const { __knexUid, __knexTxId } = connection;
        this.emit("query", Object.assign({ __knexUid, __knexTxId }, obj));
        debugQuery(obj.sql, __knexTxId);
        debugBindings(obj.bindings, __knexTxId);
        obj.sql = this.positionBindings(obj.sql);
        return this._stream(connection, obj, stream, options);
      },
      prepBindings(bindings) {
        return bindings;
      },
      positionBindings(sql) {
        return sql;
      },
      postProcessResponse(resp, queryContext) {
        if (this.config.postProcessResponse) {
          return this.config.postProcessResponse(resp, queryContext);
        }
        return resp;
      },
      wrapIdentifier(value2, queryContext) {
        return this.customWrapIdentifier(
          value2,
          this.wrapIdentifierImpl,
          queryContext
        );
      },
      customWrapIdentifier(value2, origImpl, queryContext) {
        if (this.config.wrapIdentifier) {
          return this.config.wrapIdentifier(value2, origImpl, queryContext);
        }
        return origImpl(value2);
      },
      wrapIdentifierImpl(value2) {
        return value2 !== "*" ? `"${value2.replace(/"/g, '""')}"` : "*";
      },
      initializeDriver() {
        try {
          this.driver = this._driver();
        } catch (e) {
          const message = `Knex: run
$ npm install ${this.driverName} --save`;
          this.logger.error(`${message}
${e.message}
${e.stack}`);
          throw new Error(`${message}
${e.message}`);
        }
      },
      poolDefaults() {
        return { min: 2, max: 10, propagateCreateError: true };
      },
      getPoolSettings(poolConfig) {
        poolConfig = defaults({}, poolConfig, this.poolDefaults());
        POOL_CONFIG_OPTIONS.forEach((option) => {
          if (option in poolConfig) {
            this.logger.warn(
              [
                `Pool config option "${option}" is no longer supported.`,
                `See https://github.com/Vincit/tarn.js for possible pool config options.`
              ].join(" ")
            );
          }
        });
        const timeouts = [
          this.config.acquireConnectionTimeout || 6e4,
          poolConfig.acquireTimeoutMillis
        ].filter((timeout) => timeout !== void 0);
        poolConfig.acquireTimeoutMillis = Math.min(...timeouts);
        const updatePoolConnectionSettingsFromProvider = async () => {
          if (!this.connectionConfigProvider) {
            return;
          }
          if (!this.connectionConfigExpirationChecker || !this.connectionConfigExpirationChecker()) {
            return;
          }
          const providerResult = await this.connectionConfigProvider();
          if (providerResult.expirationChecker) {
            this.connectionConfigExpirationChecker = providerResult.expirationChecker;
            delete providerResult.expirationChecker;
          } else {
            this.connectionConfigExpirationChecker = null;
          }
          this.connectionSettings = providerResult;
        };
        return Object.assign(poolConfig, {
          create: async () => {
            await updatePoolConnectionSettingsFromProvider();
            const connection = await this.acquireRawConnection();
            connection.__knexUid = uniqueId("__knexUid");
            if (poolConfig.afterCreate) {
              await promisify(poolConfig.afterCreate)(connection);
            }
            return connection;
          },
          destroy: (connection) => {
            if (connection !== void 0) {
              return this.destroyRawConnection(connection);
            }
          },
          validate: (connection) => {
            if (connection.__knex__disposed) {
              this.logger.warn(`Connection Error: ${connection.__knex__disposed}`);
              return false;
            }
            return this.validateConnection(connection);
          }
        });
      },
      initializePool(config2 = this.config) {
        if (this.pool) {
          this.logger.warn("The pool has already been initialized");
          return;
        }
        const tarnPoolConfig = {
          ...this.getPoolSettings(config2.pool)
        };
        if (tarnPoolConfig.afterCreate) {
          delete tarnPoolConfig.afterCreate;
        }
        this.pool = new Pool(tarnPoolConfig);
      },
      validateConnection(connection) {
        return true;
      },
      // Acquire a connection from the pool.
      async acquireConnection() {
        if (!this.pool) {
          throw new Error("Unable to acquire a connection");
        }
        try {
          const connection = await this.pool.acquire().promise;
          debug("acquired connection from pool: %s", connection.__knexUid);
          return connection;
        } catch (error) {
          let convertedError = error;
          if (error instanceof TimeoutError) {
            convertedError = new KnexTimeoutError(
              "Knex: Timeout acquiring a connection. The pool is probably full. Are you missing a .transacting(trx) call?"
            );
          }
          throw convertedError;
        }
      },
      // Releases a connection back to the connection pool,
      // returning a promise resolved when the connection is released.
      releaseConnection(connection) {
        debug("releasing connection to pool: %s", connection.__knexUid);
        const didRelease = this.pool.release(connection);
        if (!didRelease) {
          debug("pool refused connection: %s", connection.__knexUid);
        }
        return Promise.resolve();
      },
      // Destroy the current connection pool for the client.
      destroy(callback) {
        const maybeDestroy = this.pool && this.pool.destroy();
        return Promise.resolve(maybeDestroy).then(() => {
          this.pool = void 0;
          if (typeof callback === "function") {
            callback();
          }
        }).catch((err) => {
          if (typeof callback === "function") {
            callback(err);
          }
          return Promise.reject(err);
        });
      },
      // Return the database being used by this client.
      database() {
        return this.connectionSettings.database;
      },
      toString() {
        return "[object KnexClient]";
      },
      canCancelQuery: false,
      assertCanCancelQuery() {
        if (!this.canCancelQuery) {
          throw new Error("Query cancelling not supported for this dialect");
        }
      },
      cancelQuery() {
        throw new Error("Query cancelling not supported for this dialect");
      }
    });
    module2.exports = Client;
  }
});

// ../node_modules/knex/lib/util/fake-client.js
var require_fake_client = __commonJS({
  "../node_modules/knex/lib/util/fake-client.js"(exports, module2) {
    "use strict";
    var Formatter = require_formatter();
    var fakeClient = {
      formatter(builder) {
        return new Formatter(fakeClient, builder);
      }
    };
    module2.exports = fakeClient;
  }
});

// ../node_modules/knex/node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS({
  "../node_modules/knex/node_modules/pg-connection-string/index.js"(exports, module2) {
    "use strict";
    var url = require("url");
    var fs = require("fs");
    function parse2(str) {
      if (str.charAt(0) === "/") {
        var config2 = str.split(" ");
        return { host: config2[0], database: config2[1] };
      }
      var result = url.parse(
        / |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str) ? encodeURI(str).replace(/\%25(\d\d)/g, "%$1") : str,
        true
      );
      var config2 = result.query;
      for (var k in config2) {
        if (Array.isArray(config2[k])) {
          config2[k] = config2[k][config2[k].length - 1];
        }
      }
      var auth = (result.auth || ":").split(":");
      config2.user = auth[0];
      config2.password = auth.splice(1).join(":");
      config2.port = result.port;
      if (result.protocol == "socket:") {
        config2.host = decodeURI(result.pathname);
        config2.database = result.query.db;
        config2.client_encoding = result.query.encoding;
        return config2;
      }
      if (!config2.host) {
        config2.host = result.hostname;
      }
      var pathname = result.pathname;
      if (!config2.host && pathname && /^%2f/i.test(pathname)) {
        var pathnameSplit = pathname.split("/");
        config2.host = decodeURIComponent(pathnameSplit[0]);
        pathname = pathnameSplit.splice(1).join("/");
      }
      if (pathname && pathname.charAt(0) === "/") {
        pathname = pathname.slice(1) || null;
      }
      config2.database = pathname && decodeURI(pathname);
      if (config2.ssl === "true" || config2.ssl === "1") {
        config2.ssl = true;
      }
      if (config2.ssl === "0") {
        config2.ssl = false;
      }
      if (config2.sslcert || config2.sslkey || config2.sslrootcert || config2.sslmode) {
        config2.ssl = {};
      }
      if (config2.sslcert) {
        config2.ssl.cert = fs.readFileSync(config2.sslcert).toString();
      }
      if (config2.sslkey) {
        config2.ssl.key = fs.readFileSync(config2.sslkey).toString();
      }
      if (config2.sslrootcert) {
        config2.ssl.ca = fs.readFileSync(config2.sslrootcert).toString();
      }
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
      }
      return config2;
    }
    module2.exports = parse2;
    parse2.parse = parse2;
  }
});

// ../node_modules/knex/lib/util/parse-connection.js
var require_parse_connection = __commonJS({
  "../node_modules/knex/lib/util/parse-connection.js"(exports, module2) {
    "use strict";
    var url = require("url");
    var { parse: parse2 } = require_pg_connection_string();
    var parsePG = parse2;
    var isWindows = process && process.platform && process.platform === "win32";
    module2.exports = function parseConnectionString(str) {
      const parsed = url.parse(str, true);
      let { protocol } = parsed;
      const isDriveLetter = isWindows && protocol && protocol.length === 2;
      if (protocol === null || isDriveLetter) {
        return {
          client: "sqlite3",
          connection: {
            filename: str
          }
        };
      }
      if (protocol.slice(-1) === ":") {
        protocol = protocol.slice(0, -1);
      }
      const isPG = ["postgresql", "postgres"].includes(protocol);
      return {
        client: protocol,
        connection: isPG ? parsePG(str) : connectionObject(parsed)
      };
    };
    function connectionObject(parsed) {
      const connection = {};
      let db = parsed.pathname;
      if (db[0] === "/") {
        db = db.slice(1);
      }
      connection.database = db;
      if (parsed.hostname) {
        if (parsed.protocol.indexOf("mssql") === 0) {
          connection.server = parsed.hostname;
        } else {
          connection.host = parsed.hostname;
        }
      }
      if (parsed.port) {
        connection.port = parsed.port;
      }
      if (parsed.auth) {
        const idx = parsed.auth.indexOf(":");
        if (idx !== -1) {
          connection.user = parsed.auth.slice(0, idx);
          if (idx < parsed.auth.length - 1) {
            connection.password = parsed.auth.slice(idx + 1);
          }
        } else {
          connection.user = parsed.auth;
        }
      }
      if (parsed.query) {
        for (const key in parsed.query) {
          connection[key] = parsed.query[key];
        }
      }
      return connection;
    }
  }
});

// ../node_modules/knex/lib/config-resolver.js
var require_config_resolver = __commonJS({
  "../node_modules/knex/lib/config-resolver.js"(exports, module2) {
    "use strict";
    var Client = require_client();
    var { SUPPORTED_CLIENTS } = require_constants();
    var parseConnection = require_parse_connection();
    var { resolveClientNameWithAliases } = require_helpers();
    function resolveConfig(config2) {
      let Dialect;
      let resolvedConfig;
      const parsedConfig = typeof config2 === "string" ? Object.assign(parseConnection(config2), arguments[2]) : config2;
      if (arguments.length === 0 || !parsedConfig.client && !parsedConfig.dialect) {
        Dialect = Client;
      } else if (typeof parsedConfig.client === "function" && parsedConfig.client.prototype instanceof Client) {
        Dialect = parsedConfig.client;
      } else {
        const clientName = parsedConfig.client || parsedConfig.dialect;
        if (!SUPPORTED_CLIENTS.includes(clientName)) {
          throw new Error(
            `knex: Unknown configuration option 'client' value ${clientName}. Note that it is case-sensitive, check documentation for supported values.`
          );
        }
        const resolvedClientName = resolveClientNameWithAliases(clientName);
        Dialect = require(`./dialects/${resolvedClientName}/index.js`);
      }
      if (typeof parsedConfig.connection === "string") {
        resolvedConfig = Object.assign({}, parsedConfig, {
          connection: parseConnection(parsedConfig.connection).connection
        });
      } else {
        resolvedConfig = Object.assign({}, parsedConfig);
      }
      return {
        resolvedConfig,
        Dialect
      };
    }
    module2.exports = {
      resolveConfig
    };
  }
});

// ../node_modules/knex/lib/knex.js
var require_knex = __commonJS({
  "../node_modules/knex/lib/knex.js"(exports, module2) {
    "use strict";
    var Raw = require_raw();
    var Client = require_client();
    var QueryBuilder = require_builder();
    var QueryInterface = require_methods();
    var makeKnex = require_make_knex();
    var { KnexTimeoutError } = require_timeout();
    var fakeClient = require_fake_client();
    var { resolveConfig } = require_config_resolver();
    function Knex(config2) {
      const { resolvedConfig, Dialect } = resolveConfig(...arguments);
      const newKnex = makeKnex(new Dialect(resolvedConfig));
      if (resolvedConfig.userParams) {
        newKnex.userParams = resolvedConfig.userParams;
      }
      return newKnex;
    }
    Knex.Client = Client;
    Knex.KnexTimeoutError = KnexTimeoutError;
    Knex.QueryBuilder = {
      extend: function(methodName, fn) {
        QueryBuilder.extend(methodName, fn);
        QueryInterface.push(methodName);
      }
    };
    Knex.raw = (sql, bindings) => {
      console.warn(
        "global Knex.raw is deprecated, use knex.raw (chain off an initialized knex object)"
      );
      return new Raw(fakeClient).set(sql, bindings);
    };
    module2.exports = Knex;
  }
});

// ../node_modules/knex/lib/index.js
var require_lib = __commonJS({
  "../node_modules/knex/lib/index.js"(exports, module2) {
    "use strict";
    var Knex = require_knex();
    module2.exports = Knex;
  }
});

// ../node_modules/knex/knex.js
var require_knex2 = __commonJS({
  "../node_modules/knex/knex.js"(exports, module2) {
    "use strict";
    module2.exports = require_lib();
  }
});

// ../node_modules/pg-mem/index.js
var require_pg_mem = __commonJS({
  "../node_modules/pg-mem/index.js"(exports) {
    "use strict";
    (function(e, a) {
      for (var i in a)
        e[i] = a[i];
    })(
      exports,
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module3 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.l = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value2, mode) {
          if (mode & 1)
            value2 = __webpack_require__(value2);
          if (mode & 8)
            return value2;
          if (mode & 4 && typeof value2 === "object" && value2 && value2.__esModule)
            return value2;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value: value2 });
          if (mode & 2 && typeof value2 != "string")
            for (var key in value2)
              __webpack_require__.d(ns, key, function(key2) {
                return value2[key2];
              }.bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module3) {
          var getter = module3 && module3.__esModule ? (
            /******/
            function getDefault() {
              return module3["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module3;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 37);
      }([
        /* 0 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          });
          var __exportStar = this && this.__exportStar || function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.asView = exports2.asSelectable = exports2.asTable = exports2.asSeq = exports2.asType = exports2.asIndex = exports2.NewColumn = exports2.EmtpyTable = exports2.setId = exports2.getId = exports2.GLOBAL_VARS = void 0;
          const interfaces_1 = __webpack_require__(3);
          const immutable_1 = __webpack_require__(16);
          __exportStar(__webpack_require__(3), exports2);
          exports2.GLOBAL_VARS = Symbol("_global_vars");
          const ID = Symbol("_id");
          function getId(item) {
            if (!item) {
              return "";
            }
            const got = item[ID];
            if (!got) {
              throw new Error("Unexpected: cannot get an ID of something which is not a record");
            }
            return got;
          }
          exports2.getId = getId;
          function setId(item, id) {
            const got = item[ID];
            if (got === id) {
              return item;
            }
            if (got) {
              throw new Error("Unexpected: Cannot update an ID");
            }
            item[ID] = id;
            return item;
          }
          exports2.setId = setId;
          exports2.EmtpyTable = (0, immutable_1.Record)({
            serials: (0, immutable_1.Map)(),
            it: 0,
            indexByHash: (0, immutable_1.Map)(),
            indexByName: (0, immutable_1.Map)(),
            columnsByName: (0, immutable_1.Map)()
          });
          exports2.NewColumn = (0, immutable_1.Record)({
            default: null,
            notNull: false,
            usedInIndexes: (0, immutable_1.Set)(),
            type: null,
            name: null
          });
          function asIndex(o) {
            if (!o) {
              return null;
            }
            if (o.type === "index") {
              return o;
            }
            throw new interfaces_1.QueryError(`"${o.name}" is not an index`);
          }
          exports2.asIndex = asIndex;
          function asType(o) {
            if (!o) {
              return null;
            }
            if (o.type === "type") {
              return o;
            }
            throw new interfaces_1.QueryError(`"${o.name}" is not a type`);
          }
          exports2.asType = asType;
          function asSeq(o) {
            if (!o) {
              return null;
            }
            if (o.type === "sequence") {
              return o;
            }
            throw new interfaces_1.QueryError(`"${o.name}" is not a sequence`);
          }
          exports2.asSeq = asSeq;
          function asTable(o, nullIfNotType) {
            if (!o) {
              return null;
            }
            if (o.type === "table") {
              return o;
            }
            if (nullIfNotType) {
              return null;
            }
            throw new interfaces_1.QueryError(`"${o.name}" is not a table`);
          }
          exports2.asTable = asTable;
          function asSelectable(o, nullIfNotType) {
            if (!o) {
              return null;
            }
            if (o.type === "table" || o.type === "view") {
              return o;
            }
            if (nullIfNotType) {
              return null;
            }
            throw new interfaces_1.QueryError(`"${o.name}" is not selectable`);
          }
          exports2.asSelectable = asSelectable;
          function asView(o, nullIfNotType) {
            if (!o) {
              return null;
            }
            if (o.type === "view") {
              return o;
            }
            if (nullIfNotType) {
              return null;
            }
            throw new interfaces_1.QueryError({
              code: "42809",
              error: `"${o.name}" is not a view`
            });
          }
          exports2.asView = asView;
        },
        /* 1 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.modifyIfNecessary = exports2.notNil = exports2.fromEntries = exports2.IteratorHelper = exports2.it = exports2.errorMessage = exports2.asSingleQName = exports2.asSingleName = exports2.qnameToStr = exports2.colToStr = exports2.colByName = exports2.parseTime = exports2.parseRegClass = exports2.intervalToSec = exports2.compareVersions = exports2.findTemplate = exports2.suggestColumnName = exports2.isType = exports2.schemaOf = exports2.randomString = exports2.indexHash = exports2.pushExecutionCtx = exports2.hasExecutionCtx = exports2.executionCtx = exports2.combineSubs = exports2.ignore = exports2.isSelectAllArgList = exports2.deepCloneSimple = exports2.sum = exports2.hasNullish = exports2.nullIsh = exports2.buildLikeMatcher = exports2.queryJson = exports2.deepCompare = exports2.deepEqual = exports2.watchUse = exports2.trimNullish = void 0;
          const moment_1 = __importDefault(__webpack_require__(17));
          const immutable_1 = __webpack_require__(16);
          const interfaces_private_1 = __webpack_require__(0);
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const interfaces_1 = __webpack_require__(3);
          const buffer_node_1 = __webpack_require__(21);
          function trimNullish(value2, depth = 5) {
            if (depth < 0)
              return value2;
            if (value2 instanceof Array) {
              value2.forEach((x) => trimNullish(x, depth - 1));
            }
            if (typeof value2 !== "object" || value2 instanceof Date || moment_1.default.isMoment(value2) || moment_1.default.isDuration(value2))
              return value2;
            if (!value2) {
              return value2;
            }
            for (const k of Object.keys(value2)) {
              const val = value2[k];
              if (nullIsh(val))
                delete value2[k];
              else
                trimNullish(val, depth - 1);
            }
            return value2;
          }
          exports2.trimNullish = trimNullish;
          function watchUse(rootValue) {
            var _c, _d;
            if (!rootValue || typeof globalThis !== "undefined" && ((_d = (_c = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process) === null || _c === void 0 ? void 0 : _c.env) === null || _d === void 0 ? void 0 : _d["NOCHECKFULLQUERYUSAGE"]) === "true") {
              return { checked: rootValue };
            }
            if (typeof rootValue !== "object") {
              throw new interfaces_private_1.NotSupported();
            }
            if (Array.isArray(rootValue)) {
              throw new interfaces_private_1.NotSupported();
            }
            const toUse = /* @__PURE__ */ new Map();
            function recurse(value2, stack = (0, immutable_1.List)()) {
              if (!value2 || typeof value2 !== "object") {
                return value2;
              }
              if (Array.isArray(value2)) {
                return value2.map((x, i) => recurse(x, stack.push(`[${i}]`)));
              }
              const ret = {};
              for (const [k, _v] of Object.entries(value2)) {
                if (k[0] === "_") {
                  ret[k] = _v;
                  continue;
                }
                const nstack = stack.push("." + k);
                let v = recurse(_v, nstack);
                const nstackKey = nstack.join("");
                toUse.set(nstackKey, _v);
                Object.defineProperty(ret, k, {
                  get() {
                    toUse.delete(nstackKey);
                    return v;
                  },
                  enumerable: true
                });
              }
              return ret;
            }
            const final = recurse(rootValue);
            const check = function() {
              if (toUse.size) {
                return `The query you ran generated an AST which parts have not been read by the query planner. This means that those parts could be ignored:

    \u21E8 ` + [...toUse.entries()].map(([k, v]) => k + " (" + JSON.stringify(v) + ")").join("\n    \u21E8 ");
              }
              return null;
            };
            return { checked: final, check };
          }
          exports2.watchUse = watchUse;
          function deepEqual2(a, b, strict, depth = 10, numberDelta = 1e-4) {
            return deepCompare(a, b, strict, depth, numberDelta) === 0;
          }
          exports2.deepEqual = deepEqual2;
          function deepCompare(a, b, strict, depth = 10, numberDelta = 1e-4) {
            if (depth < 0) {
              throw new interfaces_private_1.NotSupported("Comparing too deep entities");
            }
            if (a === b) {
              return 0;
            }
            if (!strict) {
              if (!a && !b) {
                return 0;
              }
            }
            if (Array.isArray(a)) {
              if (!Array.isArray(b)) {
                return -1;
              }
              if (a.length !== b.length) {
                return a.length > b.length ? 1 : -1;
              }
              for (let i = 0; i < a.length; i++) {
                const inner = deepCompare(a[i], b[i], strict, depth - 1, numberDelta);
                if (inner)
                  return inner;
              }
              return 0;
            }
            if (Array.isArray(b)) {
              return 1;
            }
            if ((0, buffer_node_1.isBuf)(a) || (0, buffer_node_1.isBuf)(b)) {
              if (!(0, buffer_node_1.isBuf)(a)) {
                return 1;
              }
              if (!(0, buffer_node_1.isBuf)(b)) {
                return -1;
              }
              return (0, buffer_node_1.bufCompare)(a, b);
            }
            if (a instanceof Date || b instanceof Date || moment_1.default.isMoment(a) || moment_1.default.isMoment(b)) {
              const am = (0, moment_1.default)(a);
              const bm = (0, moment_1.default)(b);
              if (am.isValid() !== bm.isValid()) {
                return am.isValid() ? -1 : 1;
              }
              const diff = am.diff(bm, "seconds");
              if (Math.abs(diff) < 1e-3) {
                return 0;
              }
              return diff > 0 ? 1 : -1;
            }
            if (moment_1.default.isDuration(a) || moment_1.default.isDuration(b)) {
              const da = moment_1.default.duration(a);
              const db = moment_1.default.duration(b);
              if (da.isValid() !== db.isValid()) {
                return da.isValid() ? -1 : 1;
              }
              const diff = da.asMilliseconds() - db.asMilliseconds();
              if (Math.abs(diff) < 1) {
                return 0;
              }
              return diff > 0 ? 1 : -1;
            }
            const fa = Number.isFinite(a);
            const fb = Number.isFinite(b);
            if (fa && fb) {
              if (Math.abs(a - b) <= numberDelta) {
                return 0;
              }
              return a > b ? 1 : -1;
            } else if (fa && b) {
              return -1;
            } else if (fb && a) {
              return 1;
            }
            if (typeof a !== "object") {
              return 1;
            }
            if (typeof b !== "object") {
              return -1;
            }
            if (!a || !b) {
              return 0;
            }
            const ak = Object.keys(a);
            const bk = Object.keys(b);
            if (strict && ak.length !== bk.length) {
              return ak.length > bk.length ? 1 : -1;
            }
            const set3 = strict ? Object.keys(a) : /* @__PURE__ */ new Set([...Object.keys(a), ...Object.keys(b)]);
            for (const k of set3) {
              const inner = deepCompare(a[k], b[k], strict, depth - 1, numberDelta);
              if (inner) {
                return inner;
              }
            }
            return 0;
          }
          exports2.deepCompare = deepCompare;
          function queryJson(a, b) {
            if (!a || !b) {
              return (a !== null && a !== void 0 ? a : null) === (b !== null && b !== void 0 ? b : null);
            }
            if (a === b) {
              return true;
            }
            if (typeof a === "string" || typeof b === "string") {
              return false;
            }
            if (typeof a === "number" || typeof b === "number") {
              return false;
            }
            if (Array.isArray(a)) {
              if (!Array.isArray(b)) {
                return false;
              }
              const toMatch = [...a];
              for (const be of b) {
                for (let i = 0; i < toMatch.length; i++) {
                  if (queryJson(toMatch[i], be)) {
                    toMatch.splice(i, 1);
                    break;
                  }
                }
                if (!toMatch.length) {
                  break;
                }
              }
              return !toMatch.length;
            }
            if (Array.isArray(b)) {
              return false;
            }
            if (typeof a === "object" !== (typeof b === "object")) {
              return false;
            }
            const akeys = Object.keys(a);
            const bkeys = Object.keys(b);
            if (akeys.length > bkeys.length) {
              return false;
            }
            for (const ak of akeys) {
              if (!(ak in b)) {
                return false;
              }
              if (!queryJson(a[ak], b[ak])) {
                return false;
              }
            }
            return true;
          }
          exports2.queryJson = queryJson;
          function buildLikeMatcher(likeCondition, caseSensitive = true) {
            likeCondition = likeCondition.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            let likeRegexString = likeCondition.replace(/\%/g, ".*").replace(/_/g, ".");
            likeRegexString = "^" + likeRegexString + "$";
            const reg = new RegExp(likeRegexString, caseSensitive ? "" : "i");
            return (stringToMatch) => {
              if (nullIsh(stringToMatch)) {
                return null;
              }
              if (typeof stringToMatch != "string") {
                stringToMatch = stringToMatch.toString();
              }
              return reg.test(stringToMatch);
            };
          }
          exports2.buildLikeMatcher = buildLikeMatcher;
          function nullIsh(v) {
            return v === null || v === void 0;
          }
          exports2.nullIsh = nullIsh;
          function hasNullish(...vals) {
            return vals.some((v) => nullIsh(v));
          }
          exports2.hasNullish = hasNullish;
          function sum(v) {
            return v.reduce((sum2, el) => sum2 + el, 0);
          }
          exports2.sum = sum;
          function deepCloneSimple(v) {
            if (!v || typeof v !== "object" || v instanceof Date) {
              return v;
            }
            if (Array.isArray(v)) {
              return v.map((x) => deepCloneSimple(x));
            }
            if ((0, buffer_node_1.isBuf)(v)) {
              return (0, buffer_node_1.bufClone)(v);
            }
            const ret = {};
            for (const k of Object.keys(v)) {
              ret[k] = deepCloneSimple(v[k]);
            }
            for (const k of Object.getOwnPropertySymbols(v)) {
              ret[k] = v[k];
            }
            return ret;
          }
          exports2.deepCloneSimple = deepCloneSimple;
          function isSelectAllArgList(select) {
            const [first3] = select;
            return select.length === 1 && first3.type === "ref" && first3.name === "*" && !first3.table;
          }
          exports2.isSelectAllArgList = isSelectAllArgList;
          function ignore(...val) {
            for (const v of val) {
              if (!v) {
                continue;
              }
              if (Array.isArray(v)) {
                ignore(...v);
                continue;
              }
              if (typeof v !== "object") {
                continue;
              }
              ignore(...Object.values(v));
            }
          }
          exports2.ignore = ignore;
          function combineSubs(...vals) {
            return {
              unsubscribe: () => {
                vals.forEach((u) => u === null || u === void 0 ? void 0 : u.unsubscribe());
              }
            };
          }
          exports2.combineSubs = combineSubs;
          const curCtx = [];
          function executionCtx() {
            if (!curCtx.length) {
              throw new Error("No execution context available");
            }
            return curCtx[curCtx.length - 1];
          }
          exports2.executionCtx = executionCtx;
          function hasExecutionCtx() {
            return curCtx.length > 0;
          }
          exports2.hasExecutionCtx = hasExecutionCtx;
          function pushExecutionCtx(ctx, act) {
            try {
              curCtx.push(ctx);
              return act();
            } finally {
              curCtx.pop();
            }
          }
          exports2.pushExecutionCtx = pushExecutionCtx;
          function indexHash(vals) {
            return vals.map((x) => typeof x === "string" ? x : x.hash).sort().join("|");
          }
          exports2.indexHash = indexHash;
          function randomString(length = 8, chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") {
            var result = "";
            for (var i = length; i > 0; --i)
              result += chars[Math.floor(Math.random() * chars.length)];
            return result;
          }
          exports2.randomString = randomString;
          function schemaOf(t2) {
            if (t2.kind === "array") {
              return schemaOf(t2.arrayOf);
            }
            return t2.schema;
          }
          exports2.schemaOf = schemaOf;
          function isType(t2) {
            return !!(t2 === null || t2 === void 0 ? void 0 : t2[isType.TAG]);
          }
          exports2.isType = isType;
          isType.TAG = Symbol();
          function suggestColumnName(expr) {
            if (!expr) {
              return null;
            }
            switch (expr.type) {
              case "call":
                return expr.function.name;
              case "ref":
                return expr.name;
              case "keyword":
                return expr.keyword;
              case "cast":
                return (0, interfaces_1.typeDefToStr)(expr.to);
            }
            return null;
          }
          exports2.suggestColumnName = suggestColumnName;
          function findTemplate(selection, t2, template, columns) {
            let expr;
            for (const [k, v] of Object.entries(template !== null && template !== void 0 ? template : {})) {
              let right;
              if (nullIsh(v)) {
                right = {
                  type: "unary",
                  op: "IS NULL",
                  operand: {
                    type: "ref",
                    name: k
                  }
                };
              } else {
                let value2;
                let op = "=";
                switch (typeof v) {
                  case "number":
                    value2 = Number.isInteger(v) ? { type: "integer", value: v } : { type: "numeric", value: v };
                    break;
                  case "string":
                    value2 = { type: "string", value: v };
                    break;
                  case "object":
                    if (moment_1.default.isMoment(v)) {
                      value2 = { type: "string", value: v.toISOString() };
                    } else if (v instanceof Date) {
                      value2 = { type: "string", value: (0, moment_1.default)(v).toISOString() };
                    } else {
                      op = "@>";
                      value2 = {
                        type: "string",
                        value: JSON.stringify(v)
                      };
                    }
                    break;
                  default:
                    throw new Error(`Object type of property "${k}" not supported in template`);
                }
                right = {
                  type: "binary",
                  op,
                  left: {
                    type: "ref",
                    name: k
                  },
                  right: value2
                };
              }
              expr = !expr ? right : {
                type: "binary",
                op: "AND",
                left: expr,
                right
              };
            }
            let ret = selection.filter(expr);
            if (columns) {
              ret = ret.select(columns.map((x) => ({
                expr: { type: "ref", name: x }
              })));
            }
            return ret.enumerate(t2);
          }
          exports2.findTemplate = findTemplate;
          function ver(v) {
            if (!v || !/^\d+(\.\d+)+$/.test(v)) {
              throw new Error("Invalid semver " + v);
            }
            return v.split(/\./g).map((x) => parseInt(x, 10));
          }
          function compareVersions(_a, _b) {
            const a = ver(_a);
            const b = ver(_b);
            const m = Math.max(a.length, b.length);
            for (let i = 0; i < m; i++) {
              const d = (b[i] || 0) - (a[i] || 0);
              if (d !== 0) {
                return d;
              }
            }
            return 0;
          }
          exports2.compareVersions = compareVersions;
          function intervalToSec(v) {
            var _c, _d, _e, _f, _g, _h, _j;
            return ((_c = v.milliseconds) !== null && _c !== void 0 ? _c : 0) / 1e3 + ((_d = v.seconds) !== null && _d !== void 0 ? _d : 0) + ((_e = v.minutes) !== null && _e !== void 0 ? _e : 0) * 60 + ((_f = v.hours) !== null && _f !== void 0 ? _f : 0) * 3600 + ((_g = v.days) !== null && _g !== void 0 ? _g : 0) * 3600 * 24 + ((_h = v.months) !== null && _h !== void 0 ? _h : 0) * 3600 * 24 * 30 + ((_j = v.years) !== null && _j !== void 0 ? _j : 0) * 3600 * 24 * 30 * 12;
          }
          exports2.intervalToSec = intervalToSec;
          function parseRegClass(_reg) {
            let reg = _reg;
            if (typeof reg === "string" && /^\d+$/.test(reg)) {
              reg = parseInt(reg);
            }
            if (typeof reg === "number") {
              return reg;
            }
            try {
              const ret = (0, pgsql_ast_parser_1.parse)(reg, "qualified_name");
              return ret;
            } catch (e) {
              return { name: reg };
            }
          }
          exports2.parseRegClass = parseRegClass;
          const timeReg = /^(\d+):(\d+)(:(\d+))?(\.\d+)?$/;
          function parseTime(str) {
            var _c;
            const [_, a, b, __, c, d] = (_c = timeReg.exec(str)) !== null && _c !== void 0 ? _c : [];
            if (!_) {
              throw new interfaces_1.QueryError(`Invalid time format: ` + str);
            }
            const ms = d ? parseFloat(d) * 1e3 : void 0;
            let ret;
            if (c) {
              ret = moment_1.default.utc({
                h: parseInt(a, 10),
                m: parseInt(b, 10),
                s: parseInt(c, 10),
                ms
              });
            } else {
              if (d) {
                ret = moment_1.default.utc({
                  m: parseInt(a, 10),
                  s: parseInt(b, 10),
                  ms
                });
              } else {
                ret = moment_1.default.utc({
                  h: parseInt(a, 10),
                  m: parseInt(b, 10),
                  ms
                });
              }
            }
            if (!ret.isValid()) {
              throw new interfaces_1.QueryError(`Invalid time format: ` + str);
            }
            return ret;
          }
          exports2.parseTime = parseTime;
          function colByName(refs, ref, nullIfNotFound) {
            const nm = typeof ref === "string" ? ref : !ref.table ? ref.name : null;
            const got = nm ? refs.get(nm) : null;
            if (!got && !nullIfNotFound) {
              throw new interfaces_1.ColumnNotFound(colToStr(ref));
            }
            return got;
          }
          exports2.colByName = colByName;
          function colToStr(col) {
            if (typeof col === "string") {
              return col;
            }
            if (!col.table) {
              return col.name;
            }
            return col.table.name + "." + col.name;
          }
          exports2.colToStr = colToStr;
          function qnameToStr(col) {
            if (typeof col === "string") {
              return col;
            }
            if (!col.schema) {
              return col.name;
            }
            return col.schema + "." + col.name;
          }
          exports2.qnameToStr = qnameToStr;
          function asSingleName(col) {
            if (typeof col === "string") {
              return col;
            }
            if (col.table) {
              return null;
            }
            return col.name;
          }
          exports2.asSingleName = asSingleName;
          function asSingleQName(col, allowedSchema) {
            if (typeof col === "string") {
              return col;
            }
            if (col.schema && col.schema !== allowedSchema) {
              return null;
            }
            return col.name;
          }
          exports2.asSingleQName = asSingleQName;
          function errorMessage(error) {
            if (typeof error === "string") {
              return error;
            }
            if (typeof error !== "object") {
              return "Unkown error message";
            }
            return error === null || error === void 0 ? void 0 : error.message;
          }
          exports2.errorMessage = errorMessage;
          function it(iterable) {
            return iterable instanceof IteratorHelper ? iterable : new IteratorHelper(() => iterable);
          }
          exports2.it = it;
          class IteratorHelper {
            constructor(underlying) {
              this.underlying = underlying;
            }
            [Symbol.iterator]() {
              return this.underlying()[Symbol.iterator]();
            }
            flatten() {
              const that = this;
              function* wrap() {
                var _c;
                for (const v of (_c = that.underlying()) !== null && _c !== void 0 ? _c : []) {
                  for (const x of v) {
                    yield x;
                  }
                }
              }
              return new IteratorHelper(wrap);
            }
            reduce(callbackfn, initialValue) {
              let acc = initialValue;
              let i = 0;
              for (const v of this.underlying()) {
                acc = callbackfn(acc, v, i);
                i++;
              }
              return acc;
            }
          }
          exports2.IteratorHelper = IteratorHelper;
          function fromEntries(iterable) {
            const ret = /* @__PURE__ */ new Map();
            for (const [k, v] of iterable) {
              ret.set(k, v);
            }
            return ret;
          }
          exports2.fromEntries = fromEntries;
          function notNil(value2) {
            return (value2 !== null && value2 !== void 0 ? value2 : []).filter((x) => !nullIsh(x));
          }
          exports2.notNil = notNil;
          function modifyIfNecessary(values2, mapper) {
            let ret;
            for (let i = 0; i < values2.length; i++) {
              const mapped = mapper(values2[i]);
              if (nullIsh(mapped)) {
                continue;
              }
              if (!ret) {
                ret = [...values2];
              }
              ret[i] = mapped;
            }
            return ret !== null && ret !== void 0 ? ret : values2;
          }
          exports2.modifyIfNecessary = modifyIfNecessary;
        },
        /* 2 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          });
          var __exportStar = this && this.__exportStar || function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          __exportStar(__webpack_require__(14), exports2);
        },
        /* 3 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.typeDefToStr = exports2.PermissionDeniedError = exports2.RecordExists = exports2.TypeNotFound = exports2.RelationNotFound = exports2.AmbiguousColumn = exports2.ColumnNotFound = exports2.CastError = exports2.QueryError = exports2.NotSupported = exports2.AdvancedResult = exports2.DataType = void 0;
          var DataType;
          (function(DataType2) {
            DataType2["inet"] = "inet";
            DataType2["record"] = "record";
            DataType2["uuid"] = "uuid";
            DataType2["text"] = "text";
            DataType2["citext"] = "citext";
            DataType2["array"] = "array";
            DataType2["list"] = "list";
            DataType2["bigint"] = "bigint";
            DataType2["float"] = "float";
            DataType2["decimal"] = "decimal";
            DataType2["integer"] = "integer";
            DataType2["jsonb"] = "jsonb";
            DataType2["regtype"] = "regtype";
            DataType2["regclass"] = "regclass";
            DataType2["json"] = "json";
            DataType2["bytea"] = "bytea";
            DataType2["interval"] = "interval";
            DataType2["timestamp"] = "timestamp";
            DataType2["timestamptz"] = "timestamptz";
            DataType2["date"] = "date";
            DataType2["time"] = "time";
            DataType2["timetz"] = "timetz";
            DataType2["null"] = "null";
            DataType2["bool"] = "bool";
            DataType2["point"] = "point";
            DataType2["line"] = "line";
            DataType2["lseg"] = "lseg";
            DataType2["box"] = "box";
            DataType2["path"] = "path";
            DataType2["polygon"] = "polygon";
            DataType2["circle"] = "circle";
          })(DataType = exports2.DataType || (exports2.DataType = {}));
          class AdvancedResult {
            constructor(result, outArgs) {
              this.result = result;
            }
          }
          exports2.AdvancedResult = AdvancedResult;
          class NotSupported extends Error {
            constructor(what) {
              super("\u{1F528} Not supported \u{1F528} " + (what ? ": " + what : ""));
            }
            static never(value2, msg) {
              return new NotSupported(`${msg !== null && msg !== void 0 ? msg : ""} ${JSON.stringify(value2)}`);
            }
          }
          exports2.NotSupported = NotSupported;
          class QueryError extends Error {
            constructor(err, code) {
              super(typeof err === "string" ? err : errDataToStr(err));
              if (typeof err === "string") {
                this.data = { error: err, code };
                this.code = code;
              } else {
                this.data = err;
                this.code = err.code;
              }
            }
          }
          exports2.QueryError = QueryError;
          function errDataToStr(data) {
            const ret = ["ERROR: " + data.error];
            if (data.details) {
              ret.push("DETAIL: " + data.details);
            }
            if (data.hint) {
              ret.push("HINT: " + data.hint);
            }
            return ret.join("\n");
          }
          class CastError extends QueryError {
            constructor(from, to, inWhat) {
              super(`cannot cast type ${typeof from === "string" ? from : from.name} to ${typeof to === "string" ? to : to.name}` + (inWhat ? " in " + inWhat : ""));
            }
          }
          exports2.CastError = CastError;
          class ColumnNotFound extends QueryError {
            constructor(col) {
              super(`column "${col}" does not exist`);
            }
          }
          exports2.ColumnNotFound = ColumnNotFound;
          class AmbiguousColumn extends QueryError {
            constructor(col) {
              super(`column reference "${col}" is ambiguous`);
            }
          }
          exports2.AmbiguousColumn = AmbiguousColumn;
          class RelationNotFound extends QueryError {
            constructor(tableName) {
              super(`relation "${tableName}" does not exist`);
            }
          }
          exports2.RelationNotFound = RelationNotFound;
          class TypeNotFound extends QueryError {
            constructor(t2) {
              super(`type "${typeof t2 !== "object" ? t2 : typeDefToStr(t2)}" does not exist`);
            }
          }
          exports2.TypeNotFound = TypeNotFound;
          class RecordExists extends QueryError {
            constructor() {
              super("Records already exists");
            }
          }
          exports2.RecordExists = RecordExists;
          class PermissionDeniedError extends QueryError {
            constructor(what) {
              super(what ? `permission denied: "${what}" is a system catalog` : "permission denied");
            }
          }
          exports2.PermissionDeniedError = PermissionDeniedError;
          function typeDefToStr(t2) {
            var _a;
            if (t2.kind === "array") {
              return typeDefToStr(t2.arrayOf) + "[]";
            }
            let ret = t2.name;
            if (t2.schema) {
              ret = t2.schema + "." + ret;
            }
            if ((_a = t2.config) === null || _a === void 0 ? void 0 : _a.length) {
              ret = ret + "(" + t2.config.join(",") + ")";
            }
            return ret;
          }
          exports2.typeDefToStr = typeDefToStr;
        },
        /* 4 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.resolveName = exports2.withNameResolver = exports2.withParameters = exports2.withBindingScope = exports2.withStatement = exports2.withSelection = exports2.buildCtx = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          class StackOf {
            constructor(name) {
              this.name = name;
              this.stack = [];
              this.usingValue = (value2, act) => {
                this.stack.push(value2);
                try {
                  return act();
                } finally {
                  this.stack.pop();
                }
              };
            }
            get current() {
              if (!this.stack.length) {
                throw new Error(`No ${this.name} available`);
              }
              return this.stack[this.stack.length - 1];
            }
            get currentOrNil() {
              return this.stack[this.stack.length - 1];
            }
          }
          const _selectionStack = new StackOf("build context");
          const _statementStack = new StackOf("execution statement");
          const _tempBindings = new StackOf("binding context");
          const _parametersStack = new StackOf("parameter context");
          const _nameResolver = new StackOf("name resolver");
          class Context {
            constructor() {
              this.onFinishExecution = (callback) => {
                _statementStack.current.onExecuted(callback);
              };
              this.getTempBinding = (name) => {
                var _a;
                const ret = (_a = _tempBindings.currentOrNil) === null || _a === void 0 ? void 0 : _a.get(name);
                if (ret === "no returning") {
                  throw new interfaces_private_1.QueryError(`WITH query "${name}" does not have a RETURNING clause`);
                }
                return ret;
              };
              this.setTempBinding = (name, boundTo) => {
                if (_tempBindings.current.has(name)) {
                  throw new interfaces_private_1.QueryError(`WITH query name "${name}" specified more than once`);
                }
                _tempBindings.current.set(name, boundTo.isExecutionWithNoResult ? "no returning" : boundTo);
              };
              this.getParameter = (nameOrPosition) => {
                var _a, _b;
                const params = _parametersStack.currentOrNil;
                if (!params) {
                  return null;
                }
                if (typeof nameOrPosition === "number") {
                  const ret = (_a = params[nameOrPosition]) === null || _a === void 0 ? void 0 : _a.value;
                  if (!ret) {
                    throw new interfaces_private_1.QueryError(`bind message supplies ${params.length} parameters, but prepared statement "" requires ${nameOrPosition}`, "08P01");
                  }
                  return ret;
                }
                return (_b = params.find((p) => p.value.id === nameOrPosition)) === null || _b === void 0 ? void 0 : _b.value;
              };
            }
            get selection() {
              return _selectionStack.current;
            }
            get db() {
              return _selectionStack.current.db;
            }
            get schema() {
              return _selectionStack.current.ownerSchema;
            }
          }
          const _buildCtx = new Context();
          function buildCtx() {
            return _buildCtx;
          }
          exports2.buildCtx = buildCtx;
          exports2.withSelection = _selectionStack.usingValue;
          exports2.withStatement = _statementStack.usingValue;
          function withBindingScope(act) {
            return _tempBindings.usingValue(/* @__PURE__ */ new Map(), act);
          }
          exports2.withBindingScope = withBindingScope;
          exports2.withParameters = _parametersStack.usingValue;
          exports2.withNameResolver = _nameResolver.usingValue;
          function resolveName(name) {
            for (let i = _nameResolver.stack.length - 1; i >= 0; i--) {
              const resolver = _nameResolver.stack[i];
              const found = resolver.resolve(name);
              if (found) {
                return found;
              }
              if (resolver.isolated) {
                return null;
              }
            }
            return null;
          }
          exports2.resolveName = resolveName;
        },
        /* 5 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.FilterBase = exports2.TransformBase = exports2.DataSourceBase = exports2.initialize = void 0;
          const restrictive_index_1 = __webpack_require__(50);
          let fns;
          function initialize(init) {
            fns = init;
          }
          exports2.initialize = initialize;
          class DataSourceBase {
            constructor(ownerSchema) {
              this.ownerSchema = ownerSchema;
            }
            isAggregation() {
              return false;
            }
            // abstract get name(): string;
            get db() {
              return this.ownerSchema.db;
            }
            listColumns() {
              return this.columns;
            }
            listSelectableIdentities() {
              return this.columns;
            }
            select(select) {
              let sel;
              if (select === null || select === void 0 ? void 0 : select.some((v) => typeof v === "string")) {
                sel = select.map((v) => typeof v !== "string" ? v : {
                  expr: { type: "ref", name: v }
                });
              } else {
                sel = select;
              }
              return fns.buildSelection(this, sel);
            }
            selectAlias(alias) {
              return null;
            }
            filter(filter3) {
              if (!filter3) {
                return this;
              }
              const plan = fns.buildFilter(this, filter3, "WHERE");
              return plan;
            }
            groupBy(grouping) {
              if (!(grouping === null || grouping === void 0 ? void 0 : grouping.length)) {
                return this;
              }
              const plan = fns.buildGroupBy(this, grouping);
              return plan;
            }
            setAlias(alias) {
              return fns.buildAlias(this, alias);
            }
            limit(limit) {
              if (!(limit === null || limit === void 0 ? void 0 : limit.limit) && !(limit === null || limit === void 0 ? void 0 : limit.offset)) {
                return this;
              }
              return fns.buildLimit(this, limit);
            }
            orderBy(orderBy) {
              if (!(orderBy === null || orderBy === void 0 ? void 0 : orderBy.length)) {
                return this;
              }
              return fns.buildOrderBy(this, orderBy);
            }
            distinct(exprs) {
              return fns.buildDistinct(this, exprs);
            }
            union(right) {
              return fns.buildUnion(this, right);
            }
          }
          exports2.DataSourceBase = DataSourceBase;
          class TransformBase extends DataSourceBase {
            constructor(base) {
              super(base.ownerSchema);
              this.base = base;
            }
            get isExecutionWithNoResult() {
              return false;
            }
            entropy(t2) {
              return this.base.entropy(t2);
            }
            isOriginOf(a) {
              var _a;
              return a.origin === this || ((_a = this.base) === null || _a === void 0 ? void 0 : _a.isOriginOf(a));
            }
          }
          exports2.TransformBase = TransformBase;
          class FilterBase extends TransformBase {
            isAggregation() {
              return false;
            }
            constructor(_base) {
              super(_base);
            }
            get columns() {
              return this.base.columns;
            }
            selectAlias(alias) {
              return this.base.selectAlias(alias);
            }
            getColumn(column, nullIfNotFound) {
              if (!this.base) {
                throw new Error("Should not call .getColumn() on join");
              }
              if (!("columns" in this.base)) {
                throw new Error("Should not call getColumn() on table");
              }
              return this.base.getColumn(column, nullIfNotFound);
            }
            getIndex(...forValue) {
              const index = this.base.getIndex(...forValue);
              if (!index) {
                return null;
              }
              return new restrictive_index_1.RestrictiveIndex(index, this);
            }
          }
          exports2.FilterBase = FilterBase;
        },
        /* 6 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.sqlSubstring = exports2.buildBinaryValue = exports2.uncache = exports2.buildValue = void 0;
          const utils_1 = __webpack_require__(1);
          const interfaces_1 = __webpack_require__(3);
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const evaluator_1 = __webpack_require__(11);
          const datatypes_1 = __webpack_require__(2);
          const lru_cache_1 = __importDefault(__webpack_require__(22));
          const aggregation_1 = __webpack_require__(23);
          const moment_1 = __importDefault(__webpack_require__(17));
          const clean_results_1 = __webpack_require__(18);
          const context_1 = __webpack_require__(4);
          const select_1 = __webpack_require__(12);
          const builtLru = new lru_cache_1.default({
            max: 30
          });
          function buildValue(val) {
            const ret = _buildValue(val);
            checkNotUntypedArray(ret);
            return ret;
          }
          exports2.buildValue = buildValue;
          function checkNotUntypedArray(value2) {
            const type = value2.type;
            if (type instanceof datatypes_1.ArrayType && type.of == datatypes_1.Types.null) {
              throw new interfaces_1.QueryError(`cannot determine type of empty array`);
            }
          }
          function uncache(data) {
            builtLru.del(data);
          }
          exports2.uncache = uncache;
          function _buildValue(val) {
            const data = (0, context_1.buildCtx)().selection;
            let selLru = builtLru.get(data !== null && data !== void 0 ? data : null);
            let got;
            if (selLru) {
              got = selLru.get(val);
              if (got) {
                return got;
              }
            }
            got = _buildValueReal(val);
            if (data.isAggregation()) {
              got = data.checkIfIsKey(got);
            }
            if (!selLru) {
              builtLru.set(data !== null && data !== void 0 ? data : null, selLru = new lru_cache_1.default({
                max: 50
              }));
            }
            selLru.set(val, got);
            return got;
          }
          function _buildValueReal(val) {
            var _a;
            const { schema: schema2, getParameter, selection } = (0, context_1.buildCtx)();
            switch (val.type) {
              case "binary":
                if (val.op === "IN" || val.op === "NOT IN") {
                  return buildIn(val.left, val.right, val.op === "IN");
                }
                return buildBinary(val);
              case "unary":
                return buildUnary(val.op, val.operand);
              case "ref":
                const found = selection.getColumn(val, true);
                if (found) {
                  return found;
                }
                const arg = !val.table && getParameter(val.name);
                if (arg) {
                  return arg;
                }
                const alias = !val.table && selection.selectAlias(val.name);
                if (alias) {
                  return buildRecord(alias);
                }
                throw new interfaces_1.ColumnNotFound((0, utils_1.colToStr)(val));
              case "string":
                return evaluator_1.Value.text(val.value);
              case "null":
                return evaluator_1.Value.null();
              case "list":
              case "array":
                const vals = val.expressions.map((x) => _buildValue(x));
                return val.type === "list" ? evaluator_1.Value.list(vals) : evaluator_1.Value.array(vals);
              case "numeric":
                return evaluator_1.Value.number(val.value);
              case "integer":
                return evaluator_1.Value.number(val.value, datatypes_1.Types.integer);
              case "call":
                return _buildCall(val);
              case "cast":
                return _buildValue(val.operand).cast(schema2.getType(val.to));
              case "case":
                return buildCase(val);
              case "member":
                return buildMember(val);
              case "arrayIndex":
                return buildArrayIndex(val);
              case "boolean":
                return evaluator_1.Value.bool(val.value);
              case "ternary":
                return buildTernary(val);
              case "select":
              case "union":
              case "union all":
              case "with":
              case "with recursive":
              case "values":
                return buildSelectAsArray(val);
              case "array select":
                return buildSelectAsArray(val.select);
              case "constant":
                return evaluator_1.Value.constant(val.dataType, val.value);
              case "keyword":
                return buildKeyword(val, []);
              case "parameter":
                const [_, n] = (_a = /^\$(\d+)$/.exec(val.name)) !== null && _a !== void 0 ? _a : [];
                if (!n) {
                  throw new Error("Unexpected parameter ref shape: " + val.name);
                }
                return getParameter(parseInt(n) - 1);
              case "extract":
                return buildExtract(val);
              case "overlay":
                return buildOverlay(val);
              case "substring":
                return buildSubstring(val);
              case "default":
                throw new interfaces_1.QueryError(`DEFAULT is not allowed in this context`, "42601");
              default:
                throw interfaces_1.NotSupported.never(val);
            }
          }
          function buildRecord(alias) {
            const cols = [...alias.listColumns()];
            return new evaluator_1.Evaluator(
              datatypes_1.Types.record(cols.map((x) => ({
                name: x.id,
                type: x.type
              }))),
              null,
              Math.random().toString(),
              [],
              (raw, t2) => raw,
              { forceNotConstant: true }
            );
          }
          function _buildCall(val) {
            if (val.over) {
              throw new interfaces_1.NotSupported('"OVER" clause is not implemented in pg-mem yet');
            }
            const nm = (0, utils_1.asSingleQName)(val.function, "pg_catalog");
            if (nm && aggregation_1.aggregationFunctions.has(nm)) {
              const agg = (0, aggregation_1.getAggregator)();
              if (!agg) {
                throw new interfaces_1.QueryError(`aggregate functions are not allowed in WHERE`);
              }
              return agg.getAggregation(nm, val);
            }
            const args = val.args.map((x) => _buildValue(x));
            return evaluator_1.Value.function(val.function, args);
          }
          function buildKeyword(kw, args) {
            if (args.length) {
              throw new interfaces_1.NotSupported(`usage of "${kw.keyword}" keyword with arguments, please file an issue in https://github.com/oguimbal/pg-mem if you need it !`);
            }
            if (kw.type !== "keyword") {
              throw new Error("Invalid AST");
            }
            switch (kw.keyword) {
              case "current_catalog":
              case "current_role":
              case "current_user":
              case "session_user":
              case "user":
                return evaluator_1.Value.constant(datatypes_1.Types.text(), "pg_mem");
              case "current_schema":
                return evaluator_1.Value.constant(datatypes_1.Types.text(), "public");
              case "current_date":
                return evaluator_1.Value.constant(datatypes_1.Types.date, /* @__PURE__ */ new Date());
              case "current_timestamp":
              case "localtimestamp":
                return evaluator_1.Value.constant(datatypes_1.Types.timestamp(), /* @__PURE__ */ new Date());
              case "localtime":
              case "current_time":
                throw new interfaces_1.NotSupported('"date" data type, please file an issue in https://github.com/oguimbal/pg-mem if you need it !');
              case "distinct":
                throw new interfaces_1.NotSupported(kw.keyword);
              default:
                throw interfaces_1.NotSupported.never(kw.keyword);
            }
          }
          function buildUnary(op, operand) {
            const expr = _buildValue(operand);
            switch (op) {
              case "IS NULL":
              case "IS NOT NULL":
                return evaluator_1.Value.isNull(expr, op === "IS NULL");
              case "IS TRUE":
              case "IS NOT TRUE":
                return evaluator_1.Value.isTrue(expr, op === "IS TRUE");
              case "IS FALSE":
              case "IS NOT FALSE":
                return evaluator_1.Value.isFalse(expr, op === "IS FALSE");
              case "+":
                if (!(0, datatypes_1.isNumeric)(expr.type)) {
                  throw new interfaces_1.CastError(expr.type.primary, interfaces_1.DataType.float);
                }
                return expr;
              case "NOT":
              case "-":
                return evaluator_1.Value.negate(expr);
              default:
                throw interfaces_1.NotSupported.never(op, "Unary operator not supported");
            }
          }
          function buildIn(left, array, inclusive) {
            let leftValue = _buildValue(left);
            let rightValue = _buildValue(array);
            return evaluator_1.Value.in(leftValue, rightValue, inclusive);
          }
          function buildBinary(val) {
            let leftValue = _buildValue(val.left);
            let rightValue = _buildValue(val.right);
            return buildBinaryValue(leftValue, val.op, rightValue);
          }
          function buildBinaryValue(leftValue, op, rightValue) {
            function expectSame() {
              const ll = leftValue.type.primary === interfaces_1.DataType.list;
              const rl = rightValue.type.primary === interfaces_1.DataType.list;
              if (ll !== rl) {
                let doMap = function(v) {
                  return v.map((x) => {
                    if (!x) {
                      return x;
                    }
                    if (!Array.isArray(x)) {
                      throw new Error(`Was expecting an array. Got instead ${x}`);
                    }
                    if (x.length > 1) {
                      throw new interfaces_1.QueryError("more than one row returned by a subquery used as an expression", "21000");
                    }
                    return x[0];
                  }, v.type.of);
                };
                if (ll) {
                  leftValue = doMap(leftValue);
                } else {
                  rightValue = doMap(rightValue);
                }
              }
              const type = (0, datatypes_1.reconciliateTypes)([leftValue, rightValue]);
              leftValue = leftValue.cast(type);
              rightValue = rightValue.cast(type);
              return type;
            }
            function expectBoth(t2) {
              leftValue = leftValue.cast(t2);
              rightValue = rightValue.cast(t2);
            }
            let getter;
            let returnType = datatypes_1.Types.bool;
            let commutative = true;
            let forcehash = null;
            let rejectNils = true;
            let impure = false;
            switch (op) {
              case "=": {
                const type = expectSame();
                getter = (a, b) => type.equals(a, b);
                break;
              }
              case "!=": {
                const type = expectSame();
                getter = (a, b) => {
                  const ret = type.equals(a, b);
                  return (0, utils_1.nullIsh)(ret) ? null : !ret;
                };
                break;
              }
              case ">": {
                const type = expectSame();
                getter = (a, b) => type.gt(a, b);
                forcehash = { op: ">", left: leftValue.hash, right: rightValue.hash };
                break;
              }
              case "<": {
                const type = expectSame();
                getter = (a, b) => type.lt(a, b);
                forcehash = { op: ">", left: rightValue.hash, right: leftValue.hash };
                break;
              }
              case ">=": {
                const type = expectSame();
                getter = (a, b) => type.ge(a, b);
                forcehash = { op: ">=", left: leftValue.hash, right: rightValue.hash };
                break;
              }
              case "<=": {
                const type = expectSame();
                getter = (a, b) => type.le(a, b);
                forcehash = { op: ">=", left: rightValue.hash, right: leftValue.hash };
                break;
              }
              case "AND":
              case "OR":
                expectBoth(datatypes_1.Types.bool);
                rejectNils = false;
                if (op === "AND") {
                  getter = (a, b) => a && b;
                } else {
                  getter = (a, b) => a || b;
                }
                break;
              case "&&":
                if (leftValue.type.primary !== interfaces_1.DataType.array || !rightValue.canCast(leftValue.type)) {
                  throw new interfaces_1.QueryError(`Operator does not exist: ${leftValue.type.name} && ${rightValue.type.name}`, "42883");
                }
                rightValue = rightValue.cast(leftValue.type);
                getter = (a, b) => a.some((element) => b.includes(element));
                break;
              case "LIKE":
              case "ILIKE":
              case "NOT LIKE":
              case "NOT ILIKE":
                expectBoth(datatypes_1.Types.text());
                const caseSenit = op === "LIKE" || op === "NOT LIKE";
                const not2 = op === "NOT ILIKE" || op === "NOT LIKE";
                if (rightValue.isConstant) {
                  const pattern = rightValue.get();
                  if ((0, utils_1.nullIsh)(pattern)) {
                    return evaluator_1.Value.null(datatypes_1.Types.bool);
                  }
                  let matcher;
                  if (rightValue.isAny) {
                    if (!Array.isArray(pattern)) {
                      throw new interfaces_1.QueryError("Unsupported use of ANY()");
                    }
                    const patterns = pattern.map((x) => (0, utils_1.buildLikeMatcher)(x, caseSenit));
                    matcher = (v) => patterns.some((x) => x(v));
                  } else {
                    matcher = (0, utils_1.buildLikeMatcher)(pattern, caseSenit);
                  }
                  getter = !not2 ? (a) => (0, utils_1.nullIsh)(a) ? null : matcher(a) : (a) => {
                    if ((0, utils_1.nullIsh)(a)) {
                      return null;
                    }
                    const val = matcher(a);
                    return (0, utils_1.nullIsh)(val) ? null : !val;
                  };
                } else {
                  getter = !not2 ? (a, b) => (0, utils_1.hasNullish)(a, b) ? null : (0, utils_1.buildLikeMatcher)(b, caseSenit)(a) : (a, b) => {
                    if ((0, utils_1.hasNullish)(a, b)) {
                      return null;
                    }
                    const val = (0, utils_1.buildLikeMatcher)(b, caseSenit)(a);
                    return (0, utils_1.nullIsh)(val) ? null : !val;
                  };
                }
                break;
              default: {
                const { schema: schema2 } = (0, context_1.buildCtx)();
                const resolved = schema2.resolveOperator(op, leftValue, rightValue);
                if (!resolved) {
                  throw new interfaces_1.QueryError(`operator does not exist: ${leftValue.type.name} ${op} ${rightValue.type.name}`, "42883");
                }
                leftValue = leftValue.cast(resolved.left);
                rightValue = rightValue.cast(resolved.right);
                commutative = resolved.commutative;
                returnType = resolved.returns;
                getter = resolved.implementation;
                rejectNils = !resolved.allowNullArguments;
                impure = !!resolved.impure;
                break;
              }
            }
            const hashed = (0, object_hash_1.default)(forcehash !== null && forcehash !== void 0 ? forcehash : commutative ? { op, vals: [leftValue.hash, rightValue.hash].sort() } : { left: leftValue.hash, op, right: rightValue.hash });
            if (leftValue.isAny || rightValue.isAny) {
              return buildBinaryAny(leftValue, op, rightValue, returnType, getter, hashed);
            }
            return new evaluator_1.Evaluator(returnType, null, hashed, [leftValue, rightValue], (raw, t2) => {
              const leftRaw = leftValue.get(raw, t2);
              const rightRaw = rightValue.get(raw, t2);
              if (rejectNils && ((0, utils_1.nullIsh)(leftRaw) || (0, utils_1.nullIsh)(rightRaw))) {
                return null;
              }
              return getter(leftRaw, rightRaw);
            }, impure ? { unpure: impure } : void 0);
          }
          exports2.buildBinaryValue = buildBinaryValue;
          function buildBinaryAny(leftValue, op, rightValue, returnType, getter, hashed) {
            if (leftValue.isAny && rightValue.isAny) {
              throw new interfaces_1.QueryError("ANY() cannot be compared to ANY()");
            }
            if (returnType !== datatypes_1.Types.bool) {
              throw new interfaces_1.QueryError("Invalid ANY() usage");
            }
            return new evaluator_1.Evaluator(returnType, null, hashed, [leftValue, rightValue], leftValue.isAny ? (raw, t2) => {
              const leftRaw = leftValue.get(raw, t2);
              if ((0, utils_1.nullIsh)(leftRaw)) {
                return null;
              }
              if (!Array.isArray(leftRaw)) {
                throw new interfaces_1.QueryError("Invalid ANY() usage: was expacting an array");
              }
              for (const lr of leftRaw) {
                const rightRaw = rightValue.get(raw, t2);
                if (getter(lr, rightRaw)) {
                  return true;
                }
              }
              return false;
            } : (raw, t2) => {
              const rightRaw = rightValue.get(raw, t2);
              if ((0, utils_1.nullIsh)(rightRaw)) {
                return null;
              }
              if (!Array.isArray(rightRaw)) {
                throw new interfaces_1.QueryError("Invalid ANY() usage: was expacting an array");
              }
              for (const rr of rightRaw) {
                const leftRaw = leftValue.get(raw, t2);
                if (getter(leftRaw, rr)) {
                  return true;
                }
              }
              return false;
            });
          }
          function buildCase(op) {
            const whens = !op.value ? op.whens : op.whens.map((v) => ({
              when: {
                type: "binary",
                op: "=",
                left: op.value,
                right: v.when
              },
              value: v.value
            }));
            if (op.else) {
              whens.push({
                when: { type: "boolean", value: true },
                value: op.else
              });
            }
            const whenExprs = whens.map((x) => ({
              when: buildValue(x.when).cast(datatypes_1.Types.bool),
              then: buildValue(x.value)
            }));
            const valueType = (0, datatypes_1.reconciliateTypes)(whenExprs.map((x) => x.then));
            for (const v of whenExprs) {
              v.then = v.then.cast(valueType);
            }
            return new evaluator_1.Evaluator(valueType, null, (0, object_hash_1.default)({ when: whenExprs.map((x) => ({ when: x.when.hash, then: x.then.hash })) }), [
              ...whenExprs.map((x) => x.when),
              ...whenExprs.map((x) => x.then)
            ], (raw, t2) => {
              for (const w of whenExprs) {
                const cond = w.when.get(raw, t2);
                if (cond) {
                  return w.then.get(raw, t2);
                }
              }
              return null;
            });
          }
          function buildMember(op) {
            const oop = op.op;
            if (oop !== "->>" && oop !== "->") {
              throw interfaces_1.NotSupported.never(oop);
            }
            const onExpr = buildValue(op.operand);
            if (onExpr.type !== datatypes_1.Types.json && onExpr.type !== datatypes_1.Types.jsonb) {
              throw new interfaces_1.QueryError(`Cannot use member expression ${op.op} on type ${onExpr.type.primary}`);
            }
            const conv = op.op === "->" ? (x) => x : (x) => {
              if ((0, utils_1.nullIsh)(x)) {
                return null;
              }
              if (typeof x === "string") {
                return x;
              }
              return JSON.stringify(x);
            };
            return new evaluator_1.Evaluator(op.op === "->" ? onExpr.type : datatypes_1.Types.text(), null, (0, object_hash_1.default)([onExpr.hash, op.op, op.member]), onExpr, typeof op.member === "string" ? (raw, t2) => {
              const value2 = onExpr.get(raw, t2);
              if (!value2 || typeof value2 !== "object") {
                return null;
              }
              return conv(value2[op.member]);
            } : (raw, t2) => {
              const value2 = onExpr.get(raw, t2);
              if (!Array.isArray(value2)) {
                return null;
              }
              const i = op.member < 0 ? value2.length + op.member : op.member;
              return conv(value2[i]);
            });
          }
          function buildArrayIndex(op) {
            const onExpr = _buildValue(op.array);
            if (onExpr.type.primary !== interfaces_1.DataType.array) {
              throw new interfaces_1.QueryError(`Cannot use [] expression on type ${onExpr.type.primary}`);
            }
            const index = _buildValue(op.index).cast(datatypes_1.Types.integer);
            return new evaluator_1.Evaluator(onExpr.type.of, null, (0, object_hash_1.default)({ array: onExpr.hash, index: index.hash }), [onExpr, index], (raw, t2) => {
              const value2 = onExpr.get(raw, t2);
              if (!Array.isArray(value2)) {
                return null;
              }
              const i = index.get(raw, t2);
              if (typeof i !== "number" || i <= 0 || i > value2.length) {
                return null;
              }
              const ret = value2[i - 1];
              if (Array.isArray(ret)) {
                ret[clean_results_1.IS_PARTIAL_INDEXING] = true;
              }
              return ret;
            });
          }
          function buildTernary(op) {
            const oop = op.op;
            if (oop !== "NOT BETWEEN" && oop !== "BETWEEN") {
              throw interfaces_1.NotSupported.never(oop);
            }
            let value2 = _buildValue(op.value);
            let hi = _buildValue(op.hi);
            let lo = _buildValue(op.lo);
            const type = (0, datatypes_1.reconciliateTypes)([value2, hi, lo]);
            value2 = value2.cast(type);
            hi = hi.cast(type);
            lo = lo.cast(type);
            const conv = oop === "NOT BETWEEN" ? (x) => !x : (x) => x;
            return new evaluator_1.Evaluator(datatypes_1.Types.bool, null, (0, object_hash_1.default)({ value: value2.hash, lo: lo.hash, hi: hi.hash }), [value2, hi, lo], (raw, t2) => {
              const v = value2.get(raw, t2);
              if ((0, utils_1.nullIsh)(v)) {
                return null;
              }
              const lov = lo.get(raw, t2);
              if (!(0, utils_1.nullIsh)(lov) && type.lt(v, lov)) {
                return conv(false);
              }
              const hiv = hi.get(raw, t2);
              if (!(0, utils_1.nullIsh)(hiv) && type.gt(v, hiv)) {
                return conv(false);
              }
              if ((0, utils_1.nullIsh)(lov) || (0, utils_1.nullIsh)(hiv)) {
                return null;
              }
              return conv(true);
            });
          }
          function buildSelectAsArray(op) {
            const onData = (0, select_1.buildSelect)(op);
            if (onData.columns.length !== 1) {
              throw new interfaces_1.QueryError("subquery must return only one column", "42601");
            }
            return new evaluator_1.Evaluator(
              onData.columns[0].type.asList(),
              null,
              Math.random().toString(),
              null,
              (raw, t2) => {
                const ret = [];
                for (const v of onData.enumerate(t2)) {
                  ret.push(onData.columns[0].get(v, t2));
                }
                return ret;
              },
              {
                forceNotConstant: true
              }
            );
          }
          function buildExtract(op) {
            const from = _buildValue(op.from);
            function extract(as, fn, result = datatypes_1.Types.integer) {
              const conv = from.cast(as);
              return new evaluator_1.Evaluator(result, null, (0, object_hash_1.default)({ extract: from.hash, field: op.field }), [conv], (raw, t2) => {
                const got = conv.get(raw, t2);
                if ((0, utils_1.nullIsh)(got)) {
                  return null;
                }
                return fn(got);
              });
            }
            switch (op.field.name) {
              case "millennium":
                return extract(datatypes_1.Types.date, (x) => Math.ceil(moment_1.default.utc(x).year() / 1e3));
              case "century":
                return extract(datatypes_1.Types.date, (x) => Math.ceil(moment_1.default.utc(x).year() / 100));
              case "decade":
                return extract(datatypes_1.Types.date, (x) => Math.floor(moment_1.default.utc(x).year() / 10));
              case "day":
                if (from.canCast(datatypes_1.Types.date)) {
                  return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).date());
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a;
                  return (_a = x.days) !== null && _a !== void 0 ? _a : 0;
                });
              case "second":
                if (from.canCast(datatypes_1.Types.time)) {
                  return extract(datatypes_1.Types.time, (x) => {
                    const t2 = (0, utils_1.parseTime)(x);
                    return t2.second() + t2.milliseconds() / 1e3;
                  }, datatypes_1.Types.float);
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a, _b;
                  return ((_a = x.seconds) !== null && _a !== void 0 ? _a : 0) + ((_b = x.milliseconds) !== null && _b !== void 0 ? _b : 0) / 1e3;
                }, datatypes_1.Types.float);
              case "minute":
                if (from.canCast(datatypes_1.Types.time)) {
                  return extract(datatypes_1.Types.time, (x) => (0, utils_1.parseTime)(x).minute());
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a;
                  return (_a = x.minutes) !== null && _a !== void 0 ? _a : 0;
                });
              case "milliseconds":
                if (from.canCast(datatypes_1.Types.time)) {
                  return extract(datatypes_1.Types.time, (x) => {
                    const t2 = (0, utils_1.parseTime)(x);
                    return t2.seconds() * 1e3 + t2.milliseconds();
                  });
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a, _b;
                  return ((_a = x.seconds) !== null && _a !== void 0 ? _a : 0) * 1e3 + ((_b = x.milliseconds) !== null && _b !== void 0 ? _b : 0);
                }, datatypes_1.Types.float);
              case "month":
                if (from.canCast(datatypes_1.Types.date)) {
                  return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).month() + 1);
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a;
                  return (_a = x.months) !== null && _a !== void 0 ? _a : 0;
                });
              case "year":
                if (from.canCast(datatypes_1.Types.date)) {
                  return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).year());
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a;
                  return (_a = x.years) !== null && _a !== void 0 ? _a : 0;
                });
              case "dow":
                return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).day());
              case "isodow":
                return extract(datatypes_1.Types.date, (x) => {
                  const dow = moment_1.default.utc(x).day();
                  return dow ? dow : 7;
                });
              case "doy":
                return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).dayOfYear());
              case "epoch":
                if (from.canCast(datatypes_1.Types.timestamp())) {
                  return extract(datatypes_1.Types.timestamp(), (x) => moment_1.default.utc(x).unix(), datatypes_1.Types.float);
                }
                return extract(datatypes_1.Types.interval, (x) => (0, utils_1.intervalToSec)(x));
              case "hour":
                if (from.canCast(datatypes_1.Types.timestamp())) {
                  return extract(datatypes_1.Types.timestamp(), (x) => moment_1.default.utc(x).hour());
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a;
                  return (_a = x.hours) !== null && _a !== void 0 ? _a : 0;
                });
              case "isoyear":
                return extract(datatypes_1.Types.date, (x) => {
                  const d = moment_1.default.utc(x);
                  return d.dayOfYear() <= 1 ? d.year() - 1 : d.year();
                });
              case "quarter":
                return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).quarter());
              case "week":
                return extract(datatypes_1.Types.date, (x) => moment_1.default.utc(x).week());
              case "microseconds":
                if (from.canCast(datatypes_1.Types.time)) {
                  return extract(datatypes_1.Types.time, (x) => {
                    const t2 = (0, utils_1.parseTime)(x);
                    return t2.seconds() * 1e6 + t2.milliseconds() * 1e3;
                  });
                }
                return extract(datatypes_1.Types.interval, (x) => {
                  var _a, _b;
                  return ((_a = x.seconds) !== null && _a !== void 0 ? _a : 0) * 1e6 + ((_b = x.milliseconds) !== null && _b !== void 0 ? _b : 0) * 1e3;
                });
              default:
                throw new interfaces_1.NotSupported('Extract type "' + op.field + '"');
            }
          }
          function buildOverlay(op) {
            const value2 = _buildValue(op.value).cast(datatypes_1.Types.text());
            const placing = _buildValue(op.placing).cast(datatypes_1.Types.text());
            const from = _buildValue(op.from).cast(datatypes_1.Types.integer);
            const forr = op.for && _buildValue(op.for).cast(datatypes_1.Types.integer);
            return new evaluator_1.Evaluator(datatypes_1.Types.text(), null, (0, object_hash_1.default)({ overlay: value2.hash, placing: placing.hash, from: from.hash, for: forr === null || forr === void 0 ? void 0 : forr.hash }), forr ? [value2, placing, from, forr] : [value2, placing, from], (raw, t2) => {
              const _value = value2.get(raw, t2);
              if ((0, utils_1.nullIsh)(_value)) {
                return null;
              }
              const _placing = placing.get(raw, t2);
              if ((0, utils_1.nullIsh)(_placing)) {
                return null;
              }
              const _from = from.get(raw, t2);
              if ((0, utils_1.nullIsh)(_from)) {
                return null;
              }
              const before = sqlSubstring(_value, 0, _from - 1);
              let after;
              if (forr) {
                const _for = forr.get(raw, t2);
                if ((0, utils_1.nullIsh)(_for)) {
                  return null;
                }
                after = sqlSubstring(_value, _from + _for);
              } else {
                after = sqlSubstring(_value, _placing.length + _from);
              }
              if ((0, utils_1.nullIsh)(after)) {
                return null;
              }
              return before + _placing + after;
            });
          }
          function buildSubstring(op) {
            const value2 = _buildValue(op.value).cast(datatypes_1.Types.text());
            const vals = [value2];
            const from = op.from && _buildValue(op.from).cast(datatypes_1.Types.integer);
            const forr = op.for && _buildValue(op.for).cast(datatypes_1.Types.integer);
            if (forr) {
              vals.push(forr);
            }
            if (from) {
              vals.push(from);
            }
            return new evaluator_1.Evaluator(datatypes_1.Types.text(), null, (0, object_hash_1.default)({ substr: value2.hash, from: from === null || from === void 0 ? void 0 : from.hash, for: forr === null || forr === void 0 ? void 0 : forr.hash }), vals, (raw, t2) => {
              const _value = value2.get(raw, t2);
              if ((0, utils_1.nullIsh)(_value)) {
                return null;
              }
              let start = 0;
              let len;
              if (from) {
                start = from.get(raw, t2);
                if ((0, utils_1.nullIsh)(start)) {
                  return null;
                }
              }
              if (forr) {
                len = forr.get(raw, t2);
                if ((0, utils_1.nullIsh)(len)) {
                  return null;
                }
              }
              return sqlSubstring(_value, start, len);
            });
          }
          function sqlSubstring(value2, from = 0, len) {
            if ((0, utils_1.nullIsh)(from) || (0, utils_1.nullIsh)(value2)) {
              return null;
            }
            from--;
            if (from < 0) {
              from = 0;
            }
            if (!(0, utils_1.nullIsh)(len)) {
              if (len < 0) {
                throw new interfaces_1.QueryError("negative substring length not allowed");
              }
              return value2.substr(from, len);
            }
            return value2.substr(from);
          }
          exports2.sqlSubstring = sqlSubstring;
        },
        /* 7 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ExecHelper = exports2.locOf = exports2.checkExistence = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          function checkExistence(schema2, name, ifNotExists, act) {
            const exists = schema2.getObject(name, {
              skipSearch: true,
              nullIfNotFound: true
            });
            if (exists) {
              if (ifNotExists) {
                return false;
              }
              throw new interfaces_private_1.QueryError(`relation "${name.name}" already exists`);
            }
            act();
            return true;
          }
          exports2.checkExistence = checkExistence;
          function locOf(p) {
            var _a;
            return (_a = p._location) !== null && _a !== void 0 ? _a : { start: 0, end: 0 };
          }
          exports2.locOf = locOf;
          class ExecHelper {
            constructor(statement) {
              this.statement = statement;
            }
            noData(t2, name) {
              return {
                result: {
                  command: name !== null && name !== void 0 ? name : this.statement.type.toUpperCase(),
                  fields: [],
                  rowCount: 0,
                  rows: [],
                  location: locOf(this.statement)
                },
                state: t2
              };
            }
          }
          exports2.ExecHelper = ExecHelper;
        },
        /* 8 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ReadOnlyTable = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const transform_base_1 = __webpack_require__(5);
          const alias_1 = __webpack_require__(25);
          const selection_1 = __webpack_require__(10);
          const utils_1 = __webpack_require__(1);
          class ReadOnlyTable extends transform_base_1.DataSourceBase {
            constructor(schema2) {
              super(schema2);
              this.schema = schema2;
              this.selection = (0, alias_1.buildAlias)(this);
              this.hidden = true;
              this.columnsById = /* @__PURE__ */ new Map();
            }
            get isExecutionWithNoResult() {
              return false;
            }
            get primaryIndex() {
              return null;
            }
            getColumns() {
              throw new Error("Method not implemented on schema tables.");
            }
            isOriginOf(v) {
              return v.origin === this || v.origin === this.selection;
            }
            get type() {
              return "table";
            }
            get name() {
              return this._schema.name;
            }
            register() {
              this.reg = this.schema._reg_register(this);
            }
            build() {
              if (this._columns) {
                return;
              }
              this._columns = [];
              for (const _col of this._schema.fields) {
                const newCol = (0, selection_1.columnEvaluator)(this, _col.name, _col.type);
                this._columns.push(newCol);
                this.columnsById.set(_col.name, newCol);
              }
            }
            get columns() {
              this.build();
              return this._columns;
            }
            getColumn(column, nullIfNotFound) {
              this.build();
              if (typeof column !== "string" && column.table) {
                if (!column.table.schema && column.table.name !== this.name) {
                  return null;
                }
                column = column.name;
              }
              return (0, utils_1.colByName)(this.columnsById, column, nullIfNotFound);
            }
            explain(e) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            listIndices() {
              return [];
            }
            stats(t2) {
              throw new interfaces_private_1.NotSupported("stats (count, ...) on information schema");
            }
            rename(to) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            update(t2, toUpdate) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            addColumn(column) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            getColumnRef(column, nullIfNotFound) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            getConstraint(constraint) {
              return null;
            }
            addConstraint(constraint, t2) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            insert(item) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            doInsert(toInsert) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            delete(t2, toDelete) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            truncate(t2) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            createIndex() {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            dropIndex(t2, name) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            setHidden() {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            drop(t2) {
              throw new interfaces_private_1.PermissionDeniedError(this.name);
            }
            setReadonly() {
              return this;
            }
            getIndex(...forValue) {
              return null;
            }
            on() {
              throw new interfaces_private_1.NotSupported("subscribing information schema");
            }
            onBeforeChange(columns, check) {
              return { unsubscribe() {
              } };
            }
            onCheckChange(columns, check) {
              return { unsubscribe() {
              } };
            }
            onTruncate(sub) {
              return { unsubscribe() {
              } };
            }
            onDrop(sub) {
              return { unsubscribe() {
              } };
            }
            onIndex(sub) {
              return { unsubscribe() {
              } };
            }
            find(template, columns) {
              return (0, utils_1.findTemplate)(this.selection, this.db.data, template, columns);
            }
            make(table, i, t2) {
              throw new Error("not implemented");
            }
            *itemsByTable(table, t2) {
              if (typeof table === "string") {
                for (const s of this.db.listSchemas()) {
                  const got = s.getTable(table, true);
                  if (got) {
                    yield* this.itemsByTable(got, t2);
                  }
                }
              } else {
                let i = 0;
                for (const f of table.selection.columns) {
                  yield this.make(table, ++i, f);
                }
              }
            }
          }
          exports2.ReadOnlyTable = ReadOnlyTable;
        },
        /* 9 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TypeBase = exports2.regGen = void 0;
          const evaluator_1 = __webpack_require__(11);
          const interfaces_private_1 = __webpack_require__(0);
          const datatypes_1 = __webpack_require__(14);
          const utils_1 = __webpack_require__(1);
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const interfaces_1 = __webpack_require__(3);
          let regCnt = 0;
          function regGen() {
            return {
              classId: ++regCnt,
              typeId: ++regCnt
            };
          }
          exports2.regGen = regGen;
          class TypeBase {
            constructor() {
              this.reg = regGen();
            }
            get [utils_1.isType.TAG]() {
              return true;
            }
            get type() {
              return "type";
            }
            get name() {
              return this.primary;
            }
            doEquals(a, b) {
              return a === b;
            }
            doGt(a, b) {
              return a > b;
            }
            doLt(a, b) {
              return a < b;
            }
            toString() {
              throw new Error("Method not implemented.");
            }
            equals(a, b) {
              if ((0, utils_1.nullIsh)(a) || (0, utils_1.nullIsh)(b)) {
                return null;
              }
              return this.doEquals(a, b);
            }
            gt(a, b) {
              if ((0, utils_1.nullIsh)(a) || (0, utils_1.nullIsh)(b)) {
                return null;
              }
              return this.doGt(a, b);
            }
            lt(a, b) {
              if ((0, utils_1.nullIsh)(a) || (0, utils_1.nullIsh)(b)) {
                return null;
              }
              return this.doLt(a, b);
            }
            ge(a, b) {
              return this.gt(a, b) || this.equals(a, b);
            }
            le(a, b) {
              return this.lt(a, b) || this.equals(a, b);
            }
            /**
             * When performing 'a+b', will be given 'b' type,
             * this returns the prefered resulting type, or null if they are not compatible
              */
            prefer(to) {
              var _b, _c;
              if (to === this) {
                return this;
              }
              if (this.doPrefer) {
                const ret = this.doPrefer(to);
                if (ret) {
                  return ret;
                }
              }
              return (_c = (_b = to).doPrefer) === null || _c === void 0 ? void 0 : _c.call(_b, this);
            }
            /**
             * Can constant literals be converted implicitely
             * (without a cast... i.e. you can use both values as different values of a case expression, for instance)
             **/
            canConvertImplicit(to) {
              var _b;
              if (to === this) {
                return true;
              }
              return (_b = this.doCanConvertImplicit) === null || _b === void 0 ? void 0 : _b.call(this, to);
            }
            /** Can be explicitely casted to */
            canCast(to) {
              var _b, _c, _d, _e;
              if (to === this) {
                return true;
              }
              if ((_c = (_b = to).doCanBuildFrom) === null || _c === void 0 ? void 0 : _c.call(_b, this)) {
                return true;
              }
              if (((_d = this.doCanConvertImplicit) === null || _d === void 0 ? void 0 : _d.call(this, to)) || ((_e = this.doCanCast) === null || _e === void 0 ? void 0 : _e.call(this, to))) {
                return true;
              }
              return false;
            }
            /** Perform cast */
            cast(_a, _to) {
              return this._convert(_a, _to, (a, to) => {
                var _b;
                if (!((_b = this.doCanCast) === null || _b === void 0 ? void 0 : _b.call(this, to)) || !this.doCast) {
                  throw new interfaces_private_1.CastError(this, to);
                }
                return this.doCast(a, to);
              });
            }
            /** Perform implicit conversion */
            convertImplicit(_a, _to) {
              return this._convert(_a, _to, (a, to) => {
                var _b;
                if (!((_b = this.doCanConvertImplicit) === null || _b === void 0 ? void 0 : _b.call(this, to)) || !this.doCast) {
                  throw new interfaces_private_1.CastError(this, to);
                }
                return this.doCast(a, to);
              });
            }
            _convert(a, _to, perform) {
              var _b;
              const to = _to;
              if (to === this) {
                return a;
              }
              if (!(a instanceof evaluator_1.Evaluator)) {
                throw new interfaces_private_1.CastError(this, to);
              }
              let converted;
              if ((_b = to.doCanBuildFrom) === null || _b === void 0 ? void 0 : _b.call(to, this)) {
                if (!to.doBuildFrom) {
                  throw new interfaces_private_1.CastError(this, to);
                }
                converted = to.doBuildFrom(a, this);
              } else {
                converted = perform(a, to);
              }
              if (!converted) {
                throw new interfaces_private_1.CastError(this, to);
              }
              return converted.setType(to);
            }
            asArray() {
              if (this._asArray) {
                return this._asArray;
              }
              return this._asArray = new datatypes_1.ArrayType(this, false);
            }
            asList() {
              if (this._asList) {
                return this._asList;
              }
              return this._asList = new datatypes_1.ArrayType(this, true);
            }
            hash(value2) {
              if ((0, utils_1.nullIsh)(value2)) {
                return null;
              }
              if (this.doGetHash) {
                return this.doGetHash(value2);
              }
              if (typeof value2 === "number") {
                return value2;
              }
              return (0, object_hash_1.default)(value2);
            }
            drop(t2) {
              throw new interfaces_1.QueryError("drop type not implemented");
            }
          }
          exports2.TypeBase = TypeBase;
        },
        /* 10 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.SelectionIndex = exports2.Selection = exports2.columnEvaluator = exports2.buildSelection = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const interfaces_1 = __webpack_require__(3);
          const expression_builder_1 = __webpack_require__(6);
          const evaluator_1 = __webpack_require__(11);
          const transform_base_1 = __webpack_require__(5);
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const aggregation_1 = __webpack_require__(23);
          const utils_1 = __webpack_require__(1);
          const context_1 = __webpack_require__(4);
          function buildSelection(on, select) {
            select = select !== null && select !== void 0 ? select : [];
            if ((0, utils_1.isSelectAllArgList)(select.map((x) => x.expr))) {
              if (!on.columns.length) {
                throw new interfaces_1.QueryError("SELECT * with no tables specified is not valid");
              }
              return on;
            }
            for (const col of select !== null && select !== void 0 ? select : []) {
              if (!on.isAggregation() && "expr" in col && hasAggreg(col.expr)) {
                return (0, aggregation_1.buildGroupBy)(on, []).select(select);
              }
            }
            return new Selection(on, select);
          }
          exports2.buildSelection = buildSelection;
          function hasAggreg(e) {
            let has5 = false;
            (0, pgsql_ast_parser_1.astVisitor)((visitor) => ({
              call: (expr) => {
                const nm = (0, utils_1.asSingleQName)(expr.function, "pg_catalog");
                if (nm && aggregation_1.aggregationFunctions.has(nm)) {
                  has5 = true;
                  return;
                }
                visitor.super().call(expr);
              }
            })).expr(e);
            return has5;
          }
          function columnEvaluator(on, id, type) {
            if (!id) {
              throw new Error("Invalid column id");
            }
            const ret = new evaluator_1.Evaluator(type, id, id, null, (raw) => raw[id], {
              isColumnOf: on
            });
            return ret;
          }
          exports2.columnEvaluator = columnEvaluator;
          function* buildCols(base, columns) {
            var _a;
            for (const s of columns) {
              if ("val" in s) {
                if (s.val.origin !== base) {
                  throw new Error("Corrupted selection");
                }
                yield s;
                continue;
              }
              if (s.expr.type === "ref" && s.expr.name === "*") {
                if (s.alias) {
                  throw new interfaces_1.QueryError("Cannot alias *");
                }
                let of = base;
                const alias = s.expr.table;
                if (alias) {
                  const sub = base.selectAlias(alias.name);
                  if (!sub) {
                    throw new interfaces_1.QueryError(`Unknown alias "${alias.name}"`);
                  }
                  of = sub;
                }
                for (const val of of.listColumns()) {
                  yield { val };
                }
              } else {
                const val = (0, expression_builder_1.buildValue)(s.expr);
                yield { val, as: (_a = s.alias) === null || _a === void 0 ? void 0 : _a.name, expr: s.expr };
              }
            }
          }
          class Selection extends transform_base_1.TransformBase {
            constructor(base, _columns) {
              var _a;
              super(base);
              this.columnIds = [];
              this.columnsOrigin = [];
              this.columnMapping = /* @__PURE__ */ new Map();
              this.indexCache = /* @__PURE__ */ new Map();
              this.columnsById = /* @__PURE__ */ new Map();
              this.symbol = Symbol();
              this.columns = [];
              const columns = (0, context_1.withSelection)(base, () => [...buildCols(base, _columns)]);
              this.columnIds = columns.map((x) => {
                var _a2;
                return (_a2 = x.as) !== null && _a2 !== void 0 ? _a2 : x.val.id;
              });
              let anonymousBases = /* @__PURE__ */ new Map();
              for (let i = 0; i < this.columnIds.length; i++) {
                if (!this.columnIds[i]) {
                  let id = (_a = (0, utils_1.suggestColumnName)(columns[i].expr)) !== null && _a !== void 0 ? _a : "column";
                  let cnt = anonymousBases.get(id);
                  this.columnIds[i] = id + (cnt ? cnt : "");
                  anonymousBases.set(id, (cnt !== null && cnt !== void 0 ? cnt : 0) + 1);
                }
              }
              for (let i = 0; i < columns.length; i++) {
                this.refColumn(columns[i].val, this.columnIds[i]);
              }
              const has5 = /* @__PURE__ */ new Map();
              for (let i = 0; i < columns.length; i++) {
                const orig = this.columnIds[i];
                const oi = has5.get(orig);
                if (typeof oi !== "number") {
                  has5.set(orig, i);
                  continue;
                }
                let ret = orig;
                let k = 0;
                do {
                  ret = orig + ++k;
                } while (this.columnIds.includes(ret));
                this.columnIds[i] = ret;
                has5.set(ret, i);
              }
            }
            isAggregation() {
              return false;
            }
            refColumn(fromCol, alias) {
              const col = columnEvaluator(this, alias, fromCol.type);
              this.columns.push(col);
              this.columnMapping.set(col, fromCol);
              this.columnsOrigin.push(fromCol);
              if (!col.id) {
                return;
              }
              let ci = this.columnsById.get(col.id);
              if (!ci) {
                this.columnsById.set(col.id, ci = []);
              }
              ci.push(col);
            }
            stats(t2) {
              return this.base.stats(t2);
            }
            *enumerate(t2) {
              for (const item of this.base.enumerate(t2)) {
                yield this.build(item, t2);
              }
            }
            build(item, t2) {
              var _a;
              const ret = {};
              (0, interfaces_private_1.setId)(ret, (0, interfaces_private_1.getId)(item));
              ret[this.symbol] = this.symbol;
              for (let i = 0; i < this.columns.length; i++) {
                const col = this.columnsOrigin[i];
                ret[this.columnIds[i]] = (_a = col.get(item, t2)) !== null && _a !== void 0 ? _a : null;
              }
              return ret;
            }
            hasItem(value2, t2) {
              return value2[this.symbol] === this.symbol;
            }
            getColumn(column, nullIfNotFound) {
              const ret = (0, utils_1.colByName)(this.columnsById, column, true);
              if (!(ret === null || ret === void 0 ? void 0 : ret.length)) {
                if (nullIfNotFound) {
                  return null;
                }
                throw new interfaces_1.ColumnNotFound((0, utils_1.colToStr)(column));
              }
              if (ret.length !== 1) {
                throw new interfaces_1.AmbiguousColumn((0, utils_1.colToStr)(column));
              }
              return ret[0];
            }
            getIndex(val) {
              if (this.indexCache.has(val)) {
                return this.indexCache.get(val);
              }
              const mapped = this.columnMapping.get(val);
              const originIndex = this.base.getIndex(mapped);
              const ret = originIndex && new SelectionIndex(this, originIndex);
              this.indexCache.set(val, ret);
              return ret;
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "map",
                of: this.base.explain(e),
                select: this.columnIds.map((x, i) => ({
                  what: this.columnsOrigin[i].explain(e),
                  as: x
                }))
              };
            }
          }
          exports2.Selection = Selection;
          class SelectionIndex {
            constructor(owner, base) {
              this.owner = owner;
              this.base = base;
            }
            stats(t2, key) {
              return this.base.stats(t2, key);
            }
            iterateKeys(t2) {
              return this.base.iterateKeys(t2);
            }
            get expressions() {
              return this.base.expressions;
            }
            entropy(op) {
              return this.base.entropy(op);
            }
            eqFirst(rawKey, t2) {
              return this.base.eqFirst(rawKey, t2);
            }
            *enumerate(op) {
              for (const i of this.base.enumerate(op)) {
                yield this.owner.build(i, op.t);
              }
            }
            explain(e) {
              return {
                _: "indexMap",
                of: this.base.explain(e)
              };
            }
          }
          exports2.SelectionIndex = SelectionIndex;
        },
        /* 11 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildParameterList = exports2.Value = exports2.Evaluator = void 0;
          const interfaces_1 = __webpack_require__(3);
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const datatypes_1 = __webpack_require__(2);
          const function_call_1 = __webpack_require__(40);
          const utils_1 = __webpack_require__(1);
          class Evaluator {
            constructor(type, id, hash2, dependencies, val, opts) {
              var _a;
              this.type = type;
              this.id = id;
              this.hash = hash2;
              this.val = val;
              this.opts = opts;
              this.usedColumns = /* @__PURE__ */ new Set();
              this.isConstantLiteral = typeof val !== "function";
              if (opts === null || opts === void 0 ? void 0 : opts.forceNotConstant) {
                this.forceNotConstant = true;
              }
              let depArray = void 0;
              let hasNotConstant = false;
              if (dependencies) {
                if (!Array.isArray(dependencies)) {
                  depArray = [dependencies];
                  this.usedColumns = dependencies.usedColumns;
                  hasNotConstant = !dependencies.isConstant;
                  this.origin = dependencies.origin;
                } else {
                  this.usedColumns = /* @__PURE__ */ new Set();
                  for (const d of dependencies) {
                    if (d.origin) {
                      if (this.origin && d.origin && this.origin !== d.origin) {
                        throw new Error("You cannot evaluate an expression which is coming from multiple origins");
                      }
                      this.origin = d.origin;
                    }
                    if (!d.isConstant) {
                      hasNotConstant = true;
                    }
                    for (const u of d.usedColumns) {
                      this.usedColumns.add(u);
                    }
                  }
                }
              }
              if (opts === null || opts === void 0 ? void 0 : opts.isColumnOf) {
                this.usedColumns.add(this);
                this.origin = opts.isColumnOf;
                delete opts.isColumnOf;
              }
              if (hasNotConstant && !this.usedColumns.size) {
                this.forceNotConstant = true;
              }
              if (!this.usedColumns.size && !this.origin && !((_a = this.opts) === null || _a === void 0 ? void 0 : _a.unpure) && !this.forceNotConstant && !(depArray === null || depArray === void 0 ? void 0 : depArray.some((x) => !x.isConstantReal))) {
                if (typeof this.val === "function") {
                  this.val = this.val(null, null);
                }
              }
            }
            get index() {
              var _a;
              return (_a = this.origin) === null || _a === void 0 ? void 0 : _a.getIndex(this);
            }
            get isConstant() {
              return !this.usedColumns.size && !this.forceNotConstant;
            }
            get isConstantReal() {
              return typeof this.val !== "function";
            }
            get isAny() {
              var _a, _b;
              return (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.isAny) !== null && _b !== void 0 ? _b : false;
            }
            setType(type) {
              if (this.type === type) {
                return this;
              }
              return new Evaluator(type, this.id, this.hash, this, this.val, this.opts);
            }
            setConversion(converter, hashConv) {
              return new Evaluator(this.type, this.id, (0, object_hash_1.default)(hashConv(this.hash)), this, (raw, t2) => {
                let got = this.get(raw, t2);
                if ((0, utils_1.nullIsh)(got)) {
                  return null;
                }
                if (!this.isAny) {
                  return converter(got, t2);
                }
                if (!Array.isArray(got)) {
                  throw new interfaces_1.QueryError("Unexpected use of ANY()");
                }
                return got.map((x) => converter(x, t2));
              }, this.opts);
            }
            setOrigin(origin) {
              const ret = this.clone();
              ret.origin = origin;
              return ret;
            }
            clone() {
              return new Evaluator(this.type, this.id, this.hash, this, this.val, this.opts);
            }
            map(mapper, newType) {
              if (this.isAny) {
                throw new interfaces_1.QueryError("Unexpected use of ANY()");
              }
              const ret = new Evaluator(newType !== null && newType !== void 0 ? newType : this.type, this.id, this.hash, this, (raw, t2) => {
                const got = this.get(raw, t2);
                if ((0, utils_1.nullIsh)(got)) {
                  return null;
                }
                return mapper(got);
              }, this.opts);
              ret.origin = this.origin;
              return ret;
            }
            setWrapper(newOrigin, unwrap, newType) {
              if (this.isAny) {
                throw new interfaces_1.QueryError("Unexpected use of ANY()");
              }
              const ret = new Evaluator(newType !== null && newType !== void 0 ? newType : this.type, this.id, this.hash, this, (raw, t2) => {
                const got = unwrap(raw);
                if ((0, utils_1.nullIsh)(got)) {
                  return null;
                }
                return this.get(got, t2);
              }, this.opts);
              ret.origin = newOrigin;
              return ret;
            }
            setId(newId) {
              if (this.id === newId) {
                return this;
              }
              return new Evaluator(this.type, newId, this.hash, this, this.val, this.opts);
            }
            get(raw, t2) {
              if (((0, utils_1.nullIsh)(raw) || !t2) && !this.isConstant) {
                throw new Error("Cannot be evaluated as constant");
              }
              if (typeof this.val !== "function") {
                return this.val;
              }
              return this.val(raw, t2);
            }
            canCast(to) {
              return !!this.type.canCast(to);
            }
            cast(to) {
              return this.type.cast(this, to);
            }
            convertImplicit(to) {
              return this.type.convertImplicit(this, to);
            }
            explain(e) {
              var _a;
              if (!this.origin) {
                return {
                  constant: true
                };
              }
              return {
                on: e.idFor(this.origin),
                col: (_a = this.id) !== null && _a !== void 0 ? _a : "<complex expression>"
              };
            }
          }
          exports2.Evaluator = Evaluator;
          exports2.Value = {
            null(ofType) {
              return new Evaluator(ofType !== null && ofType !== void 0 ? ofType : datatypes_1.Types.null, null, "null", null, null, void 0);
            },
            text(value2, length = null) {
              return new Evaluator(datatypes_1.Types.text(length), null, value2, null, value2);
            },
            number(value2, type = datatypes_1.Types.float) {
              return new Evaluator(type, null, value2.toString(10), null, value2);
            },
            function(value2, args) {
              return (0, function_call_1.buildCall)(value2, args);
            },
            bool(value2) {
              const str = value2 ? "true" : "false";
              return new Evaluator(datatypes_1.Types.bool, null, str, null, value2);
            },
            /** @deprecated Use with care */
            constant(_type, value2) {
              const type = (0, utils_1.nullIsh)(value2) ? datatypes_1.Types.null : _type;
              return new Evaluator(type, null, null, null, value2);
            },
            /** @deprecated Use with care */
            converter(type, to) {
              let last3 = null;
              const evaluator = new Evaluator(type, null, null, null, () => last3, { forceNotConstant: true }).cast(to);
              return (val, t2) => {
                if ((0, utils_1.nullIsh)(val)) {
                  return null;
                }
                last3 = val;
                const ret = evaluator.get(val, t2);
                last3 = null;
                return ret;
              };
            },
            in(value2, array, inclusive) {
              if (!value2) {
                throw new Error("Argument null");
              }
              if (array.type.primary !== interfaces_1.DataType.list && array.type) {
                array = exports2.Value.list([array]);
              }
              const of = array.type.of;
              const type = (0, datatypes_1.reconciliateTypes)([value2, exports2.Value.null(of)]);
              value2 = value2.cast(type);
              array = array.cast(type.asArray());
              return new Evaluator(datatypes_1.Types.bool, null, (0, object_hash_1.default)({ val: value2.hash, in: array.hash }), [value2, array], (raw, t2) => {
                const rawValue = value2.get(raw, t2);
                const rawArray = array.get(raw, t2);
                if (!Array.isArray(rawArray)) {
                  return false;
                }
                const has5 = rawArray.some((x) => of.equals(rawValue, x));
                return inclusive ? has5 : !has5;
              });
            },
            isNull(leftValue, expectNull) {
              return new Evaluator(datatypes_1.Types.bool, null, (0, object_hash_1.default)({ isNull: leftValue.hash, expectNull }), leftValue, (raw, t2) => {
                const left = leftValue.get(raw, t2);
                const ret = (0, utils_1.nullIsh)(left);
                return expectNull ? ret : !ret;
              });
            },
            isTrue(leftValue, expectTrue) {
              leftValue = leftValue.cast(datatypes_1.Types.bool);
              return new Evaluator(datatypes_1.Types.bool, null, (0, object_hash_1.default)({ isTrue: leftValue.hash, expectTrue }), leftValue, expectTrue ? (raw, t2) => {
                const left = leftValue.get(raw, t2);
                return left === true;
              } : (raw, t2) => {
                const left = leftValue.get(raw, t2);
                return !(left === true);
              });
            },
            isFalse(leftValue, expectFalse) {
              leftValue = leftValue.cast(datatypes_1.Types.bool);
              return new Evaluator(datatypes_1.Types.bool, null, (0, object_hash_1.default)({ isFalse: leftValue.hash, expectFalse }), leftValue, expectFalse ? (raw, t2) => {
                const left = leftValue.get(raw, t2);
                return left === false;
              } : (raw, t2) => {
                const left = leftValue.get(raw, t2);
                return !(left === false);
              });
            },
            negate(value2) {
              if (value2.type === datatypes_1.Types.bool) {
                return value2.setConversion((x) => !x, (x) => ({ not: x }));
              }
              if (!(0, datatypes_1.isNumeric)(value2.type)) {
                throw new interfaces_1.QueryError('Can only apply "-" unary operator to numeric types');
              }
              return value2.setConversion((x) => -x, (x) => ({ neg: x }));
            },
            array(values2) {
              return arrayOrList(values2, false);
            },
            list(values2) {
              return arrayOrList(values2, true);
            }
          };
          function arrayOrList(values2, list) {
            const type = values2.reduce((t2, v) => {
              if (v.canCast(t2)) {
                return t2;
              }
              if (!t2.canCast(v.type)) {
                throw new interfaces_1.CastError(t2.primary, v.type.primary);
              }
              return v.type;
            }, datatypes_1.Types.null);
            const converted = values2.map((x) => x.cast(type));
            return new Evaluator(list ? type.asList() : type.asArray(), null, (0, object_hash_1.default)(converted.map((x) => x.hash)), converted, (raw, t2) => {
              const arr = values2.map((x) => x.get(raw, t2));
              return arr;
            });
          }
          function buildParameterList(statementName, args) {
            return args.map(({ type, name }, i) => {
              const value2 = new Evaluator(type, name, (0, object_hash_1.default)({ param: name }), null, () => {
                var _a;
                const { parametersValues } = (0, utils_1.executionCtx)();
                if (!parametersValues || parametersValues.length <= i) {
                  throw new interfaces_1.QueryError(`bind message supplies ${(_a = parametersValues === null || parametersValues === void 0 ? void 0 : parametersValues.length) !== null && _a !== void 0 ? _a : 0} parameters, but prepared statement "${statementName}" requires ${args.length}`, "08P01");
                }
                return parametersValues[i];
              }, {
                forceNotConstant: true
              });
              return { value: value2, index: i };
            });
          }
          exports2.buildParameterList = buildParameterList;
        },
        /* 12 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TYPE_SYMBOL = exports2.SelectExec = exports2.buildWith = exports2.buildSelect = exports2.buildValues = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const deletion_1 = __webpack_require__(58);
          const update_1 = __webpack_require__(59);
          const insert_1 = __webpack_require__(60);
          const values_table_1 = __webpack_require__(61);
          const utils_1 = __webpack_require__(1);
          const join_1 = __webpack_require__(24);
          const clean_results_1 = __webpack_require__(18);
          const mutation_base_1 = __webpack_require__(20);
          const exec_utils_1 = __webpack_require__(7);
          const context_1 = __webpack_require__(4);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const t_record_1 = __webpack_require__(19);
          const function_call_table_1 = __webpack_require__(62);
          function buildValues(p, acceptDefault) {
            const ret = new values_table_1.ValuesTable("", p.values, null, acceptDefault);
            return ret.selection;
          }
          exports2.buildValues = buildValues;
          function buildWithable(p) {
            switch (p.type) {
              case "select":
              case "union":
              case "union all":
              case "with":
              case "with recursive":
              case "values":
                return buildSelect(p);
              case "delete":
                return new deletion_1.Deletion(p);
              case "update":
                return new update_1.Update(p);
              case "insert":
                return new insert_1.Insert(p);
              default:
                throw interfaces_private_1.NotSupported.never(p);
            }
          }
          function buildSelect(p) {
            switch (p.type) {
              case "union":
              case "union all":
                return buildUnion(p);
              case "with":
                return buildWith(p, false);
              case "select":
                return buildRawSelect(p);
              case "values":
                return buildValues(p);
              case "with recursive":
                throw new interfaces_private_1.NotSupported("recursirve with statements not implemented by pg-mem");
              default:
                throw interfaces_private_1.NotSupported.never(p);
            }
          }
          exports2.buildSelect = buildSelect;
          function buildUnion(p) {
            const left = buildSelect(p.left);
            const right = buildSelect(p.right);
            const ret = left.union(right);
            if (p.type === "union all") {
              return ret;
            }
            return ret.distinct();
          }
          function buildWith(p, topLevel) {
            return (0, context_1.withBindingScope)(() => {
              const { setTempBinding } = (0, context_1.buildCtx)();
              for (const { alias, statement } of p.bind) {
                const prepared = (topLevel ? buildWithable(statement) : buildSelect(checkReadonlyWithable(statement))).setAlias(alias.name);
                setTempBinding(alias.name, prepared);
              }
              return buildSelect(checkReadonlyWithable(p.in));
            });
          }
          exports2.buildWith = buildWith;
          function buildRawSelectSubject(p) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
            let sel = void 0;
            for (const from of (_a = p.from) !== null && _a !== void 0 ? _a : []) {
              let newT;
              switch (from.type) {
                case "table":
                  newT = getSelectable(from.name);
                  break;
                case "statement":
                  newT = mapColumns(from.alias, buildSelect(from.statement), from.columnNames, true).setAlias(from.alias);
                  break;
                case "call":
                  const fnName = (_c = (_b = from.alias) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : (_d = from.function) === null || _d === void 0 ? void 0 : _d.name;
                  const fromValue = (0, expression_builder_1.buildValue)(from);
                  if (datatypes_1.ArrayType.matches(fromValue.type) && t_record_1.RecordType.matches(fromValue.type.of)) {
                    const cols = fromValue.type.of.columns;
                    newT = new function_call_table_1.FunctionCallTable(cols, fromValue);
                  } else {
                    newT = new values_table_1.ValuesTable(fnName, [[from]], [fnName]).setAlias((_g = (_f = (_e = from.alias) === null || _e === void 0 ? void 0 : _e.name) !== null && _f !== void 0 ? _f : (0, utils_1.suggestColumnName)(from)) !== null && _g !== void 0 ? _g : "");
                  }
                  break;
                default:
                  throw interfaces_private_1.NotSupported.never(from);
              }
              if (!sel) {
                sel = newT;
                continue;
              }
              switch ((_h = from.join) === null || _h === void 0 ? void 0 : _h.type) {
                case "INNER JOIN":
                  sel = new join_1.JoinSelection(sel, newT, from.join, true);
                  break;
                case "LEFT JOIN":
                  sel = new join_1.JoinSelection(sel, newT, from.join, false);
                  break;
                case "RIGHT JOIN":
                  sel = new join_1.JoinSelection(newT, sel, from.join, false);
                  break;
                case null:
                case void 0:
                  sel = new join_1.JoinSelection(sel, newT, {
                    type: "INNER JOIN",
                    on: { type: "boolean", value: true }
                  }, true);
                  break;
                default:
                  throw new interfaces_private_1.NotSupported("Join type not supported " + ((_k = (_j = from.join) === null || _j === void 0 ? void 0 : _j.type) !== null && _k !== void 0 ? _k : "<no join specified>"));
              }
            }
            return sel;
          }
          function buildRawSelect(p) {
            var _a, _b, _c;
            const distinct = !p.distinct || p.distinct === "all" ? null : p.distinct;
            (0, utils_1.ignore)(p.for);
            let sel = buildRawSelectSubject(p);
            sel = sel !== null && sel !== void 0 ? sel : (0, context_1.buildCtx)().schema.dualTable.selection;
            sel = sel.filter(p.where);
            const aliases = new Map((0, utils_1.notNil)((_a = p.columns) === null || _a === void 0 ? void 0 : _a.filter((c) => {
              var _a2;
              return !!((_a2 = c.alias) === null || _a2 === void 0 ? void 0 : _a2.name);
            })).map((c) => [c.alias.name, c.expr]));
            const orderBy = (0, utils_1.modifyIfNecessary)((_b = p.orderBy) !== null && _b !== void 0 ? _b : [], (o) => {
              const by = o.by.type === "ref" && !o.by.table && aliases.get(o.by.name);
              return by ? { ...o, by } : null;
            });
            if (p.groupBy) {
              const groupBy2 = (0, utils_1.modifyIfNecessary)((_c = p.groupBy) !== null && _c !== void 0 ? _c : [], (o) => {
                const group = o.type === "ref" && !o.table && !(sel === null || sel === void 0 ? void 0 : sel.getColumn(o.name, true)) && aliases.get(o.name);
                return group || null;
              });
              sel = sel.groupBy(groupBy2);
            }
            sel = sel.orderBy(orderBy);
            if (!p.groupBy && Array.isArray(p.distinct)) {
              sel = sel.distinct(p.distinct);
            }
            sel = sel.select(p.columns);
            if (p.groupBy && Array.isArray(p.distinct)) {
              sel = sel.distinct(p.distinct);
            }
            if (distinct === "distinct") {
              sel = sel.distinct();
            }
            if (p.limit) {
              sel = sel.limit(p.limit);
            }
            return sel;
          }
          function getSelectable(name) {
            const { schema: schema2, getTempBinding } = (0, context_1.buildCtx)();
            const temp = !name.schema && getTempBinding(name.name);
            let ret = temp || (0, interfaces_private_1.asSelectable)(schema2.getObject(name)).selection;
            ret = mapColumns(name.name, ret, name.columnNames, false);
            if (name.alias) {
              ret = ret.setAlias(name.alias);
            }
            return ret;
          }
          function mapColumns(tableName, sel, columnNames, appendNonMapped) {
            if (!(columnNames === null || columnNames === void 0 ? void 0 : columnNames.length)) {
              return sel;
            }
            if (columnNames.length > sel.columns.length) {
              throw new interfaces_private_1.QueryError(`table "${tableName}" has ${sel.columns.length} columns available but ${columnNames.length} columns specified`, "42P10");
            }
            const mapped = new Set(columnNames.map((x) => x.name));
            const cols = sel.columns.map((col, i) => {
              var _a;
              return {
                expr: {
                  type: "ref",
                  name: col.id
                },
                // when realiasing table columns, columns which have not been mapped
                //  must not be removed
                // see ut "can map column names"
                alias: (_a = columnNames[i]) !== null && _a !== void 0 ? _a : {
                  name: mapped.has(sel.columns[i].id) ? `${sel.columns[i].id}1` : sel.columns[i].id
                }
              };
            });
            return sel.select(cols);
          }
          class SelectExec {
            constructor(statement, p) {
              this.statement = statement;
              this.p = p;
              this.selection = p.type === "with" ? buildWith(p, true) : buildWithable(p);
            }
            get schema() {
              return this.statement.schema;
            }
            execute(t2) {
              var _a;
              const rows = (0, clean_results_1.cleanResults)([...this.selection.enumerate(t2)]);
              let unnamedFields = 0;
              const nextDefaultFieldName = () => {
                const unnamedField = `column${unnamedFields || ""}`;
                unnamedFields += 1;
                return unnamedField;
              };
              return {
                result: {
                  rows,
                  rowCount: (_a = t2.getTransient(mutation_base_1.MutationDataSourceBase.affectedRows)) !== null && _a !== void 0 ? _a : rows.length,
                  command: this.p.type.toUpperCase(),
                  fields: this.selection.columns.map((c) => {
                    var _a2;
                    return {
                      name: (_a2 = c.id) !== null && _a2 !== void 0 ? _a2 : nextDefaultFieldName(),
                      type: c.type.primary,
                      [exports2.TYPE_SYMBOL]: c.type
                    };
                  }),
                  location: (0, exec_utils_1.locOf)(this.p)
                },
                state: t2
              };
            }
          }
          exports2.SelectExec = SelectExec;
          exports2.TYPE_SYMBOL = Symbol("type");
          function checkReadonlyWithable(st) {
            switch (st.type) {
              case "delete":
              case "insert":
              case "update":
                throw new interfaces_private_1.NotSupported(`"WITH" nested statement with query type '${st.type}'`);
            }
            return st;
          }
        },
        /* 13 */
        /***/
        function(module3, exports2) {
          module3.exports = require_pgsql_ast_parser();
        },
        /* 14 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.reconciliateTypes = exports2.typeSynonyms = exports2.isGeometric = exports2.isDateType = exports2.dateTypes = exports2.Types = exports2.ArrayType = exports2.isInteger = exports2.isNumeric = exports2.numberPriorities = exports2.numbers = exports2.floats = exports2.integers = exports2.DefaultType = void 0;
          const interfaces_1 = __webpack_require__(3);
          const utils_1 = __webpack_require__(1);
          const evaluator_1 = __webpack_require__(11);
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const pgsql_ast_parser_2 = __webpack_require__(13);
          const buffer_node_1 = __webpack_require__(21);
          const datatype_base_1 = __webpack_require__(9);
          const datatypes_geometric_1 = __webpack_require__(41);
          const t_interval_1 = __webpack_require__(42);
          const t_time_1 = __webpack_require__(43);
          const t_timestamp_1 = __webpack_require__(44);
          const t_jsonb_1 = __webpack_require__(45);
          const t_regtype_1 = __webpack_require__(46);
          const t_regclass_1 = __webpack_require__(47);
          const t_record_1 = __webpack_require__(19);
          const t_inet_1 = __webpack_require__(48);
          const context_1 = __webpack_require__(4);
          class UUIDtype extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.uuid;
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                  return true;
              }
              return null;
            }
            doCast(value2, to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                  return value2;
              }
              throw new Error("Unexpected cast error");
            }
          }
          class NullType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.null;
            }
            doCast(value2, to) {
              return new evaluator_1.Evaluator(to, null, "null", null, null);
            }
            doCanCast(to) {
              return true;
            }
            doCanConvertImplicit() {
              return true;
            }
            doEquals(a, b) {
              return false;
            }
            doGt(a, b) {
              return false;
            }
            doLt(a, b) {
              return false;
            }
            doPrefer(type) {
              return type;
            }
          }
          class DefaultType extends NullType {
          }
          exports2.DefaultType = DefaultType;
          exports2.integers = /* @__PURE__ */ new Set([interfaces_1.DataType.integer, interfaces_1.DataType.bigint]);
          exports2.floats = /* @__PURE__ */ new Set([interfaces_1.DataType.decimal, interfaces_1.DataType.float]);
          exports2.numbers = /* @__PURE__ */ new Set([...exports2.integers, ...exports2.floats]);
          exports2.numberPriorities = [interfaces_1.DataType.integer, interfaces_1.DataType.bigint, interfaces_1.DataType.decimal, interfaces_1.DataType.float].reduce((a, x, i) => ({
            ...a,
            [x]: i
          }), {});
          function isNumeric(t2) {
            const type = typeof t2 === "string" ? t2 : t2.primary;
            return exports2.numbers.has(type);
          }
          exports2.isNumeric = isNumeric;
          function isInteger(t2) {
            const type = typeof t2 === "string" ? t2 : t2.primary;
            return exports2.integers.has(type);
          }
          exports2.isInteger = isInteger;
          class NumberType extends datatype_base_1.TypeBase {
            constructor(primary) {
              super();
              this.primary = primary;
            }
            doCanConvertImplicit(to) {
              switch (to.primary) {
                case interfaces_1.DataType.integer:
                case interfaces_1.DataType.bigint:
                case interfaces_1.DataType.float:
                case interfaces_1.DataType.decimal:
                case interfaces_1.DataType.regtype:
                case interfaces_1.DataType.regclass:
                  return true;
                default:
                  return false;
              }
            }
            doPrefer(type) {
              switch (type.primary) {
                case interfaces_1.DataType.integer:
                case interfaces_1.DataType.bigint:
                  return this;
                case interfaces_1.DataType.float:
                case interfaces_1.DataType.decimal:
                  return type;
              }
              return null;
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_1.DataType.integer:
                case interfaces_1.DataType.bigint:
                case interfaces_1.DataType.float:
                case interfaces_1.DataType.decimal:
                case interfaces_1.DataType.regtype:
                case interfaces_1.DataType.regclass:
                  return true;
                case interfaces_1.DataType.text:
                  return true;
                default:
                  return false;
              }
            }
            doCast(value2, to) {
              if (!exports2.integers.has(value2.type.primary) && exports2.integers.has(to.primary)) {
                return new evaluator_1.Evaluator(to, value2.id, value2.hash, value2, (raw, t2) => {
                  const got = value2.get(raw, t2);
                  return typeof got === "number" ? Math.round(got) : got;
                });
              }
              const { schema: schema2 } = (0, context_1.buildCtx)();
              switch (to.primary) {
                case interfaces_1.DataType.regtype:
                  return value2.setType(exports2.Types.regtype).setConversion((int2) => {
                    const got = schema2.getType(int2, { nullIfNotFound: true });
                    if (!got) {
                      throw new interfaces_1.CastError(interfaces_1.DataType.integer, interfaces_1.DataType.regtype);
                    }
                    return got.name;
                  }, (intToRegType) => ({ intToRegType }));
                case interfaces_1.DataType.regclass:
                  return value2.setType(exports2.Types.regclass).setConversion((int2) => {
                    var _a;
                    const obj = schema2.getObjectByRegOrName(int2, { nullIfNotFound: true });
                    return (_a = obj === null || obj === void 0 ? void 0 : obj.reg.classId) !== null && _a !== void 0 ? _a : int2;
                  }, (intToRegClass) => ({ intToRegClass }));
                case interfaces_1.DataType.text:
                  return value2.setType(to).setConversion((int2) => int2.toString(), (toTxt) => ({ toTxt }));
              }
              return value2.setType(to);
            }
          }
          class ByteArrayType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.bytea;
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                  return true;
              }
              return null;
            }
            doCast(value2, to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                  return value2.setConversion((raw) => (0, buffer_node_1.bufToString)(raw), (toStr) => ({ toStr }));
              }
              throw new Error("Unexpected cast error");
            }
            doEquals(a, b) {
              return (0, buffer_node_1.bufCompare)(a, b) === 0;
            }
            doGt(a, b) {
              return (0, buffer_node_1.bufCompare)(a, b) > 0;
            }
            doLt(a, b) {
              return (0, buffer_node_1.bufCompare)(a, b) < 0;
            }
          }
          class TextType extends datatype_base_1.TypeBase {
            constructor(len, citext) {
              super();
              this.len = len;
              this.citext = citext;
            }
            get name() {
              if (this.citext) {
                return "citext";
              }
              return this.len ? "character varying" : "text";
            }
            get primary() {
              return this.citext ? interfaces_1.DataType.citext : interfaces_1.DataType.text;
            }
            doPrefer(to) {
              if (to instanceof TextType) {
                if (!to.len) {
                  return to;
                }
                if (!this.len) {
                  return this;
                }
                return to.len > this.len ? to : this;
              }
              if (this.canCast(to)) {
                return to;
              }
              return null;
            }
            doCanConvertImplicit(to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                case interfaces_1.DataType.bool:
                case interfaces_1.DataType.uuid:
                case interfaces_1.DataType.bytea:
                  return true;
              }
              return false;
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                case interfaces_1.DataType.citext:
                  return true;
                case interfaces_1.DataType.text:
                case interfaces_1.DataType.uuid:
                  return true;
                case interfaces_1.DataType.bool:
                  return true;
                case interfaces_1.DataType.array:
                  return this.canCast(to.of);
                case interfaces_1.DataType.bytea:
                  return true;
              }
              if (exports2.numbers.has(to.primary)) {
                return true;
              }
              if (isGeometric(to.primary)) {
                return true;
              }
              return void 0;
            }
            doCast(value2, to) {
              var _a;
              switch (to.primary) {
                case interfaces_1.DataType.citext:
                  return value2.setType(to);
                case interfaces_1.DataType.bool:
                  return value2.setConversion((rawStr) => {
                    if ((0, utils_1.nullIsh)(rawStr)) {
                      return null;
                    }
                    if (rawStr === "0") {
                      return false;
                    } else if (rawStr === "1") {
                      return true;
                    }
                    const str = rawStr.toLowerCase();
                    if ("true".startsWith(str)) {
                      return true;
                    } else if ("false".startsWith(str)) {
                      return false;
                    }
                    if ("yes".startsWith(str)) {
                      return true;
                    } else if ("no".startsWith(str)) {
                      return false;
                    }
                    throw new interfaces_1.CastError(interfaces_1.DataType.text, interfaces_1.DataType.bool, "string " + rawStr);
                  }, (toBool) => ({ toBool }));
                case interfaces_1.DataType.uuid:
                  return value2.setConversion((_rawStr) => {
                    var _a2;
                    let rawStr = _rawStr;
                    if ((0, utils_1.nullIsh)(rawStr)) {
                      return null;
                    }
                    if (rawStr[0] === "{") {
                      if (rawStr[rawStr.length - 1] !== "}") {
                        throw new interfaces_1.CastError(interfaces_1.DataType.text, interfaces_1.DataType.uuid, "string: " + JSON.stringify(_rawStr));
                      }
                      rawStr = rawStr.substr(1, rawStr.length - 2);
                    }
                    rawStr = rawStr.toLowerCase();
                    const [full, a, b, c, d, e] = (_a2 = /^([0-9a-f]{8})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{4})-?([0-9a-f]{12})$/.exec(rawStr)) !== null && _a2 !== void 0 ? _a2 : [];
                    if (!full) {
                      throw new interfaces_1.CastError(interfaces_1.DataType.text, interfaces_1.DataType.uuid, "string: " + JSON.stringify(_rawStr));
                    }
                    return `${a}-${b}-${c}-${d}-${e}`;
                  }, (toUuid) => ({ toUuid }));
                case interfaces_1.DataType.text:
                  const fromStr = to;
                  const toStr = to;
                  if (toStr.len === null || ((_a = fromStr.len) !== null && _a !== void 0 ? _a : -1) < toStr.len) {
                    return value2;
                  }
                  return value2.setConversion((str) => {
                    if (str && str.length > toStr.len) {
                      throw new interfaces_1.QueryError(`value too long for type character varying(${toStr.len})`);
                    }
                    return str;
                  }, (truncate) => ({ truncate, len: toStr.len }));
                case interfaces_1.DataType.array:
                  return value2.setType(to).setConversion((str) => {
                    const array = (0, pgsql_ast_parser_1.parseArrayLiteral)(str);
                    to.convertLiteral(array);
                    return array;
                  }, (parseArray) => ({ parseArray }));
                case interfaces_1.DataType.bytea:
                  return value2.setConversion((str) => {
                    return (0, buffer_node_1.bufFromString)(str);
                  }, (toBytea) => ({ toBytea }));
              }
              if (exports2.numbers.has(to.primary)) {
                const isInt = exports2.integers.has(to.primary);
                return value2.setConversion((str) => {
                  const val = Number.parseFloat(str);
                  if (!Number.isFinite(val)) {
                    throw new interfaces_1.QueryError(`invalid input syntax for ${to.primary}: ${str}`);
                  }
                  if (isInt && Math.floor(val) !== val) {
                    throw new interfaces_1.QueryError(`invalid input syntax for ${to.primary}: ${str}`);
                  }
                  return val;
                }, (castNum) => ({ castNum, to: to.primary }));
              }
              if (isGeometric(to.primary)) {
                return value2.setConversion((str) => {
                  const ret = (0, pgsql_ast_parser_2.parseGeometricLiteral)(str, to.primary);
                  return ret;
                }, (castGeo) => ({ castGeo, to: to.primary }));
              }
              return void 0;
            }
            doEquals(a, b) {
              if (this.citext) {
                return a.localeCompare(b, void 0, { sensitivity: "accent" }) === 0;
              }
              return super.doEquals(a, b);
            }
          }
          class BoolType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.bool;
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                case interfaces_1.DataType.citext:
                case interfaces_1.DataType.bool:
                case interfaces_1.DataType.integer:
                  return true;
              }
              return false;
            }
            doCast(value2, to) {
              switch (to.primary) {
                case interfaces_1.DataType.text:
                case interfaces_1.DataType.citext:
                  return new evaluator_1.Evaluator(to, value2.id, value2.hash, value2, (raw, t2) => {
                    const got = value2.get(raw, t2);
                    return got ? "true" : "false";
                  });
                case interfaces_1.DataType.bool:
                  return value2;
                case interfaces_1.DataType.integer:
                  return new evaluator_1.Evaluator(to, value2.id, value2.hash, value2, (raw, t2) => {
                    const got = value2.get(raw, t2);
                    return got ? 1 : 0;
                  });
              }
              throw new Error("Unexpected cast error");
            }
          }
          class ArrayType extends datatype_base_1.TypeBase {
            constructor(of, list) {
              super();
              this.of = of;
              this.list = list;
            }
            static matches(type) {
              return type.primary === interfaces_1.DataType.array;
            }
            get primary() {
              if (this.list) {
                return interfaces_1.DataType.list;
              }
              return interfaces_1.DataType.array;
            }
            get name() {
              return this.of.name + "[]";
            }
            doCanCast(to) {
              if (to instanceof ArrayType) {
                return this.of.canCast(to.of);
              }
              return this.of.canCast(to);
            }
            doCast(value2, _to) {
              if (_to instanceof ArrayType) {
                const to = _to;
                const valueType = value2.type;
                return new evaluator_1.Evaluator(to, value2.id, value2.hash, value2, (raw, t2) => {
                  const arr = value2.get(raw, t2);
                  return arr.map((x) => evaluator_1.Value.constant(valueType.of, x).cast(to.of).get(raw, t2));
                });
              }
              if (_to.primary === interfaces_1.DataType.text) {
                return this.toText(_to, value2);
              }
              return this.toSingleColumn(_to, value2);
            }
            toText(to, value2) {
              const valueType = value2.type;
              const converter = evaluator_1.Value.converter(valueType.of, exports2.Types.text());
              return new evaluator_1.Evaluator(to, value2.id, value2.hash, value2, (raw, t2) => {
                const arr = value2.get(raw, t2);
                const strs = arr.map((x) => converter(x, t2));
                const data = strs.join(",");
                return this.list ? "(" + data + ")" : "{" + data + "}";
              }, { forceNotConstant: true });
            }
            toSingleColumn(to, value2) {
              const valueType = value2.type;
              const converter = evaluator_1.Value.converter(valueType.of, to);
              return new evaluator_1.Evaluator(to, value2.id, value2.hash, value2, (raw, t2) => {
                const arr = value2.get(raw, t2);
                return converter(arr[0], t2);
              }, { forceNotConstant: true });
            }
            doEquals(a, b) {
              if (a.length !== b.length) {
                return false;
              }
              for (let i = 0; i < a.length; i++) {
                if (!this.of.equals(a[i], b[i])) {
                  return false;
                }
              }
              return true;
            }
            doGt(a, b) {
              const len = Math.min(a.length, b.length);
              for (let i = 0; i < len; i++) {
                if (this.of.gt(a[i], b[i])) {
                  return true;
                }
              }
              return a.length > b.length;
            }
            doLt(a, b) {
              const len = Math.min(a.length, b.length);
              for (let i = 0; i < len; i++) {
                if (this.of.lt(a[i], b[i])) {
                  return true;
                }
              }
              return a.length < b.length;
            }
            convertLiteral(elts) {
              if ((0, utils_1.nullIsh)(elts)) {
                return;
              }
              if (!Array.isArray(elts)) {
                throw new interfaces_1.QueryError("Array depth mismatch: was expecting an array item.");
              }
              if (this.of instanceof ArrayType) {
                for (let i = 0; i < elts.length; i++) {
                  this.of.convertLiteral(elts[i]);
                }
              } else {
                for (let i = 0; i < elts.length; i++) {
                  if (Array.isArray(elts[i])) {
                    throw new interfaces_1.QueryError("Array depth mismatch: was not expecting an array item.");
                  }
                  elts[i] = evaluator_1.Value.text(elts[i]).cast(this.of).get();
                }
              }
              return elts;
            }
          }
          exports2.ArrayType = ArrayType;
          exports2.Types = {
            [interfaces_1.DataType.record]: (columns) => new t_record_1.RecordType(columns),
            [interfaces_1.DataType.bool]: new BoolType(),
            [interfaces_1.DataType.text]: (len = null) => makeText(len),
            [interfaces_1.DataType.citext]: new TextType(null, true),
            [interfaces_1.DataType.timestamp]: (len = null) => makeTimestamp(interfaces_1.DataType.timestamp, len),
            [interfaces_1.DataType.timestamptz]: (len = null) => makeTimestamp(interfaces_1.DataType.timestamptz, len),
            [interfaces_1.DataType.uuid]: new UUIDtype(),
            [interfaces_1.DataType.date]: new t_timestamp_1.TimestampType(interfaces_1.DataType.date),
            [interfaces_1.DataType.interval]: new t_interval_1.IntervalType(),
            [interfaces_1.DataType.time]: new t_time_1.TimeType(interfaces_1.DataType.time),
            [interfaces_1.DataType.timetz]: new t_time_1.TimeType(interfaces_1.DataType.timetz),
            [interfaces_1.DataType.jsonb]: new t_jsonb_1.JSONBType(interfaces_1.DataType.jsonb),
            [interfaces_1.DataType.regtype]: new t_regtype_1.RegTypeImpl(),
            [interfaces_1.DataType.regclass]: new t_regclass_1.RegClassImpl(),
            [interfaces_1.DataType.json]: new t_jsonb_1.JSONBType(interfaces_1.DataType.json),
            [interfaces_1.DataType.null]: new NullType(),
            [interfaces_1.DataType.float]: new NumberType(interfaces_1.DataType.float),
            [interfaces_1.DataType.integer]: new NumberType(interfaces_1.DataType.integer),
            [interfaces_1.DataType.bigint]: new NumberType(interfaces_1.DataType.bigint),
            [interfaces_1.DataType.bytea]: new ByteArrayType(),
            [interfaces_1.DataType.point]: new datatypes_geometric_1.PointType(),
            [interfaces_1.DataType.line]: new datatypes_geometric_1.LineType(),
            [interfaces_1.DataType.lseg]: new datatypes_geometric_1.LsegType(),
            [interfaces_1.DataType.box]: new datatypes_geometric_1.BoxType(),
            [interfaces_1.DataType.inet]: new t_inet_1.INetType(),
            [interfaces_1.DataType.path]: new datatypes_geometric_1.PathType(),
            [interfaces_1.DataType.polygon]: new datatypes_geometric_1.PolygonType(),
            [interfaces_1.DataType.circle]: new datatypes_geometric_1.CircleType(),
            default: new DefaultType()
          };
          exports2.dateTypes = /* @__PURE__ */ new Set([
            interfaces_1.DataType.timestamp,
            interfaces_1.DataType.timestamptz,
            interfaces_1.DataType.date,
            interfaces_1.DataType.time
          ]);
          function isDateType(_type) {
            const t2 = typeof _type === "string" ? _type : _type.primary;
            return exports2.dateTypes.has(t2);
          }
          exports2.isDateType = isDateType;
          function isGeometric(dt) {
            switch (dt) {
              case interfaces_1.DataType.point:
              case interfaces_1.DataType.line:
              case interfaces_1.DataType.lseg:
              case interfaces_1.DataType.box:
              case interfaces_1.DataType.path:
              case interfaces_1.DataType.polygon:
              case interfaces_1.DataType.circle:
                return true;
            }
            return false;
          }
          exports2.isGeometric = isGeometric;
          const texts = /* @__PURE__ */ new Map();
          function makeText(len = null) {
            len = len !== null && len !== void 0 ? len : null;
            let got = texts.get(len);
            if (!got) {
              texts.set(len, got = new TextType(len));
            }
            return got;
          }
          const timestamps = /* @__PURE__ */ new Map();
          function makeTimestamp(primary, len = null) {
            len = len !== null && len !== void 0 ? len : null;
            const key = primary + "/" + len;
            let got = timestamps.get(key);
            if (!got) {
              timestamps.set(key, got = new t_timestamp_1.TimestampType(primary, len));
            }
            return got;
          }
          exports2.typeSynonyms = {
            "varchar": interfaces_1.DataType.text,
            "char": interfaces_1.DataType.text,
            "character": interfaces_1.DataType.text,
            "character varying": interfaces_1.DataType.text,
            "int": interfaces_1.DataType.integer,
            "int4": interfaces_1.DataType.integer,
            "serial": interfaces_1.DataType.integer,
            "bigserial": interfaces_1.DataType.integer,
            "smallserial": interfaces_1.DataType.integer,
            "smallint": interfaces_1.DataType.integer,
            "bigint": interfaces_1.DataType.integer,
            "oid": interfaces_1.DataType.integer,
            "decimal": interfaces_1.DataType.float,
            "float": interfaces_1.DataType.float,
            "double precision": interfaces_1.DataType.float,
            "numeric": { type: interfaces_1.DataType.float, ignoreConfig: true },
            "real": interfaces_1.DataType.float,
            "money": interfaces_1.DataType.float,
            "timestamp with time zone": interfaces_1.DataType.timestamptz,
            "timestamp without time zone": interfaces_1.DataType.timestamp,
            "boolean": interfaces_1.DataType.bool,
            "time with time zone": interfaces_1.DataType.timetz,
            "time without time zone": interfaces_1.DataType.time
          };
          function reconciliateTypes(values2, nullIfNoMatch) {
            const nonNull = values2.filter((x) => x.type.primary !== interfaces_1.DataType.null);
            if (!nonNull.length) {
              return exports2.Types.text();
            }
            const single = new Set(nonNull.map((v) => v.type.reg.typeId));
            if (single.size === 1) {
              return nonNull[0].type;
            }
            return reconciliateTypesRaw(nonNull, nullIfNoMatch);
          }
          exports2.reconciliateTypes = reconciliateTypes;
          function reconciliateTypesRaw(values2, nullIfNoMatch) {
            const foundType = values2.reduce((final, c) => {
              var _a;
              if (c.type === exports2.Types.null) {
                return final;
              }
              const pref = final.prefer(c.type);
              if (!pref) {
                throw new interfaces_1.CastError(c.type.primary, final.primary, (_a = c.id) !== null && _a !== void 0 ? _a : void 0);
              }
              return pref;
            }, exports2.Types.null);
            for (const x of values2) {
              if (!x.isConstantLiteral && !x.type.canConvertImplicit(foundType)) {
                if (nullIfNoMatch) {
                  return null;
                }
                throw new interfaces_1.CastError(x.type.primary, foundType.primary);
              }
            }
            return foundType;
          }
        },
        /* 15 */
        /***/
        function(module3, exports2) {
          module3.exports = require_object_hash();
        },
        /* 16 */
        /***/
        function(module3, exports2) {
          module3.exports = (init_immutable_es(), __toCommonJS(immutable_es_exports));
        },
        /* 17 */
        /***/
        function(module3, exports2) {
          module3.exports = require_moment();
        },
        /* 18 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.cleanResults = exports2.SELECT_ALL = exports2.IS_PARTIAL_INDEXING = exports2.JSON_NIL = void 0;
          exports2.JSON_NIL = Symbol("null");
          exports2.IS_PARTIAL_INDEXING = Symbol("partial_indexing");
          exports2.SELECT_ALL = Symbol("select *");
          function cleanResults(results) {
            function cleanObj(obj) {
              if (!obj || typeof obj !== "object") {
                return;
              }
              for (const [k, v] of Object.entries(obj)) {
                if (v === exports2.JSON_NIL) {
                  obj[k] = null;
                } else if (Array.isArray(v)) {
                  if (v[exports2.IS_PARTIAL_INDEXING]) {
                    obj[k] = null;
                  } else {
                    for (let i = 0; i < v.length; i++) {
                      if (obj[i] === exports2.JSON_NIL) {
                        obj[i] = null;
                      } else {
                        cleanObj(v);
                      }
                    }
                  }
                } else {
                  cleanObj(v);
                }
              }
            }
            for (let i = 0; i < results.length; i++) {
              const sel = results[i][exports2.SELECT_ALL];
              if (sel) {
                results[i] = sel();
              }
              cleanObj(results[i]);
            }
            return results;
          }
          exports2.cleanResults = cleanResults;
        },
        /* 19 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.RecordType = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatype_base_1 = __webpack_require__(9);
          class RecordType extends datatype_base_1.TypeBase {
            constructor(columns) {
              super();
              this.columns = columns;
            }
            static matches(type) {
              return type.primary === interfaces_private_1.DataType.record;
            }
            get primary() {
              return interfaces_private_1.DataType.record;
            }
            doEquals(a, b) {
              return (0, interfaces_private_1.getId)(a) === (0, interfaces_private_1.getId)(b);
            }
            static from(selection) {
              const recordCols = selection.columns.filter((c) => !!c.id).map((x) => ({ name: x.id, type: x.type }));
              return new RecordType(recordCols);
            }
            /** Build a function that will transform a record of this type to a record of the target type  */
            transformItemFrom(source) {
              if (source.columns.length !== this.columns.length) {
                return null;
              }
              const setters = [];
              for (let i = 0; i < this.columns.length; i++) {
                const to = this.columns[i];
                const from = source.columns[i];
                if (!from.type.canConvertImplicit(to.type)) {
                  return null;
                }
                const casted = from.cast(to.type);
                setters.push((old, neu, t2) => neu[to.name] = casted.get(old, t2));
              }
              return (raw, t2, execId) => {
                const ret = {};
                (0, interfaces_private_1.setId)(ret, execId + (0, interfaces_private_1.getId)(raw));
                for (const s of setters) {
                  s(raw, ret, t2);
                }
                return ret;
              };
            }
            doCanCast(to) {
              return to instanceof RecordType && !to.columns.length;
            }
            doCast(value2, to) {
              return value2;
            }
          }
          exports2.RecordType = RecordType;
        },
        /* 20 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.createSetter = exports2.MutationDataSourceBase = void 0;
          const transform_base_1 = __webpack_require__(5);
          const array_filter_1 = __webpack_require__(29);
          const clean_results_1 = __webpack_require__(18);
          const interfaces_private_1 = __webpack_require__(0);
          const selection_1 = __webpack_require__(10);
          const expression_builder_1 = __webpack_require__(6);
          const context_1 = __webpack_require__(4);
          const utils_1 = __webpack_require__(1);
          class MutationDataSourceBase extends transform_base_1.DataSourceBase {
            constructor(table, mutatedSel, p) {
              super(table.ownerSchema);
              this.table = table;
              this.mutatedSel = mutatedSel;
              this.mutationResult = Symbol("mutationResult");
              if (p.returning) {
                this.returningRows = new array_filter_1.ArrayFilter(this.mutatedSel, []);
                this.returning = (0, selection_1.buildSelection)(this.returningRows, p.returning);
              }
              const { onFinishExecution } = (0, context_1.buildCtx)();
              onFinishExecution((t2) => {
                this._doExecuteOnce(t2);
              });
            }
            get isExecutionWithNoResult() {
              return !this.returning;
            }
            isAggregation() {
              return false;
            }
            get columns() {
              var _a, _b;
              return (_b = (_a = this.returning) === null || _a === void 0 ? void 0 : _a.columns) !== null && _b !== void 0 ? _b : [];
            }
            _doExecuteOnce(t2) {
              let affected = t2.getTransient(this.mutationResult);
              if (!affected) {
                affected = this.performMutation(t2);
                t2.setTransient(this.mutationResult, affected);
              }
              t2.setTransient(MutationDataSourceBase.affectedRows, affected.length);
              return affected;
            }
            *enumerate(t2) {
              const affected = this._doExecuteOnce(t2);
              if (!this.returning) {
                return;
              }
              try {
                (0, clean_results_1.cleanResults)(affected);
                this.returningRows.rows = affected;
                yield* this.returning.enumerate(t2);
              } finally {
                this.returningRows.rows = [];
              }
            }
            entropy(t2) {
              return 0;
            }
            getColumn(column, nullIfNotFound) {
              if (!this.returning) {
                throw new Error(`Cannot get column "${(0, utils_1.colToStr)(column)}" from a mutation that has no returning statement`);
              }
              return this.returning.getColumn(column, nullIfNotFound);
            }
            hasItem(value2, t2) {
              throw new Error("To fix: Joins cannot call hasItem on a mutation");
            }
            getIndex(forValue) {
              return null;
            }
            explain(e) {
              throw new Error("not implemented");
            }
            isOriginOf(a) {
              return !!this.returning && a.origin === this.returning;
            }
            stats(t2) {
              return null;
            }
          }
          exports2.MutationDataSourceBase = MutationDataSourceBase;
          MutationDataSourceBase.affectedRows = Symbol("affectedRows");
          function createSetter(setTable, setSelection, _sets) {
            return (0, context_1.withSelection)(setSelection, () => {
              const alreadySet = /* @__PURE__ */ new Set();
              const sets = _sets.map((x) => {
                const col = setTable.getColumnRef(x.column.name);
                if (alreadySet.has(col)) {
                  throw new interfaces_private_1.QueryError(` multiple assignments to same column "${col.name}"`, "42601");
                }
                alreadySet.add(col);
                return {
                  col,
                  value: x.value,
                  getter: x.value.type !== "default" ? (0, expression_builder_1.buildValue)(x.value).cast(col.expression.type) : null
                };
              });
              return (t2, target, source) => {
                var _a, _b, _c, _d;
                for (const s of sets) {
                  if (s.value.type === "default") {
                    target[s.col.expression.id] = (_b = (_a = s.col.default) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : void 0;
                  } else {
                    target[s.col.expression.id] = (_d = (_c = s.getter) === null || _c === void 0 ? void 0 : _c.get(source, t2)) !== null && _d !== void 0 ? _d : null;
                  }
                }
              };
            });
          }
          exports2.createSetter = createSetter;
        },
        /* 21 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.bufClone = exports2.isBuf = exports2.bufFromString = exports2.bufCompare = exports2.bufToString = void 0;
          function bufToString(buf) {
            return buf === null || buf === void 0 ? void 0 : buf.toString("utf-8");
          }
          exports2.bufToString = bufToString;
          function bufCompare(a, b) {
            return Buffer.compare(a, b);
          }
          exports2.bufCompare = bufCompare;
          function bufFromString(str) {
            return Buffer.from(str);
          }
          exports2.bufFromString = bufFromString;
          function isBuf(v) {
            return Buffer.isBuffer(v);
          }
          exports2.isBuf = isBuf;
          function bufClone(buf) {
            const bufcopy = Buffer.alloc(buf.length);
            buf.copy(bufcopy);
            return bufcopy;
          }
          exports2.bufClone = bufClone;
        },
        /* 22 */
        /***/
        function(module3, exports2) {
          module3.exports = require_lru_cache();
        },
        /* 23 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Aggregation = exports2.getAggregator = exports2.buildGroupBy = exports2.aggregationFunctions = void 0;
          const transform_base_1 = __webpack_require__(5);
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const interfaces_1 = __webpack_require__(3);
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const evaluator_1 = __webpack_require__(11);
          const count_1 = __webpack_require__(51);
          const max_min_1 = __webpack_require__(52);
          const sum_1 = __webpack_require__(53);
          const array_agg_1 = __webpack_require__(54);
          const avg_1 = __webpack_require__(55);
          const selection_1 = __webpack_require__(10);
          const context_1 = __webpack_require__(4);
          const json_aggs_1 = __webpack_require__(56);
          const utils_1 = __webpack_require__(1);
          const bool_aggregs_1 = __webpack_require__(57);
          exports2.aggregationFunctions = /* @__PURE__ */ new Set([
            "array_agg",
            "avg",
            "bit_and",
            "bit_or",
            "bool_and",
            "bool_or",
            "count",
            "every",
            "json_agg",
            "jsonb_agg",
            "json_object_agg",
            "jsonb_object_agg",
            "max",
            "min",
            "string_agg",
            "sum",
            "xmlagg"
          ]);
          function buildGroupBy(on, groupBy2) {
            const agg = new Aggregation(on, groupBy2);
            return agg;
          }
          exports2.buildGroupBy = buildGroupBy;
          let idCnt = 0;
          function getAggregator() {
            const on = (0, context_1.buildCtx)().selection;
            if (!on) {
              return null;
            }
            if (on.isAggregation()) {
              return on;
            }
            if (!(on instanceof selection_1.Selection)) {
              return null;
            }
            if (!on.base.isAggregation()) {
              return null;
            }
            return on.base;
          }
          exports2.getAggregator = getAggregator;
          function isIntegralType(value2) {
            return typeof value2 === "number" || typeof value2 === "string" || value2 instanceof Date;
          }
          class Aggregation extends transform_base_1.TransformBase {
            constructor(on, _groupedBy) {
              super(on);
              this.symbol = Symbol();
              this.aggId = idCnt++;
              this.aggregations = /* @__PURE__ */ new Map();
              this.groupByMapping = /* @__PURE__ */ new Map();
              this.groupingValuesOnbase = (0, context_1.withSelection)(on, () => _groupedBy.map((x) => (0, expression_builder_1.buildValue)(x)));
              for (let _i = 0; _i < this.groupingValuesOnbase.length; _i++) {
                const i = _i;
                const g = this.groupingValuesOnbase[i];
                this.groupByMapping.set(g.hash, new evaluator_1.Evaluator(
                  g.type,
                  g.id,
                  g.hash,
                  [g],
                  (v) => v[this.symbol][i]
                ));
              }
              this.groupIndex = on.getIndex(...this.groupingValuesOnbase);
              this.columns = [];
            }
            isAggregation() {
              return true;
            }
            getColumn(column, nullIfNotFound) {
              return this.base.getColumn(column, nullIfNotFound);
            }
            checkIfIsKey(got) {
              var _a;
              return (_a = this.groupByMapping.get(got.hash)) !== null && _a !== void 0 ? _a : got;
            }
            entropy(t2) {
              return this.groupByMapping.size || 1;
            }
            stats() {
              return null;
            }
            *enumerate(t2) {
              for (const item of this._enumerateAggregationKeys(t2)) {
                const sym = item[this.symbol];
                (0, interfaces_private_1.setId)(item, `agg_${this.aggId}_${(0, object_hash_1.default)(sym)}`);
                yield item;
              }
            }
            _enumerateAggregationKeys(t2) {
              const ret = this.computeDirect(t2);
              if (ret) {
                return [ret];
              }
              const fromIndex = this.iterateFromIndex(t2);
              if (fromIndex) {
                return fromIndex;
              }
              return this.seqScan(t2);
            }
            iterateFromIndex(t2) {
              var _a, _b;
              if (!this.groupIndex) {
                return null;
              }
              const aggs = [...this.aggregations.values()];
              const allByGroup = !aggs.some((x) => !x.computer.computeFromIndex);
              if (!allByGroup) {
                return null;
              }
              const indexKeys = this.groupIndex.iterateKeys(t2);
              if (!indexKeys) {
                return null;
              }
              const computed = [];
              for (const k of indexKeys) {
                const ret = { [this.symbol]: k };
                for (const agg of aggs) {
                  const val = (_b = (_a = agg.computer).computeFromIndex) === null || _b === void 0 ? void 0 : _b.call(_a, k, this.groupIndex, t2);
                  if (typeof val === "undefined") {
                    if (computed.length) {
                      throw new Error("Compute from index has succeeded on an index key, but failed on another (which must not happen)");
                    }
                    return null;
                  }
                  ret[agg.id] = val;
                }
                computed.push(ret);
              }
              return computed;
            }
            *seqScan(t2) {
              var _a;
              const aggs = [...this.aggregations.values()];
              const groups = /* @__PURE__ */ new Map();
              for (const item of this.base.enumerate(t2)) {
                const key = this.groupingValuesOnbase.map((g) => g.get(item, t2));
                const groupingKey = (0, object_hash_1.default)(key);
                let group = groups.get(groupingKey);
                if (!group) {
                  groups.set(groupingKey, group = {
                    key,
                    aggs: aggs.map((x) => ({
                      computer: x.computer.createGroup(t2),
                      instance: x,
                      distinctHash: /* @__PURE__ */ new Set()
                    }))
                  });
                }
                for (const g of group.aggs) {
                  if (!g.computer) {
                    continue;
                  }
                  if (g.instance.distinct) {
                    const distinctValues = g.instance.distinct.map((x) => x.get(item, t2));
                    if (distinctValues.length === 1 && (0, utils_1.nullIsh)(distinctValues[0])) {
                      continue;
                    }
                    let valuesHash;
                    if (distinctValues.length === 1 && isIntegralType(distinctValues[0])) {
                      valuesHash = distinctValues[0];
                    } else {
                      valuesHash = (0, object_hash_1.default)(distinctValues);
                    }
                    if (g.distinctHash.has(valuesHash)) {
                      continue;
                    }
                    g.distinctHash.add(valuesHash);
                  }
                  g.computer.feedItem(item);
                }
              }
              if (groups.size === 0 && !this.groupingValuesOnbase.length) {
                const key = [];
                const groupingKey = (0, object_hash_1.default)(key);
                groups.set(groupingKey, {
                  key,
                  aggs: aggs.map((x) => ({
                    computer: x.computer.createGroup(t2),
                    instance: x,
                    distinctHash: /* @__PURE__ */ new Set()
                  }))
                });
              }
              for (const g of groups.values()) {
                const ret = {
                  // specify the grouping key
                  [this.symbol]: g.key
                };
                for (const { instance: { id }, computer } of g.aggs) {
                  ret[id] = (_a = computer.finish()) !== null && _a !== void 0 ? _a : null;
                }
                yield ret;
              }
            }
            computeDirect(t2) {
              var _a, _b;
              if (this.groupByMapping.size) {
                return null;
              }
              const aggs = [...this.aggregations.values()];
              const allNoGroup = !aggs.some((x) => !x.computer.computeNoGroup);
              if (!allNoGroup) {
                return null;
              }
              const ret = {
                [this.symbol]: []
              };
              for (const agg of this.aggregations.values()) {
                const val = (_b = (_a = agg.computer).computeNoGroup) === null || _b === void 0 ? void 0 : _b.call(_a, t2);
                if (typeof val === "undefined") {
                  return null;
                }
                ret[agg.id] = val;
              }
              return ret;
            }
            getAggregation(name, call) {
              const hashed = (0, object_hash_1.default)(call);
              const agg = this.aggregations.get(hashed);
              if (agg) {
                return agg.getter;
              }
              const got = this._getAggregation(name, call);
              const id = Symbol(name);
              const getter = new evaluator_1.Evaluator(got.type, null, hashed, [], (raw) => raw[id], {
                forceNotConstant: true
              });
              let distinct = null;
              if (call.distinct === "distinct") {
                if (call.args.length === 1 && call.args[0].type === "list") {
                  distinct = call.args[0].expressions.map((x) => (0, expression_builder_1.buildValue)(x));
                } else {
                  distinct = call.args.map((x) => (0, expression_builder_1.buildValue)(x));
                }
              }
              this.aggregations.set(hashed, {
                id,
                getter,
                computer: got,
                distinct
              });
              return getter;
            }
            _getAggregation(name, call) {
              switch (name) {
                case "count":
                  return (0, count_1.buildCount)(this.base, call);
                case "max":
                case "min":
                  return (0, max_min_1.buildMinMax)(this.base, call.args, name);
                case "sum":
                  return (0, sum_1.buildSum)(this.base, call);
                case "array_agg":
                  return (0, array_agg_1.buildArrayAgg)(this.base, call);
                case "avg":
                  return (0, avg_1.buildAvg)(this.base, call);
                case "jsonb_agg":
                case "json_agg":
                  return (0, json_aggs_1.buildJsonAgg)(this.base, call, name);
                case "bool_and":
                case "bool_or":
                  return (0, bool_aggregs_1.buildBoolAgg)(this.base, call, name);
                default:
                  throw new interfaces_1.NotSupported("aggregation function " + name);
              }
            }
            hasItem(value2, t2) {
              return !!value2[this.symbol];
            }
            getIndex(forValue) {
              return null;
            }
            explain(e) {
              return {
                _: "aggregate",
                id: e.idFor(this),
                aggregator: null
              };
            }
          }
          exports2.Aggregation = Aggregation;
        },
        /* 24 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.JoinIndex = exports2.JoinSelection = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const interfaces_1 = __webpack_require__(3);
          const transform_base_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(2);
          const clean_results_1 = __webpack_require__(18);
          const selection_1 = __webpack_require__(10);
          const context_1 = __webpack_require__(4);
          let jCnt = 0;
          function* extractAnds(on) {
            if (on.type === "binary" && on.op === "AND") {
              yield* extractAnds(on.left);
              yield* extractAnds(on.right);
              return;
            }
            yield on;
          }
          function chooseStrategy(t2, strategies) {
            strategies.sort((a, b) => a.iterate.entropy(t2) > b.iterate.entropy(t2) ? 1 : -1);
            return strategies[0];
          }
          class JoinSelection extends transform_base_1.DataSourceBase {
            constructor(restrictive, joined, on, innerJoin) {
              super((0, context_1.buildCtx)().schema);
              this.restrictive = restrictive;
              this.joined = joined;
              this.innerJoin = innerJoin;
              this._columns = [];
              this.columnsMappingParentToThis = /* @__PURE__ */ new Map();
              this.indexOnRestrictingTableByValue = /* @__PURE__ */ new Map();
              this.indexCache = /* @__PURE__ */ new Map();
              this.strategies = [];
              this.building = false;
              this.joinId = jCnt++;
              for (const c of this.restrictive.listSelectableIdentities()) {
                const nc = c.setWrapper(this, (x) => x[">restrictive"]);
                this.columnsMappingParentToThis.set(c, nc);
                if (c.type.primary === interfaces_1.DataType.record) {
                  continue;
                }
                this._columns.push(nc);
                if (c.index) {
                  this.indexOnRestrictingTableByValue.set(nc, c.index);
                }
              }
              for (const c of this.joined.listSelectableIdentities()) {
                const nc = c.setWrapper(this, (x) => x[">joined"]);
                this.columnsMappingParentToThis.set(c, nc);
                if (c.type.primary === interfaces_1.DataType.record) {
                  continue;
                }
                this._columns.push(nc);
              }
              (0, context_1.withSelection)(this, () => {
                var _a;
                if (on.on) {
                  this.fetchOnStrategies(on.on);
                } else if ((_a = on.using) === null || _a === void 0 ? void 0 : _a.length) {
                  this.fetchUsingStrategies(on.using);
                } else {
                  throw new Error("Unspecified join ON clause");
                }
              });
            }
            get isExecutionWithNoResult() {
              return false;
            }
            isOriginOf(a) {
              return this.joined.isOriginOf(a) || this.restrictive.isOriginOf(a);
            }
            get columns() {
              return this._columns;
            }
            entropy(t2) {
              const strategy = chooseStrategy(t2, this.strategies);
              if (!strategy) {
                return this.restrictive.entropy(t2) * this.joined.entropy(t2);
              }
              const ret = strategy.iterate.entropy(t2);
              return ret;
            }
            wrap(v) {
              const ret = this.columnsMappingParentToThis.get(v);
              if (!ret) {
                throw new Error("Corrupted join (unknown column)");
              }
              return ret;
            }
            listSelectableIdentities() {
              return this.columnsMappingParentToThis.values();
            }
            fetchOnStrategies(_on) {
              const ands = [];
              const others = [];
              for (const on of extractAnds(_on)) {
                if (on.type !== "binary" || on.op !== "=") {
                  others.push((0, expression_builder_1.buildValue)(on));
                  continue;
                }
                this.building = true;
                const left = (0, expression_builder_1.buildValue)(on.left);
                const right = (0, expression_builder_1.buildValue)(on.right);
                this.building = false;
                (0, expression_builder_1.uncache)(this);
                ands.push({
                  left,
                  right,
                  eq: (0, expression_builder_1.buildValue)(on)
                });
              }
              this.fetchAndStrategies(ands, others);
              this.seqScanExpression = (0, expression_builder_1.buildValue)(_on).cast(datatypes_1.Types.bool);
            }
            fetchUsingStrategies(_using) {
              const ands = _using.map((n) => {
                const left = this.restrictive.getColumn(n.name);
                const right = this.joined.getColumn(n.name);
                return {
                  left,
                  right,
                  eq: (0, expression_builder_1.buildBinaryValue)(this.wrap(left), "=", this.wrap(right))
                };
              });
              this.ignoreDupes = new Set(ands.map((x) => this.wrap(x.left)));
              this.fetchAndStrategies(ands, []);
              this.seqScanExpression = ands.slice(1).reduce((a, b) => (0, expression_builder_1.buildBinaryValue)(a, "AND", b.eq), ands[0].eq);
            }
            fetchAndStrategies(ands, otherPredicates) {
              for (let i = 0; i < ands.length; i++) {
                const { left, right } = ands[i];
                const strats = [...this.fetchEqStrategyOn(left, right)];
                if (!strats.length) {
                  continue;
                }
                const others = [
                  ...ands.slice(0, i).map((x) => x.eq),
                  ...ands.slice(i + 1).map((x) => x.eq),
                  ...otherPredicates
                ];
                if (others.length) {
                  const and = others.slice(1).reduce((v, c) => (0, expression_builder_1.buildBinaryValue)(c, "AND", v), others[0]);
                  for (const s of strats) {
                    s.othersPredicate = and;
                  }
                }
                this.strategies.push(...strats);
              }
            }
            *fetchEqStrategyOn(a, b) {
              let restrictedVal = void 0;
              let joinedVal = void 0;
              if (this.restrictive.isOriginOf(a) && this.joined.isOriginOf(b)) {
                restrictedVal = a;
                joinedVal = b;
              } else if (this.restrictive.isOriginOf(b) && this.joined.isOriginOf(a)) {
                restrictedVal = b;
                joinedVal = a;
              }
              let processInner = this.innerJoin;
              let iterateSide = "restrictive";
              while (restrictedVal && joinedVal) {
                const jindex = joinedVal.index;
                if (jindex && jindex.expressions.length === 1) {
                  yield {
                    iterate: iterateSide === "restrictive" ? this.restrictive : this.joined,
                    iterateSide,
                    onValue: restrictedVal,
                    joinIndex: jindex
                  };
                }
                if (!processInner) {
                  break;
                }
                processInner = false;
                const t2 = restrictedVal;
                restrictedVal = joinedVal;
                joinedVal = t2;
                iterateSide = "joined";
              }
            }
            getColumn(column, nullIfNotFound) {
              let onLeft = this.restrictive.getColumn(column, true);
              let onRight = this.joined.getColumn(column, true);
              if (!onLeft && !onRight) {
                if (nullIfNotFound) {
                  return null;
                }
                throw new interfaces_1.ColumnNotFound((0, utils_1.colToStr)(column));
              }
              if (!!onLeft && !!onRight) {
                throw new interfaces_1.QueryError(`column reference "${(0, utils_1.colToStr)(column)}" is ambiguous`);
              }
              const on = onLeft !== null && onLeft !== void 0 ? onLeft : onRight;
              if (this.building) {
                return on;
              }
              const mapped = this.columnsMappingParentToThis.get(on);
              if (mapped) {
                return mapped;
              }
              throw new Error("Corrupted join");
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              const strategy = chooseStrategy(t2, this.strategies);
              if (strategy) {
                for (const l of strategy.iterate.enumerate(t2)) {
                  yield* this.iterateStrategyItem(l, strategy, t2);
                }
              } else {
                this.db.raiseGlobal("catastrophic-join-optimization");
                const others = [...this.joined.enumerate(t2)];
                for (const l of this.restrictive.enumerate(t2)) {
                  yield* this.iterateCatastrophicItem(l, others, "restrictive", t2);
                }
              }
            }
            selectAlias(alias) {
              let onLeft = this.restrictive.selectAlias(alias);
              let onRight = this.joined.selectAlias(alias);
              if (!onLeft && !onRight) {
                return null;
              }
              if (!!onLeft && !!onRight) {
                throw new interfaces_1.QueryError(`alias "${alias}" is ambiguous`);
              }
              return new JoinMapAlias(this, onLeft !== null && onLeft !== void 0 ? onLeft : onRight, onLeft ? ">restrictive" : ">joined");
            }
            *iterateCatastrophicItem(item, others, side, t2) {
              const { template, buildItem } = this.builder(item, side);
              let yielded = false;
              for (const cr of others) {
                const combined = buildItem(cr);
                const result = this.seqScanExpression.get(combined, t2);
                if (result) {
                  yielded = true;
                  yield combined;
                }
              }
              if (!this.innerJoin && !yielded) {
                yield template;
              }
            }
            builder(item, side) {
              let template;
              let buildItem;
              if (side === "joined") {
                buildItem = (x) => this.buildItem(x, item);
                template = this.buildItem(null, item);
              } else {
                buildItem = (x) => this.buildItem(item, x);
                template = this.buildItem(item, null);
              }
              return { buildItem, template };
            }
            *iterateStrategyItem(item, strategy, t2) {
              const { template, buildItem } = this.builder(item, strategy.iterateSide);
              const joinValue = strategy.onValue.get(item, t2);
              let yielded = false;
              if (!(0, utils_1.nullIsh)(joinValue)) {
                for (const o of strategy.joinIndex.enumerate({
                  type: "eq",
                  key: [joinValue],
                  t: t2
                })) {
                  const item2 = buildItem(o);
                  if (strategy.othersPredicate) {
                    const others = strategy.othersPredicate.get(item2, t2);
                    if (!others) {
                      continue;
                    }
                  }
                  yielded = true;
                  yield item2;
                }
              }
              if (!this.innerJoin && !yielded) {
                yield template;
              }
            }
            buildItem(l, r) {
              const ret = {
                ">joined": r,
                ">restrictive": l,
                [clean_results_1.SELECT_ALL]: () => this.merge(ret)
              };
              (0, interfaces_private_1.setId)(ret, `join${this.joinId}-${(0, interfaces_private_1.getId)(l)}-${(0, interfaces_private_1.getId)(r)}`);
              return ret;
            }
            merge(item) {
              if (!this.mergeSelect) {
                let sel = this.columns.map((val) => ({ val }));
                if (this.ignoreDupes) {
                  sel = sel.filter((t2) => {
                    var _a;
                    return !((_a = this.ignoreDupes) === null || _a === void 0 ? void 0 : _a.has(t2.val));
                  });
                }
                this.mergeSelect = new selection_1.Selection(this, sel);
              }
              const ret = this.mergeSelect.build(item, Symbol("hack"));
              return ret;
            }
            hasItem(value2) {
              throw new interfaces_1.NotSupported("lookups on joins");
            }
            getIndex(forValue) {
              if (this.indexCache.has(forValue)) {
                return this.indexCache.get(forValue);
              }
              const mapped = this.indexOnRestrictingTableByValue.get(forValue);
              if (!mapped) {
                return null;
              }
              const ret = new JoinIndex(this, mapped);
              this.indexCache.set(forValue, ret);
              return ret;
            }
            explain(e) {
              const strategy = chooseStrategy(e.transaction, this.strategies);
              return {
                id: e.idFor(this),
                _: "join",
                restrictive: this.restrictive.explain(e),
                joined: this.joined.explain(e),
                inner: this.innerJoin,
                on: strategy ? {
                  iterate: e.idFor(strategy.iterate),
                  iterateSide: strategy.iterateSide,
                  joinIndex: strategy.joinIndex.explain(e),
                  matches: strategy.onValue.explain(e),
                  ...strategy.othersPredicate ? { filtered: true } : {}
                } : {
                  seqScan: this.seqScanExpression.explain(e)
                }
              };
            }
          }
          exports2.JoinSelection = JoinSelection;
          class JoinMapAlias {
            constructor(owner, target, map2) {
              this.owner = owner;
              this.target = target;
              this.map = map2;
            }
            *listColumns() {
              for (const c of this.target.listColumns()) {
                yield c.setWrapper(this.owner, (x) => x[this.map]);
              }
            }
          }
          class JoinIndex {
            constructor(owner, base) {
              this.owner = owner;
              this.base = base;
            }
            get expressions() {
              return this.base.expressions;
            }
            stats(t2, key) {
              return null;
            }
            iterateKeys() {
              return null;
            }
            entropy(op) {
              const strategy = this.chooseStrategy(op.t);
              if (!strategy) {
                return this.base.entropy(op) * this.owner.joined.entropy(op.t);
              }
              return this.base.entropy(op);
            }
            eqFirst(rawKey, t2) {
              for (const i of this.enumerate({
                type: "eq",
                key: rawKey,
                t: t2
              })) {
                return i;
              }
              return null;
            }
            chooseStrategy(t2) {
              const strats = this.owner.strategies.filter((x) => x.iterateSide === "restrictive");
              if (!strats.length) {
                return null;
              }
              return chooseStrategy(t2, strats);
            }
            *enumerate(op) {
              const strategy = this.chooseStrategy(op.t);
              if (strategy) {
                for (const i of this.base.enumerate(op)) {
                  yield* this.owner.iterateStrategyItem(i, strategy, op.t);
                }
              } else {
                this.owner.db.raiseGlobal("catastrophic-join-optimization");
                const all = [...this.owner.joined.enumerate(op.t)];
                for (const i of this.base.enumerate(op)) {
                  yield* this.owner.iterateCatastrophicItem(i, all, "restrictive", op.t);
                }
              }
            }
            explain(e) {
              var _a, _b;
              const strat = this.chooseStrategy(e.transaction);
              return {
                _: "indexOnJoin",
                index: this.base.explain(e),
                strategy: (_b = (_a = strat === null || strat === void 0 ? void 0 : strat.joinIndex) === null || _a === void 0 ? void 0 : _a.explain(e)) !== null && _b !== void 0 ? _b : "catastrophic"
              };
            }
          }
          exports2.JoinIndex = JoinIndex;
        },
        /* 25 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Alias = exports2.buildAlias = void 0;
          const transform_base_1 = __webpack_require__(5);
          const evaluator_1 = __webpack_require__(11);
          const utils_1 = __webpack_require__(1);
          const interfaces_1 = __webpack_require__(3);
          const t_record_1 = __webpack_require__(19);
          function buildAlias(on, alias) {
            if (!alias) {
              return on;
            }
            if (on instanceof Alias && on.name === alias) {
              return on;
            }
            return new Alias(on, alias);
          }
          exports2.buildAlias = buildAlias;
          class Alias extends transform_base_1.TransformBase {
            constructor(sel, name) {
              super(sel);
              this.name = name;
              this.oldToThis = /* @__PURE__ */ new Map();
              this.thisToOld = /* @__PURE__ */ new Map();
              this._columns = null;
            }
            get isExecutionWithNoResult() {
              return this.base.isExecutionWithNoResult;
            }
            *listSelectableIdentities() {
              this.init();
              yield* super.listSelectableIdentities();
              yield this.asRecord;
            }
            rebuild() {
              this._columns = null;
              this.oldToThis.clear();
              this.thisToOld.clear();
            }
            selectAlias(alias) {
              if (this.name === alias) {
                return this;
              }
              return null;
            }
            listColumns() {
              return this.columns;
            }
            get debugId() {
              return this.base.debugId;
            }
            get columns() {
              this.init();
              return this._columns;
            }
            init() {
              if (this._columns) {
                return;
              }
              this._columns = this.base.columns.map((x) => {
                const ret = x.setOrigin(this);
                this.oldToThis.set(x, ret);
                this.thisToOld.set(ret, x);
                return ret;
              });
              this.asRecord = new evaluator_1.Evaluator(t_record_1.RecordType.from(this), this.name, Math.random().toString(), this._columns, (v) => ({ ...v }), { forceNotConstant: true });
            }
            stats(t2) {
              return this.base.stats(t2);
            }
            enumerate(t2) {
              return this.base.enumerate(t2);
            }
            hasItem(value2, t2) {
              return this.base.hasItem(value2, t2);
            }
            getColumn(column, nullIfNotFound) {
              const col = this._getColumn(column);
              if (col) {
                return col;
              }
              if ((0, utils_1.asSingleName)(column) === this.name) {
                return this.asRecord;
              }
              if (nullIfNotFound) {
                return null;
              }
              throw new interfaces_1.ColumnNotFound((0, utils_1.colToStr)(column));
            }
            _getColumn(column) {
              if (typeof column !== "string" && column.table) {
                if (!column.table.schema && column.table.name !== this.name) {
                  return null;
                }
                column = column.name;
              }
              const got = this.base.getColumn(column, true);
              if (!got) {
                return got;
              }
              this.init();
              const ret = this.oldToThis.get(got);
              if (!ret) {
                throw new Error("Corrupted alias");
              }
              return ret;
            }
            explain(e) {
              return this.base.explain(e);
            }
            getIndex(...forValue) {
              return this.base.getIndex(...forValue.map((v) => {
                var _a;
                return (_a = this.thisToOld.get(v)) !== null && _a !== void 0 ? _a : v;
              }));
            }
          }
          exports2.Alias = Alias;
        },
        /* 26 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.parseSql = exports2.enableStatementLocationTracking = void 0;
          const interfaces_1 = __webpack_require__(3);
          const lru_cache_1 = __importDefault(__webpack_require__(22));
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const utils_1 = __webpack_require__(1);
          const astCache = new lru_cache_1.default({
            max: 1e3
          });
          let locationTracking = false;
          function enableStatementLocationTracking() {
            locationTracking = true;
            astCache.reset();
          }
          exports2.enableStatementLocationTracking = enableStatementLocationTracking;
          function parseSql(sql, entry) {
            const key = !entry && (0, object_hash_1.default)(sql);
            if (!entry) {
              const cached = astCache.get(key);
              if (cached) {
                return cached;
              }
            }
            try {
              let ret = (0, pgsql_ast_parser_1.parse)(sql, {
                entry,
                locationTracking
              });
              if (!entry) {
                astCache.set(key, ret);
              }
              return ret;
            } catch (e) {
              const msg = (0, utils_1.errorMessage)(e);
              if (!/Syntax error/.test(msg)) {
                throw e;
              }
              throw new interfaces_1.QueryError(`\u{1F494} Your query failed to parse.
This is most likely due to a SQL syntax error. However, you might also have hit a bug, or an unimplemented feature of pg-mem.
If this is the case, please file an issue at https://github.com/oguimbal/pg-mem along with a query that reproduces this syntax error.

\u{1F449} Failed query:

    ${sql}

\u{1F480} ${msg}`);
            }
          }
          exports2.parseSql = parseSql;
        },
        /* 27 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TableIndex = void 0;
          const interfaces_1 = __webpack_require__(3);
          class TableIndex {
            constructor(onTable, col) {
              this.onTable = onTable;
              this.col = col;
              this.expressions = [col];
            }
            get hash() {
              throw new Error("not implemented");
            }
            explain(e) {
              throw new Error("not implemented");
            }
            stats(t2, key) {
              return null;
            }
            iterateKeys() {
              return null;
            }
            get indexName() {
              return "index_table_name_name";
            }
            entropy(op) {
              return this.onTable.db.listSchemas().reduce((tot, s) => tot + s.tablesCount(op.t) * 10 * 3, 0);
            }
            add(raw) {
              throw new interfaces_1.PermissionDeniedError("tables");
            }
            eqFirst([key], t2) {
              for (const its of this.onTable.itemsByTable(key, t2)) {
                return its;
              }
            }
            *eq([rawKey], t2) {
              for (const its of this.onTable.itemsByTable(rawKey, t2)) {
                yield its;
              }
            }
            *nin(keys2, t2) {
              const raws = keys2.map((x) => x[0]);
              for (const i of this.onTable.selection.enumerate(t2)) {
                if (raws.includes(i.table_name)) {
                  continue;
                }
                yield i;
              }
            }
            *neq([rawKey], t2) {
              for (const i of this.onTable.selection.enumerate(t2)) {
                if (i.table_name !== rawKey) {
                  yield i;
                }
              }
            }
            *gt(rawKey, t2) {
              for (const i of this.onTable.selection.enumerate(t2)) {
                if (i.table_name > rawKey) {
                  yield i;
                }
              }
            }
            *lt(rawKey, t2) {
              for (const i of this.onTable.selection.enumerate(t2)) {
                if (i.table_name < rawKey) {
                  yield i;
                }
              }
            }
            *ge(rawKey, t2) {
              for (const i of this.onTable.selection.enumerate(t2)) {
                if (i.table_name >= rawKey) {
                  yield i;
                }
              }
            }
            *le(rawKey, t2) {
              for (const i of this.onTable.selection.enumerate(t2)) {
                if (i.table_name <= rawKey) {
                  yield i;
                }
              }
            }
            enumerate(op) {
              switch (op.type) {
                case "eq":
                  return this.eq(op.key, op.t);
                case "neq":
                  return this.neq(op.key, op.t);
                case "ge":
                  return this.ge(op.key, op.t);
                case "le":
                  return this.le(op.key, op.t);
                case "gt":
                  return this.gt(op.key, op.t);
                case "lt":
                  return this.lt(op.key, op.t);
                case "outside":
                  return this.outside(op.lo, op.hi, op.t);
                case "inside":
                  return this.inside(op.lo, op.hi, op.t);
                case "nin":
                  return this.nin(op.keys, op.t);
                default:
                  throw interfaces_1.NotSupported.never(op["type"]);
              }
            }
            *outside(lo, hi, t2) {
              yield* this.lt(lo, t2);
              yield* this.gt(hi, t2);
            }
            *inside(lo, hi, t2) {
              throw new Error("Not implemented");
            }
          }
          exports2.TableIndex = TableIndex;
        },
        /* 28 */
        /***/
        function(module3, exports2) {
          module3.exports = require_json_stable_stringify();
        },
        /* 29 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ArrayFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          class ArrayFilter extends transform_base_1.FilterBase {
            constructor(fromTable, rows) {
              super(fromTable);
              this.rows = rows;
            }
            get index() {
              return null;
            }
            entropy() {
              return this.rows.length;
            }
            hasItem(raw) {
              return this.rows.includes(raw);
            }
            getIndex() {
              return null;
            }
            enumerate() {
              return this.rows;
            }
            stats(t2) {
              return {
                count: this.rows.length
              };
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "constantSet",
                rawArrayLen: this.rows.length
              };
            }
          }
          exports2.ArrayFilter = ArrayFilter;
        },
        /* 30 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.IndexConstraint = void 0;
          class IndexConstraint {
            constructor(name, index, table) {
              this.name = name;
              this.index = index;
              this.table = table;
            }
            uninstall(t2) {
              this.table.dropIndex(t2, this.name);
            }
          }
          exports2.IndexConstraint = IndexConstraint;
        },
        /* 31 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.literal = void 0;
          function literal(val) {
            if (null == val)
              return "NULL";
            if (Array.isArray(val)) {
              var vals = val.map(literal);
              return "(" + vals.join(", ") + ")";
            }
            var backslash = ~val.indexOf("\\");
            var prefix = backslash ? "E" : "";
            val = val.replace(/'/g, "''");
            val = val.replace(/\\/g, "\\\\");
            return prefix + "'" + val + "'";
          }
          exports2.literal = literal;
          ;
        },
        /* 32 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CustomEnumType = void 0;
          const datatype_base_1 = __webpack_require__(9);
          const interfaces_1 = __webpack_require__(3);
          class CustomEnumType extends datatype_base_1.TypeBase {
            constructor(schema2, _name, values2) {
              super();
              this.schema = schema2;
              this._name = _name;
              this.values = values2;
            }
            get primary() {
              return this.name;
            }
            get name() {
              return this._name;
            }
            install() {
              this.schema._registerType(this);
            }
            doCanCast(to) {
              return to.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              return value2;
            }
            prefer(type) {
              return this;
            }
            doCanBuildFrom(from) {
              return from.primary === interfaces_1.DataType.text;
            }
            doBuildFrom(value2, from) {
              return value2.setConversion((raw) => {
                if (!this.values.includes(raw)) {
                  throw new interfaces_1.QueryError(`invalid input value for enum ${this.name}: "${raw}"`);
                }
                return raw;
              }, (conv) => ({ conv, toCenum: this.name }));
            }
            drop(t2) {
              this.schema._unregisterType(this);
            }
          }
          exports2.CustomEnumType = CustomEnumType;
        },
        /* 33 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ExecuteCreateSequence = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const sequence_1 = __webpack_require__(73);
          const exec_utils_1 = __webpack_require__(7);
          class ExecuteCreateSequence extends exec_utils_1.ExecHelper {
            constructor(inSchema, p, acceptTempSequences) {
              super(p);
              this.p = p;
              this.acceptTempSequences = acceptTempSequences;
              const name = p.name;
              this.schema = inSchema.getThisOrSiblingFor(name);
            }
            execute(t2) {
              t2 = t2.fullCommit();
              this.createSeq(t2);
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
            createSeq(t2) {
              const p = this.p;
              const name = p.name;
              let ret = null;
              (0, exec_utils_1.checkExistence)(this.schema, name, p.ifNotExists, () => {
                if (p.temp && !this.acceptTempSequences) {
                  throw new interfaces_private_1.NotSupported("temp sequences");
                }
                ret = new sequence_1.Sequence(name.name, this.schema).alter(t2, p.options);
                this.schema.db.onSchemaChange();
              });
              return ret;
            }
          }
          exports2.ExecuteCreateSequence = ExecuteCreateSequence;
        },
        /* 34 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.StatementExec = exports2.SimpleExecutor = void 0;
          const utils_1 = __webpack_require__(1);
          const interfaces_private_1 = __webpack_require__(0);
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const create_table_1 = __webpack_require__(74);
          const create_sequence_1 = __webpack_require__(33);
          const exec_utils_1 = __webpack_require__(7);
          const create_index_1 = __webpack_require__(75);
          const alter_1 = __webpack_require__(76);
          const alter_sequence_1 = __webpack_require__(77);
          const drop_index_1 = __webpack_require__(78);
          const drop_table_1 = __webpack_require__(79);
          const drop_sequence_1 = __webpack_require__(80);
          const transaction_statements_1 = __webpack_require__(81);
          const truncate_table_1 = __webpack_require__(82);
          const show_1 = __webpack_require__(83);
          const set_1 = __webpack_require__(84);
          const create_enum_1 = __webpack_require__(85);
          const create_view_1 = __webpack_require__(86);
          const create_materialized_view_1 = __webpack_require__(87);
          const create_schema_1 = __webpack_require__(88);
          const create_function_1 = __webpack_require__(89);
          const do_1 = __webpack_require__(90);
          const select_1 = __webpack_require__(12);
          const context_1 = __webpack_require__(4);
          const drop_type_1 = __webpack_require__(91);
          const detailsIncluded = Symbol("errorDetailsIncluded");
          class SimpleExecutor extends exec_utils_1.ExecHelper {
            constructor(st, exec, opName) {
              super(st);
              this.exec = exec;
              this.opName = opName;
            }
            execute(t2) {
              this.exec(t2);
              return this.noData(t2, this.opName);
            }
          }
          exports2.SimpleExecutor = SimpleExecutor;
          class MapNameResolver {
            constructor(map2, isolated) {
              this.map = map2;
              this.isolated = isolated;
            }
            resolve(name) {
              return this.map.get(name);
            }
          }
          class StatementExec {
            constructor(schema2, statement, pAsSql, parameters) {
              this.schema = schema2;
              this.statement = statement;
              this.pAsSql = pAsSql;
              this.parameters = parameters;
              this.onExecutedCallbacks = [];
            }
            onExecuted(callback) {
              this.onExecutedCallbacks.push(callback);
            }
            get db() {
              return this.schema.db;
            }
            _getExecutor(p) {
              switch (p.type) {
                case "start transaction":
                case "begin":
                  return new transaction_statements_1.BeginStatementExec(p);
                case "commit":
                  return new transaction_statements_1.CommitExecutor(p);
                case "rollback":
                  return new transaction_statements_1.RollbackExecutor(p);
                case "select":
                case "delete":
                case "update":
                case "insert":
                case "union":
                case "union all":
                case "values":
                case "with recursive":
                case "with":
                  return new select_1.SelectExec(this, p);
                case "truncate table":
                  return new truncate_table_1.TruncateTable(p);
                case "create table":
                  return new create_table_1.ExecuteCreateTable(p);
                case "create index":
                  return new create_index_1.CreateIndexExec(this, p);
                case "alter table":
                  return new alter_1.Alter(this, p);
                case "create extension":
                  return new SimpleExecutor(p, () => this.schema.executeCreateExtension(p));
                case "create sequence":
                  return new create_sequence_1.ExecuteCreateSequence(this.schema, p, false);
                case "alter sequence":
                  return new alter_sequence_1.AlterSequence(this, p);
                case "drop index":
                  return new drop_index_1.DropIndex(this, p);
                case "drop table":
                  return new drop_table_1.DropTable(this, p);
                case "drop sequence":
                  return new drop_sequence_1.DropSequence(this, p);
                case "drop type":
                  return new drop_type_1.DropType(this, p);
                case "show":
                  return new show_1.ShowExecutor(p);
                case "set":
                case "set timezone":
                  return new set_1.SetExecutor(p);
                case "create enum":
                  return new create_enum_1.CreateEnum(this, p);
                case "create view":
                  return new create_view_1.CreateView(this, p);
                case "create materialized view":
                  return new create_materialized_view_1.CreateMaterializedView(this, p);
                case "create schema":
                  return new create_schema_1.CreateSchema(this, p);
                case "create function":
                  return new create_function_1.CreateFunction(this, p);
                case "drop function":
                  return new SimpleExecutor(p, () => this.schema.dropFunction(p), "DROP");
                case "do":
                  return new do_1.DoStatementExec(this, p);
                case "comment":
                case "raise":
                case "deallocate":
                  (0, utils_1.ignore)(p);
                  return new SimpleExecutor(p, () => {
                  });
                case "refresh materialized view":
                  (0, utils_1.ignore)(p);
                  return new SimpleExecutor(p, () => {
                  });
                case "tablespace":
                  throw new interfaces_private_1.NotSupported('"TABLESPACE" statement');
                case "prepare":
                  throw new interfaces_private_1.NotSupported('"PREPARE" statement');
                case "create composite type":
                  throw new interfaces_private_1.NotSupported("create composite type");
                case "drop trigger":
                  throw new interfaces_private_1.NotSupported('"drop trigger" statement');
                case "alter index":
                  throw new interfaces_private_1.NotSupported('"alter index" statement');
                default:
                  throw interfaces_private_1.NotSupported.never(p, "statement type");
              }
            }
            compile() {
              return this.niceErrors(() => {
                var _a, _b;
                if (this.executor) {
                  return this.executor;
                }
                let p = this.statement;
                if (!this.db.options.noAstCoverageCheck) {
                  const watched = (0, utils_1.watchUse)(p);
                  p = watched.checked;
                  this.checkAstCoverage = () => {
                    var _a2;
                    const err = (_a2 = watched.check) === null || _a2 === void 0 ? void 0 : _a2.call(watched);
                    if (err) {
                      throw new interfaces_private_1.NotSupported(err);
                    }
                  };
                }
                const namedParams = (0, utils_1.fromEntries)((_b = (_a = this.parameters) === null || _a === void 0 ? void 0 : _a.filter((p2) => !!p2.value.id).map((x) => [x.value.id, x])) !== null && _b !== void 0 ? _b : []);
                const nameResolver = new MapNameResolver(namedParams, true);
                (0, context_1.withNameResolver)(nameResolver, () => (0, context_1.withStatement)(this, () => (0, context_1.withSelection)(this.schema.dualTable.selection, () => this.executor = this._getExecutor(p))));
                return this.executor;
              });
            }
            executeStatement(t2) {
              return this.niceErrors(() => (0, utils_1.pushExecutionCtx)({
                transaction: t2,
                schema: this.schema
              }, () => {
                var _a;
                t2.clearTransientData();
                if (!this.executor) {
                  throw new Error("Statement not prepared");
                }
                const result = this.executor.execute(t2);
                for (const s of this.onExecutedCallbacks) {
                  s(t2);
                }
                (_a = this.checkAstCoverage) === null || _a === void 0 ? void 0 : _a.call(this);
                return result;
              }));
            }
            niceErrors(act) {
              try {
                return act();
              } catch (e) {
                if (e && typeof e === "object" && e[detailsIncluded]) {
                  throw e;
                }
                if (!this.db.options.noErrorDiagnostic && e instanceof Error || e instanceof interfaces_private_1.NotSupported) {
                  const msgs = [e.message];
                  if (e instanceof interfaces_private_1.QueryError) {
                    msgs.push(`\u{1F41C} This seems to be an execution error, which means that your request syntax seems okay,
    but the resulting statement cannot be executed \u2192 Probably not a pg-mem error.`);
                  } else if (e instanceof interfaces_private_1.NotSupported) {
                    msgs.push(`\u{1F449} pg-mem is work-in-progress, and it would seem that you've hit one of its limits.`);
                  } else {
                    msgs.push('\u{1F4A5} This is a nasty error, which was unexpected by pg-mem. Also known "a bug" \u{1F601} Please file an issue !');
                  }
                  if (!this.db.options.noErrorDiagnostic) {
                    if (this.pAsSql) {
                      msgs.push(`*\uFE0F\u20E3 Failed SQL statement: ${this.pAsSql}`);
                    } else {
                      try {
                        msgs.push(`*\uFE0F\u20E3 Reconsituted failed SQL statement: ${pgsql_ast_parser_1.toSql.statement(this.statement)}`);
                      } catch (f) {
                        msgs.push(`*\uFE0F\u20E3 <Failed to reconsitute SQL - ${(0, utils_1.errorMessage)(f)}>`);
                      }
                    }
                  }
                  msgs.push("\u{1F449} You can file an issue at https://github.com/oguimbal/pg-mem along with a way to reproduce this error (if you can), and  the stacktrace:");
                  e.message = msgs.join("\n\n") + "\n\n";
                }
                if (e && typeof e === "object") {
                  e.location = (0, exec_utils_1.locOf)(this.statement);
                  e[detailsIncluded] = true;
                }
                throw e;
              }
            }
          }
          exports2.StatementExec = StatementExec;
        },
        /* 35 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.View = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const transform_base_1 = __webpack_require__(5);
          class View extends transform_base_1.FilterBase {
            constructor(ownerSchema, name, selection) {
              super(selection);
              this.ownerSchema = ownerSchema;
              this.name = name;
              this.selection = selection;
            }
            get type() {
              return "view";
            }
            get reg() {
              if (!this._reg) {
                throw new interfaces_private_1.QueryError(`relation "${this.name}" does not exist`);
              }
              return this._reg;
            }
            enumerate(t2) {
              return this.selection.enumerate(t2);
            }
            hasItem(value2, t2) {
              return this.selection.hasItem(value2, t2);
            }
            explain(e) {
              return this.selection.explain(e);
            }
            stats(t2) {
              return this.selection.stats(t2);
            }
            register() {
              this._reg = this.ownerSchema._reg_register(this);
              return this;
            }
            drop(t2) {
              throw new Error("Method not implemented.");
            }
          }
          exports2.View = View;
        },
        /* 36 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.SeqScanFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const datatypes_1 = __webpack_require__(2);
          class SeqScanFilter extends transform_base_1.FilterBase {
            constructor(selection, getter) {
              super(selection);
              this.selection = selection;
              this.getter = getter;
              this.getter = getter.cast(datatypes_1.Types.bool);
            }
            get index() {
              return null;
            }
            entropy(t2) {
              return this.selection.entropy(t2) * 1.5;
            }
            hasItem(raw, t2) {
              return !!this.getter.get(raw, t2);
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              for (const raw of this.selection.enumerate(t2)) {
                const cond = this.getter.get(raw, t2);
                if (cond) {
                  yield raw;
                }
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "seqFilter",
                filtered: this.selection.explain(e)
              };
            }
          }
          exports2.SeqScanFilter = SeqScanFilter;
        },
        /* 37 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          });
          var __exportStar = this && this.__exportStar || function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.enableStatementLocationTracking = exports2.newDb = void 0;
          var db_1 = __webpack_require__(38);
          Object.defineProperty(exports2, "newDb", { enumerable: true, get: function() {
            return db_1.newDb;
          } });
          var parse_cache_1 = __webpack_require__(26);
          Object.defineProperty(exports2, "enableStatementLocationTracking", { enumerable: true, get: function() {
            return parse_cache_1.enableStatementLocationTracking;
          } });
          __exportStar(__webpack_require__(3), exports2);
        },
        /* 38 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.newDb = void 0;
          const interfaces_1 = __webpack_require__(3);
          const interfaces_private_1 = __webpack_require__(0);
          const schema_1 = __webpack_require__(39);
          const transform_base_1 = __webpack_require__(5);
          const selection_1 = __webpack_require__(10);
          const alias_1 = __webpack_require__(25);
          const build_filter_1 = __webpack_require__(92);
          const adapters_1 = __webpack_require__(102);
          const transaction_1 = __webpack_require__(105);
          const aggregation_1 = __webpack_require__(23);
          const limit_1 = __webpack_require__(106);
          const union_1 = __webpack_require__(107);
          const distinct_1 = __webpack_require__(108);
          const order_by_1 = __webpack_require__(109);
          const pg_catalog_1 = __webpack_require__(110);
          const information_schema_1 = __webpack_require__(126);
          const utils_1 = __webpack_require__(1);
          function newDb2(opts) {
            (0, transform_base_1.initialize)({
              buildSelection: selection_1.buildSelection,
              buildAlias: alias_1.buildAlias,
              buildFilter: build_filter_1.buildFilter,
              buildGroupBy: aggregation_1.buildGroupBy,
              buildLimit: limit_1.buildLimit,
              buildUnion: union_1.buildUnion,
              buildOrderBy: order_by_1.buildOrderBy,
              buildDistinct: distinct_1.buildDistinct
            });
            const root = transaction_1.Transaction.root();
            const globals = root.getMap(interfaces_private_1.GLOBAL_VARS).set("server_version", "12.2 (pg-mem)");
            root.set(interfaces_private_1.GLOBAL_VARS, globals);
            return new MemoryDb(root, void 0, opts !== null && opts !== void 0 ? opts : {});
          }
          exports2.newDb = newDb2;
          class MemoryDb {
            constructor(data, schemas, options = {}) {
              this.data = data;
              this.options = options;
              this.handlers = /* @__PURE__ */ new Map();
              this.schemas = /* @__PURE__ */ new Map();
              this.schemaVersion = 1;
              this.adapters = new adapters_1.Adapters(this);
              this.extensions = {};
              this.languages = {};
              this.searchPath = ["pg_catalog", "public"];
              if (!schemas) {
                this.createSchema("public");
              } else {
                this.schemas = schemas;
              }
              (0, pg_catalog_1.setupPgCatalog)(this);
              (0, information_schema_1.setupInformationSchema)(this);
            }
            get public() {
              return this.getSchema(null);
            }
            onSchemaChange() {
              this.schemaVersion++;
              this.raiseGlobal("schema-change", this);
            }
            backup() {
              return new Backup(this);
            }
            registerExtension(name, install) {
              this.extensions[name] = install;
              return this;
            }
            registerLanguage(languageName, compiler) {
              this.languages[languageName.toLowerCase()] = compiler;
              return this;
            }
            getLanguage(name) {
              const ret = this.languages[name.toLowerCase()];
              if (!ret) {
                throw new interfaces_1.QueryError(`Unkonwn language "${name}". If you plan to use a script language, you must declare it to pg-mem via ".registerLanguage()"`);
              }
              return ret;
            }
            getExtension(name) {
              const ret = this.extensions[name];
              if (!ret) {
                throw new Error("Extension does not exist: " + name);
              }
              return ret;
            }
            createSchema(name) {
              if (this.schemas.has(name)) {
                throw new Error("Schema exists: " + name);
              }
              this.onSchemaChange();
              const ret = new schema_1.DbSchema(name, this);
              this.schemas.set(name, ret);
              return ret;
            }
            getTable(name, nullIfNotExists) {
              return this.public.getTable(name, nullIfNotExists);
            }
            resolveFunction(name, types) {
              const asSingle = (0, utils_1.asSingleQName)(name);
              if (asSingle) {
                for (const sp of this.searchPath) {
                  const found = this.getSchema(sp).resolveFunction(name, types, true);
                  if (found) {
                    return found;
                  }
                }
                return null;
              } else {
                const q = name;
                return this.getSchema(q.schema).resolveFunction(q.name, types, true);
              }
            }
            resolveOperator(name, left, right) {
              for (const sp of this.searchPath) {
                const found = this.getSchema(sp).resolveOperator(name, left, right, true);
                if (found) {
                  return found;
                }
              }
              return null;
            }
            on(event, handler) {
              let lst = this.handlers.get(event);
              if (!lst) {
                this.handlers.set(event, lst = /* @__PURE__ */ new Set());
              }
              lst.add(handler);
              return {
                unsubscribe: () => lst === null || lst === void 0 ? void 0 : lst.delete(handler)
              };
            }
            raiseTable(table, event) {
              const got = this.handlers.get(event);
              for (const h of got !== null && got !== void 0 ? got : []) {
                h(table);
              }
            }
            raiseGlobal(event, ...data) {
              const got = this.handlers.get(event);
              for (const h of got !== null && got !== void 0 ? got : []) {
                h(...data);
              }
            }
            getSchema(db, nullIfNotFound) {
              db = db !== null && db !== void 0 ? db : "public";
              const got = this.schemas.get(db);
              if (!got) {
                if (nullIfNotFound) {
                  return null;
                }
                throw new interfaces_1.QueryError("schema not found: " + db);
              }
              return got;
            }
            listSchemas() {
              return [...this.schemas.values()];
            }
          }
          class Backup {
            constructor(db) {
              this.db = db;
              this.data = db.data.clone();
              this.schemaVersion = db.schemaVersion;
            }
            restore() {
              if (this.schemaVersion !== this.db.schemaVersion) {
                throw new Error("You cannot restore this backup: schema has been changed since this backup has been created => prefer .clone() in this kind of cases.");
              }
              this.db.data = this.data.clone();
            }
          }
        },
        /* 39 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DbSchema = void 0;
          const interfaces_1 = __webpack_require__(3);
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(2);
          const table_1 = __webpack_require__(49);
          const parse_cache_1 = __webpack_require__(26);
          const migrate_1 = __webpack_require__(70);
          const t_custom_enum_1 = __webpack_require__(32);
          const datatype_base_1 = __webpack_require__(9);
          const t_equivalent_1 = __webpack_require__(71);
          const overload_resolver_1 = __webpack_require__(72);
          const create_sequence_1 = __webpack_require__(33);
          const statement_exec_1 = __webpack_require__(34);
          const select_1 = __webpack_require__(12);
          class DbSchema {
            constructor(name, db) {
              this.name = name;
              this.db = db;
              this.relsByNameCas = /* @__PURE__ */ new Map();
              this.relsByCls = /* @__PURE__ */ new Map();
              this.relsByTyp = /* @__PURE__ */ new Map();
              this._tables = /* @__PURE__ */ new Set();
              this.fns = new overload_resolver_1.OverloadResolver(false);
              this.ops = new overload_resolver_1.OverloadResolver(false);
              this.installedExtensions = /* @__PURE__ */ new Set();
              this.interceptors = /* @__PURE__ */ new Set();
              this.simpleTypes = {};
              this.sizeableTypes = {};
              this.dualTable = new table_1.MemoryTable(this, this.db.data, { fields: [], name: "dual" }).register();
              this.dualTable.insert({});
              this.dualTable.setReadonly();
              this._reg_unregister(this.dualTable);
            }
            setReadonly() {
              this.readonly = true;
              return this;
            }
            none(query) {
              this.query(query);
            }
            one(query) {
              const [result] = this.many(query);
              return result;
            }
            many(query) {
              return this.query(query).rows;
            }
            query(text) {
              if (typeof text === "string") {
                for (const { intercept } of this.interceptors) {
                  const ret = intercept(text);
                  if (ret) {
                    return {
                      command: text,
                      fields: [],
                      location: { start: 0, end: text.length },
                      rowCount: 0,
                      rows: ret
                    };
                  }
                }
              }
              let last3;
              for (const r of this.queries(text)) {
                last3 = r;
              }
              return last3 !== null && last3 !== void 0 ? last3 : {
                command: typeof text === "string" ? text : "<custom ast>",
                fields: [],
                location: { start: 0, end: typeof text === "string" ? text.length : 0 },
                rowCount: 0,
                rows: []
              };
            }
            parse(query) {
              if (typeof query === "string") {
                return (0, parse_cache_1.parseSql)(query);
              }
              return Array.isArray(query) ? query : [query];
            }
            *queries(query) {
              query = typeof query === "string" ? query + ";" : query;
              try {
                let parsed = this.parse(query);
                if (!Array.isArray(parsed)) {
                  parsed = [parsed];
                }
                const singleSql = typeof query === "string" && parsed.length === 1 ? query : void 0;
                const prepared = parsed.filter((s) => !!s).map((x) => new statement_exec_1.StatementExec(this, x, singleSql));
                let t2 = this.db.data.fork();
                for (const p of prepared) {
                  const executor = p.compile();
                  if (executor instanceof select_1.SelectExec) {
                    this.lastSelect = executor.selection;
                  }
                  const { state, result } = p.executeStatement(t2);
                  yield result;
                  t2 = state;
                }
                t2.fullCommit();
                this.db.raiseGlobal("query", query);
              } catch (e) {
                this.db.raiseGlobal("query-failed", query);
                throw e;
              }
            }
            registerEnum(name, values2) {
              new t_custom_enum_1.CustomEnumType(this, name, values2).install();
            }
            getThisOrSiblingFor(name) {
              if (!(name === null || name === void 0 ? void 0 : name.schema) || name.schema === this.name) {
                return this;
              }
              return this.db.getSchema(name.schema);
            }
            parseType(native) {
              if (/\[\]$/.test(native)) {
                const inner = this.parseType(native.substr(0, native.length - 2));
                return inner.asArray();
              }
              return this.getType({ name: native });
            }
            getOwnType(t2) {
              var _a, _b, _c, _d, _e;
              if (t2.kind === "array") {
                const $of = this.getOwnType(t2.arrayOf);
                if (!$of) {
                  return null;
                }
                return $of.asArray();
              }
              const synonym = t2.doubleQuoted ? null : datatypes_1.typeSynonyms[t2.name];
              let name;
              let ignoreConfig = false;
              if (typeof synonym === "object" && synonym && "type" in synonym) {
                name = synonym.type;
                ignoreConfig = synonym.ignoreConfig;
              } else {
                name = synonym !== null && synonym !== void 0 ? synonym : t2.name;
              }
              const sizeable = this.sizeableTypes[name];
              if (sizeable) {
                const key = ((_a = t2.config) === null || _a === void 0 ? void 0 : _a.length) === 1 ? t2.config[0] : (_c = (_b = t2.config) === null || _b === void 0 ? void 0 : _b.join(",")) !== null && _c !== void 0 ? _c : void 0;
                let ret = sizeable.regs.get(key);
                if (!ret) {
                  sizeable.regs.set(key, ret = sizeable.ctor(...(_d = t2.config) !== null && _d !== void 0 ? _d : []));
                }
                return ret;
              } else if (ignoreConfig) {
                (0, utils_1.ignore)(t2.config);
              }
              return (_e = this.simpleTypes[name]) !== null && _e !== void 0 ? _e : null;
            }
            getTypePub(t2) {
              return this.getType(t2);
            }
            getType(_t, opts) {
              if (typeof _t === "number") {
                const byOid = this.relsByTyp.get(_t);
                if (byOid) {
                  return (0, interfaces_private_1.asType)(byOid);
                }
                throw new interfaces_1.TypeNotFound(_t);
              }
              if (typeof _t === "string") {
                return this.getType({ name: _t });
              }
              if ((0, utils_1.isType)(_t)) {
                return _t;
              }
              const t2 = _t;
              function chk(ret) {
                if (!ret && !(opts === null || opts === void 0 ? void 0 : opts.nullIfNotFound)) {
                  throw new interfaces_1.TypeNotFound(t2);
                }
                return ret;
              }
              const schema2 = (0, utils_1.schemaOf)(t2);
              if (schema2) {
                if (schema2 === this.name) {
                  return chk(this.getOwnType(t2));
                } else {
                  return chk(this.db.getSchema(schema2).getType(t2, opts));
                }
              }
              if (opts === null || opts === void 0 ? void 0 : opts.skipSearch) {
                return chk(this.getOwnType(t2));
              }
              for (const sp of this.db.searchPath) {
                const rel = this.db.getSchema(sp).getOwnType(t2);
                if (rel) {
                  return rel;
                }
              }
              return chk(this.getOwnType(t2));
            }
            getObject(p, opts) {
              function chk(ret) {
                var _a;
                const bc = opts === null || opts === void 0 ? void 0 : opts.beingCreated;
                if (!ret && bc && (!p.schema || p.schema === ((_a = bc.ownerSchema) === null || _a === void 0 ? void 0 : _a.name)) && bc.name === p.name) {
                  ret = bc;
                }
                if (!ret && !(opts === null || opts === void 0 ? void 0 : opts.nullIfNotFound)) {
                  throw new interfaces_1.RelationNotFound(p.name);
                }
                return ret;
              }
              if (p.schema) {
                if (p.schema === this.name) {
                  return chk(this.getOwnObject(p.name));
                } else {
                  return chk(this.db.getSchema(p.schema).getObject(p, opts));
                }
              }
              if (opts === null || opts === void 0 ? void 0 : opts.skipSearch) {
                return chk(this.getOwnObject(p.name));
              }
              for (const sp of this.db.searchPath) {
                const rel = this.db.getSchema(sp).getOwnObject(p.name);
                if (rel) {
                  return rel;
                }
              }
              return chk(this.getOwnObject(p.name));
            }
            getOwnObject(name) {
              var _a;
              return (_a = this.relsByNameCas.get(name)) !== null && _a !== void 0 ? _a : null;
            }
            getObjectByRegOrName(_reg, opts) {
              const reg = (0, utils_1.parseRegClass)(_reg);
              if (typeof reg === "number") {
                return this.getObjectByRegClassId(reg, opts);
              }
              return this.getObject(reg, opts);
            }
            getObjectByRegClassId(reg, opts) {
              function chk(ret) {
                if (!ret && !(opts === null || opts === void 0 ? void 0 : opts.nullIfNotFound)) {
                  throw new interfaces_1.RelationNotFound(reg.toString());
                }
                return ret;
              }
              if (opts === null || opts === void 0 ? void 0 : opts.skipSearch) {
                return chk(this.getOwnObjectByRegClassId(reg));
              }
              for (const sp of this.db.searchPath) {
                const rel = this.db.getSchema(sp).getOwnObjectByRegClassId(reg);
                if (rel) {
                  return rel;
                }
              }
              return chk(this.getOwnObjectByRegClassId(reg));
            }
            getOwnObjectByRegClassId(reg) {
              var _a;
              return (_a = this.relsByCls.get(reg)) !== null && _a !== void 0 ? _a : null;
            }
            createSequence(t2, opts, _name) {
              _name = _name !== null && _name !== void 0 ? _name : {
                name: (0, utils_1.randomString)()
              };
              return new create_sequence_1.ExecuteCreateSequence(this, {
                type: "create sequence",
                name: _name,
                options: opts !== null && opts !== void 0 ? opts : {}
              }, true).createSeq(t2);
            }
            explainLastSelect() {
              var _a;
              return (_a = this.lastSelect) === null || _a === void 0 ? void 0 : _a.explain(new Explainer(this.db.data));
            }
            explainSelect(sql) {
              let parsed = this.parse(sql);
              if (parsed.length !== 1) {
                throw new Error("Expecting a single statement");
              }
              if (parsed[0].type !== "select") {
                throw new Error("Expecting a select statement");
              }
              const prepared = new statement_exec_1.StatementExec(this, parsed[0], sql).compile();
              if (!(prepared instanceof select_1.SelectExec)) {
                throw new Error("Can only explain selection executors");
              }
              return prepared.selection.explain(new Explainer(this.db.data));
            }
            executeCreateExtension(p) {
              const ext = this.db.getExtension(p.extension.name);
              const schema2 = p.schema ? this.db.getSchema(p.schema.name) : this;
              this.db.raiseGlobal("create-extension", p.extension, schema2, p.version, p.from);
              const ne = p.ifNotExists;
              if (this.installedExtensions.has(p.extension.name)) {
                if (ne) {
                  return;
                }
                throw new interfaces_1.QueryError("Extension already created !");
              }
              ext(schema2);
              this.installedExtensions.add(p.extension.name);
            }
            getTable(name, nullIfNotFound) {
              const ret = this.getOwnObject(name);
              if (!ret || ret.type !== "table") {
                if (nullIfNotFound) {
                  return null;
                }
                throw new interfaces_1.RelationNotFound(name);
              }
              return ret;
            }
            declareTable(table, noSchemaChange) {
              const trans = this.db.data.fork();
              const ret = new table_1.MemoryTable(this, trans, table).register();
              trans.commit();
              if (!noSchemaChange) {
                this.db.onSchemaChange();
              }
              return ret;
            }
            registerEquivalentType(type) {
              const ret = new t_equivalent_1.EquivalentType(type);
              this._registerType(ret);
              return ret;
            }
            _registerTypeSizeable(name, ctor) {
              if (this.simpleTypes[name] || this.sizeableTypes[name]) {
                throw new interfaces_1.QueryError(`type "${name}" already exists`);
              }
              this.sizeableTypes[name] = {
                ctor,
                regs: /* @__PURE__ */ new Map()
              };
              return this;
            }
            _registerType(type) {
              if (this.simpleTypes[type.primary] || this.sizeableTypes[type.primary] || this.getOwnObject(type.primary)) {
                throw new interfaces_1.QueryError(`type "${type.primary}" already exists`);
              }
              this.simpleTypes[type.primary] = type;
              this._reg_register(type);
              return this;
            }
            _unregisterType(type) {
              delete this.simpleTypes[type.primary];
              this._reg_unregister(type);
              return this;
            }
            _reg_register(rel) {
              if (this.readonly) {
                throw new interfaces_1.PermissionDeniedError();
              }
              if (this.relsByNameCas.has(rel.name)) {
                throw new Error(`relation "${rel.name}" already exists`);
              }
              const ret = (0, datatype_base_1.regGen)();
              this.relsByNameCas.set(rel.name, rel);
              this.relsByCls.set(ret.classId, rel);
              this.relsByTyp.set(ret.typeId, rel);
              if (rel.type === "table") {
                this._tables.add(rel);
              }
              return ret;
            }
            _reg_unregister(rel) {
              if (this.readonly) {
                throw new interfaces_1.PermissionDeniedError();
              }
              this.relsByNameCas.delete(rel.name);
              this.relsByCls.delete(rel.reg.classId);
              this.relsByTyp.delete(rel.reg.typeId);
              if (rel.type === "table") {
                this._tables.delete(rel);
              }
            }
            _reg_rename(rel, oldName, newName) {
              if (this.readonly) {
                throw new interfaces_1.PermissionDeniedError();
              }
              if (this.relsByNameCas.has(newName)) {
                throw new Error("relation exists: " + newName);
              }
              if (this.relsByNameCas.get(oldName) !== rel) {
                throw new Error("consistency error while renaming relation");
              }
              this.relsByNameCas.delete(oldName);
              this.relsByNameCas.set(newName, rel);
            }
            tablesCount(t2) {
              return this._tables.size;
            }
            *listTables() {
              for (const t2 of this._tables.values()) {
                if (!t2.hidden) {
                  yield t2;
                }
              }
            }
            registerFunction(fn, replace) {
              var _a, _b;
              const def = {
                name: fn.name,
                args: (_b = (_a = fn.args) === null || _a === void 0 ? void 0 : _a.map((x) => {
                  if (typeof x === "string" || (0, utils_1.isType)(x)) {
                    return {
                      type: this.getTypePub(x)
                    };
                  }
                  return x;
                })) !== null && _b !== void 0 ? _b : [],
                argsVariadic: fn.argsVariadic && this.getTypePub(fn.argsVariadic),
                returns: fn.returns && this.getTypePub(fn.returns),
                impure: !!fn.impure,
                implementation: fn.implementation,
                allowNullArguments: fn.allowNullArguments
              };
              this.fns.add(def, replace !== null && replace !== void 0 ? replace : true);
              return this;
            }
            registerOperator(op, replace) {
              this._registerOperator(op, replace !== null && replace !== void 0 ? replace : true);
              if (op.commutative && op.left !== op.right) {
                this._registerOperator({
                  ...op,
                  left: op.right,
                  right: op.left,
                  implementation: (a, b) => op.implementation(b, a)
                }, replace !== null && replace !== void 0 ? replace : true);
              }
              return this;
            }
            _registerOperator(fn, replace) {
              var _a;
              const args = [fn.left, fn.right].map((x) => {
                if (typeof x === "string" || (0, utils_1.isType)(x)) {
                  return {
                    type: this.getTypePub(x)
                  };
                }
                return x;
              });
              const def = {
                name: fn.operator,
                args,
                left: args[0].type,
                right: args[1].type,
                returns: fn.returns && this.getTypePub(fn.returns),
                impure: !!fn.impure,
                implementation: fn.implementation,
                allowNullArguments: fn.allowNullArguments,
                commutative: (_a = fn.commutative) !== null && _a !== void 0 ? _a : false
              };
              this.ops.add(def, replace);
              return this;
            }
            resolveFunction(name, args, forceOwn) {
              const asSingle = (0, utils_1.asSingleQName)(name, this.name);
              if (!asSingle || !forceOwn) {
                return this.db.resolveFunction(name, args);
              }
              return this.fns.resolve(asSingle, args);
            }
            getFunction(name, args) {
              return this.fns.getExact(name, args);
            }
            dropFunction(fn) {
              if (fn.name.schema && fn.name.schema !== this.name) {
                return this.db.getSchema(fn.name.schema).dropFunction(fn);
              }
              const fns = this.fns.getOverloads(fn.name.name);
              let toRemove;
              if (fn.arguments) {
                const targetArgs = fn.arguments;
                const match = fns === null || fns === void 0 ? void 0 : fns.filter((x) => x.args.length === targetArgs.length && !x.args.some((a, i) => a.type !== this.getType(targetArgs[i].type)));
                if (!(match === null || match === void 0 ? void 0 : match.length)) {
                  if (fn.ifExists) {
                    return;
                  }
                  throw new interfaces_1.QueryError(`function ${fn.name.name}(${targetArgs.map((t2) => (0, interfaces_1.typeDefToStr)(t2.type)).join(",")}) does not exist`, "42883");
                }
                if (match.length > 1) {
                  throw new interfaces_1.QueryError(`function name "${fn.name.name}" is ambiguous`, "42725");
                }
                toRemove = match[0];
              } else {
                if (!(fns === null || fns === void 0 ? void 0 : fns.length)) {
                  if (fn.ifExists) {
                    return;
                  }
                  throw new interfaces_1.QueryError(`could not find a function named "${fn.name.name}"`, "42883");
                }
                if ((fns === null || fns === void 0 ? void 0 : fns.length) !== 1) {
                  throw new interfaces_1.QueryError(`function name "${fn.name.name}" is not unique`, "42725");
                }
                toRemove = fns[0];
              }
              this.fns.remove(toRemove);
            }
            resolveOperator(name, left, right, forceOwn) {
              if (!forceOwn) {
                return this.db.resolveOperator(name, left, right);
              }
              return this.ops.resolve(name, [left, right]);
            }
            async migrate(config2) {
              await (0, migrate_1.migrate)(this, config2);
            }
            interceptQueries(intercept) {
              const qi = { intercept };
              this.interceptors.add(qi);
              return {
                unsubscribe: () => {
                  this.interceptors.delete(qi);
                }
              };
            }
          }
          exports2.DbSchema = DbSchema;
          class Explainer {
            constructor(transaction) {
              this.transaction = transaction;
              this.sels = /* @__PURE__ */ new Map();
            }
            idFor(sel) {
              if (sel.debugId) {
                return sel.debugId;
              }
              if (this.sels.has(sel)) {
                return this.sels.get(sel);
              }
              const id = this.sels.size + 1;
              this.sels.set(sel, id);
              return id;
            }
          }
        },
        /* 40 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildCall = void 0;
          const datatypes_1 = __webpack_require__(2);
          const interfaces_1 = __webpack_require__(3);
          const evaluator_1 = __webpack_require__(11);
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const utils_1 = __webpack_require__(1);
          const context_1 = __webpack_require__(4);
          function buildCall(name, args) {
            let type = null;
            let get11;
            let impure = false;
            let acceptNulls = false;
            const { schema: schema2 } = (0, context_1.buildCtx)();
            switch ((0, utils_1.asSingleQName)(name)) {
              case "any":
                return buildAnyCall(args);
              case "current_schema":
                type = datatypes_1.Types.text();
                get11 = () => "public";
                break;
              case "pg_get_constraintdef":
              case "pg_get_expr":
                type = datatypes_1.Types.text();
                get11 = () => {
                  throw new interfaces_1.NotSupported((0, utils_1.qnameToStr)(name) + " is not supported");
                };
                break;
              case "unnest":
                if (args.length !== 1) {
                  throw new interfaces_1.QueryError("unnest expects 1 arguments, given " + args.length);
                }
                const utype = args[0].type;
                if (!(utype instanceof datatypes_1.ArrayType)) {
                  throw new interfaces_1.QueryError("unnest expects enumerable argument " + utype.primary);
                }
                type = utype.of;
                get11 = () => {
                  throw new interfaces_1.NotSupported((0, utils_1.qnameToStr)(name) + " is not supported");
                };
                break;
              case "coalesce":
                acceptNulls = true;
                if (!args.length) {
                  throw new interfaces_1.QueryError("coalesce expects at least 1 argument");
                }
                type = args.reduce((a, b) => {
                  if (a === b.type) {
                    return a;
                  }
                  if (b.type.canCast(a)) {
                    return a;
                  }
                  if (a.canCast(b.type)) {
                    return b.type;
                  }
                  throw new interfaces_1.QueryError(`COALESCE types ${a.name} and ${b.type.name} cannot be matched`, "42804");
                }, args[0].type);
                args = args.map((x) => x.cast(type));
                get11 = (...args2) => args2.find((x) => !(0, utils_1.nullIsh)(x));
                break;
              default:
                acceptNulls = true;
                const resolved = schema2.resolveFunction(name, args);
                if (resolved) {
                  args = args.map((x, i) => {
                    var _a, _b;
                    return x.cast((_b = (_a = resolved.args[i]) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : resolved.argsVariadic);
                  });
                  type = resolved.returns;
                  get11 = resolved.implementation;
                  impure = !!resolved.impure;
                  acceptNulls = !!resolved.allowNullArguments;
                }
                break;
            }
            if (!get11) {
              throw new interfaces_1.QueryError({
                error: `function ${(0, utils_1.qnameToStr)(name)}(${args.map((a) => a.type.name).join(",")}) does not exist`,
                hint: `\u{1F528} Please note that pg-mem implements very few native functions.

            \u{1F449} You can specify the functions you would like to use via "db.public.registerFunction(...)"`
              });
            }
            return new evaluator_1.Evaluator(type !== null && type !== void 0 ? type : datatypes_1.Types.null, null, (0, object_hash_1.default)({ call: name, args: args.map((x) => x.hash) }), args, (raw, t2) => {
              const argRaw = args.map((x) => x.get(raw, t2));
              if (!acceptNulls && argRaw.some(utils_1.nullIsh)) {
                return null;
              }
              return get11(...argRaw);
            }, impure ? { unpure: impure } : void 0);
          }
          exports2.buildCall = buildCall;
          function buildAnyCall(args) {
            if (args.length !== 1) {
              throw new interfaces_1.QueryError("ANY() expects 1 argument, given " + args.length);
            }
            const array = args[0];
            if (array.type instanceof datatypes_1.ArrayType) {
              return new evaluator_1.Evaluator(
                array.type.of,
                null,
                (0, object_hash_1.default)({ any: array.hash }),
                args,
                (raw, t2) => {
                  return array.get(raw, t2);
                },
                { isAny: true }
                // <== isAny !
              );
            }
            if (array.type !== datatypes_1.Types.text() || !array.isConstantLiteral) {
              throw new interfaces_1.QueryError("ANY() expects either a selection, or an array literal");
            }
            const arrayValue = (0, pgsql_ast_parser_1.parseArrayLiteral)(array.get());
            return new evaluator_1.Evaluator(
              datatypes_1.Types.text(),
              null,
              (0, object_hash_1.default)({ any: array.hash }),
              args,
              arrayValue,
              { isAny: true }
              // <== isAny !
            );
          }
        },
        /* 41 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CircleType = exports2.PolygonType = exports2.PathType = exports2.BoxType = exports2.LsegType = exports2.LineType = exports2.PointType = exports2.pointEq = exports2.pointToStr = void 0;
          const interfaces_1 = __webpack_require__(3);
          const datatype_base_1 = __webpack_require__(9);
          function pointToStr(p) {
            return `(${p.x},${p.y})`;
          }
          exports2.pointToStr = pointToStr;
          function pointEq(a, b) {
            return a.x === b.x && a.y === b.y;
          }
          exports2.pointEq = pointEq;
          class PointType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.point;
            }
            get name() {
              return "point";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion((p) => {
                return pointToStr(p);
              }, (pointToTxt) => ({ pointToTxt }));
            }
            doEquals(a, b) {
              return pointEq(a, b);
            }
            doGt(a, b) {
              if (a.x !== b.x) {
                return a.x > b.x;
              }
              return a.y > b.y;
            }
            doLt(a, b) {
              if (a.x !== b.x) {
                return a.x < b.x;
              }
              return a.y < b.y;
            }
          }
          exports2.PointType = PointType;
          class LineType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.line;
            }
            get name() {
              return "line";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion((l) => {
                return `{${l.a},${l.b},${l.c}}`;
              }, (lineToTxt) => ({ lineToTxt }));
            }
            doEquals(a, b) {
              return a.a === b.a && a.b === b.b && a.c === b.c;
            }
          }
          exports2.LineType = LineType;
          class LsegType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.lseg;
            }
            get name() {
              return "lseg";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion(([a, b]) => {
                return `[${pointToStr(a)},${pointToStr(b)}]`;
              }, (SegmentToTxt) => ({ SegmentToTxt }));
            }
            doEquals([as, ae], [bs, be]) {
              return pointEq(as, bs) && pointEq(ae, be);
            }
          }
          exports2.LsegType = LsegType;
          class BoxType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.box;
            }
            get name() {
              return "box";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion(([a, b]) => {
                return `${pointToStr(a)},${pointToStr(b)}`;
              }, (BoxToTxt) => ({ BoxToTxt }));
            }
            doEquals([as, ae], [bs, be]) {
              return pointEq(as, bs) && pointEq(ae, be);
            }
          }
          exports2.BoxType = BoxType;
          class PathType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.path;
            }
            get name() {
              return "path";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion((p) => {
                const vals = p.path.map(pointToStr).join(",");
                return p.closed ? "(" + vals + ")" : "[" + vals + "]";
              }, (PathToTxt) => ({ PathToTxt }));
            }
            doEquals(a, b) {
              return true;
            }
          }
          exports2.PathType = PathType;
          class PolygonType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.polygon;
            }
            get name() {
              return "polygon";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion((p) => {
                const vals = p.map(pointToStr).join(",");
                return "(" + vals + ")";
              }, (PolygonToTxt) => ({ PolygonToTxt }));
            }
            doEquals(a, b) {
              return a.length === b.length && a.every((x, i) => pointEq(x, b[i]));
            }
          }
          exports2.PolygonType = PolygonType;
          class CircleType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.circle;
            }
            get name() {
              return "circle";
            }
            doCanCast(t2) {
              return t2.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              if (to.primary !== interfaces_1.DataType.text) {
                throw new interfaces_1.QueryError(`Invalid cast to: ` + to.primary);
              }
              return value2.setConversion((p) => {
                return `<${pointToStr(p.c)},${p.r}>`;
              }, (CircleToTxt) => ({ CircleToTxt }));
            }
            doEquals(a, b) {
              return pointEq(a.c, b.c) && a.r === b.r;
            }
          }
          exports2.CircleType = CircleType;
        },
        /* 42 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.IntervalType = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const pgsql_ast_parser_1 = __webpack_require__(13);
          const datatype_base_1 = __webpack_require__(9);
          const utils_1 = __webpack_require__(1);
          class IntervalType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_private_1.DataType.interval;
            }
            doCanBuildFrom(from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return true;
              }
              return false;
            }
            doBuildFrom(value2, from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return value2.setConversion((str) => {
                    const conv = (0, pgsql_ast_parser_1.normalizeInterval)((0, pgsql_ast_parser_1.parseIntervalLiteral)(str));
                    return conv;
                  }, (toInterval) => ({ toInterval }));
              }
              return null;
            }
            doEquals(a, b) {
              return (0, utils_1.intervalToSec)(a) === (0, utils_1.intervalToSec)(b);
            }
            doGt(a, b) {
              return (0, utils_1.intervalToSec)(a) > (0, utils_1.intervalToSec)(b);
            }
            doLt(a, b) {
              return (0, utils_1.intervalToSec)(a) < (0, utils_1.intervalToSec)(b);
            }
          }
          exports2.IntervalType = IntervalType;
        },
        /* 43 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TimeType = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatype_base_1 = __webpack_require__(9);
          const utils_1 = __webpack_require__(1);
          class TimeType extends datatype_base_1.TypeBase {
            constructor(primary) {
              super();
              this.primary = primary;
            }
            get name() {
              return this.primary === interfaces_private_1.DataType.timetz ? "time with time zone" : "time without time zone";
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.text:
                case interfaces_private_1.DataType.timetz:
                case interfaces_private_1.DataType.time:
                  return true;
              }
              return null;
            }
            doCanConvertImplicit(to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.timetz:
                  return true;
                case interfaces_private_1.DataType.time:
                  return this.primary === interfaces_private_1.DataType.time;
              }
              return false;
            }
            doCast(value2, to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.text:
                case interfaces_private_1.DataType.time:
                case interfaces_private_1.DataType.timetz:
                  return value2.setType(to);
              }
              throw new Error("Unexpected cast error");
            }
            doCanBuildFrom(from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return true;
              }
              return false;
            }
            doBuildFrom(value2, from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return value2.setConversion((str) => {
                    const conv = (0, utils_1.parseTime)(str);
                    const ret = conv.format("HH:mm:ss");
                    const ms = conv.milliseconds();
                    return ms ? ret + (ms / 1e3).toString(10).substr(1) : ret;
                  }, (toTime) => ({ toTime }));
              }
              return null;
            }
          }
          exports2.TimeType = TimeType;
        },
        /* 44 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TimestampType = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatype_base_1 = __webpack_require__(9);
          const moment_1 = __importDefault(__webpack_require__(17));
          const utils_1 = __webpack_require__(1);
          class TimestampType extends datatype_base_1.TypeBase {
            constructor(primary, precision = null) {
              super();
              this.primary = primary;
              this.precision = precision;
            }
            get name() {
              if (!(0, utils_1.nullIsh)(this.precision)) {
                return `${this.primary}(${this.precision})`;
              }
              switch (this.primary) {
                case interfaces_private_1.DataType.timestamp:
                  return "timestamp without time zone";
                case interfaces_private_1.DataType.timestamptz:
                  return "timestamp with time zone";
                case interfaces_private_1.DataType.date:
                  return "date";
                case interfaces_private_1.DataType.time:
                  return "time without time zone";
                case interfaces_private_1.DataType.timetz:
                  return "time with time zone";
              }
              return this.primary;
            }
            doCanCast(to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.timestamp:
                case interfaces_private_1.DataType.timestamptz:
                case interfaces_private_1.DataType.date:
                  return this.primary !== interfaces_private_1.DataType.time && this.primary !== interfaces_private_1.DataType.timetz;
                case interfaces_private_1.DataType.time:
                  return this.primary !== interfaces_private_1.DataType.date;
                case interfaces_private_1.DataType.timetz:
                  return this.primary !== interfaces_private_1.DataType.date && this.primary !== interfaces_private_1.DataType.timestamp;
              }
              return null;
            }
            doCanConvertImplicit(to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.timestamp:
                  return this.primary === interfaces_private_1.DataType.timestamp || this.primary === interfaces_private_1.DataType.date;
                case interfaces_private_1.DataType.timestamptz:
                  return this.primary !== interfaces_private_1.DataType.time;
                case interfaces_private_1.DataType.date:
                  return this.primary === interfaces_private_1.DataType.date;
                case interfaces_private_1.DataType.time:
                  return this.primary === interfaces_private_1.DataType.time;
              }
              return false;
            }
            doCast(value2, to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.timestamp:
                case interfaces_private_1.DataType.timestamptz:
                  return value2;
                case interfaces_private_1.DataType.date:
                  return value2.setConversion((raw) => moment_1.default.utc(raw).startOf("day").toDate(), (toDate) => ({ toDate }));
                case interfaces_private_1.DataType.time:
                case interfaces_private_1.DataType.timetz:
                  return value2.setConversion((raw) => moment_1.default.utc(raw).format("HH:mm:ss") + ".000000", (toDate) => ({ toDate }));
              }
              throw new Error("Unexpected cast error");
            }
            doCanBuildFrom(from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return true;
              }
              return false;
            }
            doBuildFrom(value2, from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  switch (this.primary) {
                    case interfaces_private_1.DataType.timestamp:
                    case interfaces_private_1.DataType.timestamptz:
                      return value2.setConversion((str) => {
                        const conv = moment_1.default.utc(str);
                        if (!conv.isValid()) {
                          throw new interfaces_private_1.QueryError(`Invalid timestamp format: ` + str);
                        }
                        return conv.toDate();
                      }, (toTs) => ({ toTs, t: this.primary }));
                    case interfaces_private_1.DataType.date:
                      return value2.setConversion((str) => {
                        const conv = moment_1.default.utc(str);
                        if (!conv.isValid()) {
                          throw new interfaces_private_1.QueryError(`Invalid timestamp format: ` + str);
                        }
                        return conv.startOf("day").toDate();
                      }, (toDate) => ({ toDate }));
                    case interfaces_private_1.DataType.time:
                    case interfaces_private_1.DataType.timetz:
                      return value2.setConversion((str) => {
                        (0, utils_1.parseTime)(str);
                        return str;
                      }, (toTime) => ({ toTime, t: this.primary }));
                  }
              }
              return null;
            }
            doEquals(a, b) {
              return Math.abs((0, moment_1.default)(a).diff((0, moment_1.default)(b))) < 0.1;
            }
            doGt(a, b) {
              return (0, moment_1.default)(a).diff((0, moment_1.default)(b)) > 0;
            }
            doLt(a, b) {
              return (0, moment_1.default)(a).diff((0, moment_1.default)(b)) < 0;
            }
          }
          exports2.TimestampType = TimestampType;
        },
        /* 45 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.JSONBType = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatype_base_1 = __webpack_require__(9);
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(14);
          const clean_results_1 = __webpack_require__(18);
          const interfaces_1 = __webpack_require__(3);
          const json_stable_stringify_1 = __importDefault(__webpack_require__(28));
          class JSONBType extends datatype_base_1.TypeBase {
            constructor(primary) {
              super();
              this.primary = primary;
            }
            doCanCast(_to) {
              switch (_to.primary) {
                case interfaces_private_1.DataType.text:
                case interfaces_private_1.DataType.json:
                case interfaces_private_1.DataType.jsonb:
                case interfaces_private_1.DataType.float:
                case interfaces_private_1.DataType.bool:
                case interfaces_private_1.DataType.integer:
                  return true;
              }
              return null;
            }
            doCast(a, to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.text:
                  return a.setType(datatypes_1.Types.text()).setConversion((json) => (0, json_stable_stringify_1.default)(this.toResult(json)), (toJsonB) => ({ toJsonB })).cast(to);
                case interfaces_private_1.DataType.jsonb:
                case interfaces_private_1.DataType.json:
                  return a.setType(to);
                case interfaces_private_1.DataType.float:
                case interfaces_private_1.DataType.integer:
                  const isInt = to.primary === interfaces_private_1.DataType.integer;
                  return a.setType(to).setConversion((json) => {
                    if (json === clean_results_1.JSON_NIL) {
                      throw new interfaces_1.QueryError("cannot cast jsonb null to type " + (isInt ? "integer" : "double precision"), "22023");
                    }
                    if (typeof json !== "number") {
                      throw new interfaces_1.QueryError("cannot cast jsonb string to type " + (isInt ? "integer" : "double precision"), "22023");
                    }
                    return isInt ? Math.round(json) : json;
                  }, (toFloat) => ({ toFloat }));
                case interfaces_private_1.DataType.bool:
                  return a.setType(to).setConversion((json) => {
                    if (typeof json !== "boolean") {
                      throw new interfaces_1.QueryError("cannot cast jsonb string to type boolean", "22023");
                    }
                    return json;
                  }, (toFloat) => ({ toFloat }));
                default:
                  return a.setType(to);
              }
            }
            doCanBuildFrom(from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return true;
              }
              return false;
            }
            doBuildFrom(value2, from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return value2.setConversion((raw) => {
                    var _a;
                    try {
                      return (_a = JSON.parse(raw, (_, x) => x !== null && x !== void 0 ? x : clean_results_1.JSON_NIL)) !== null && _a !== void 0 ? _a : clean_results_1.JSON_NIL;
                    } catch (e) {
                      throw new interfaces_1.QueryError({
                        error: `invalid input syntax for type json`,
                        details: (0, utils_1.errorMessage)(e),
                        code: "22P02"
                      });
                    }
                  }, (toJsonb) => ({ toJsonb }));
              }
              return null;
            }
            doEquals(a, b) {
              return (0, utils_1.deepEqual)(this.toResult(a), this.toResult(b), false);
            }
            doGt(a, b) {
              return (0, utils_1.deepCompare)(this.toResult(a), this.toResult(b)) > 0;
            }
            doLt(a, b) {
              return (0, utils_1.deepCompare)(this.toResult(a), this.toResult(b)) < 0;
            }
            toResult(result) {
              return result === clean_results_1.JSON_NIL ? null : result;
            }
          }
          exports2.JSONBType = JSONBType;
        },
        /* 46 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.RegTypeImpl = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatype_base_1 = __webpack_require__(9);
          const datatypes_1 = __webpack_require__(14);
          const context_1 = __webpack_require__(4);
          class RegTypeImpl extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_private_1.DataType.regtype;
            }
            doCanCast(_to) {
              switch (_to.primary) {
                case interfaces_private_1.DataType.text:
                case interfaces_private_1.DataType.integer:
                  return true;
              }
              return null;
            }
            doCast(a, to) {
              switch (to.primary) {
                case interfaces_private_1.DataType.text:
                  return a.setType(to).setConversion((raw) => raw.toString(10), (toText) => ({ toText }));
                case interfaces_private_1.DataType.integer:
                  const { schema: schema2 } = (0, context_1.buildCtx)();
                  return a.setType(to).setConversion((raw) => {
                    if (typeof raw === "number") {
                      return raw;
                    }
                    const t2 = schema2.parseType(raw);
                    return t2.reg.typeId;
                  }, (toText) => ({ toText }));
              }
              throw new Error("failed to cast");
            }
            doCanBuildFrom(from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return true;
              }
              return false;
            }
            doBuildFrom(value2, from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  const { schema: schema2 } = (0, context_1.buildCtx)();
                  return value2.setType(datatypes_1.Types.regtype).setConversion((str) => {
                    let repl = str.replace(/["\s]+/g, "");
                    if (repl.startsWith("pg_catalog.")) {
                      repl = repl.substr("pg_catalog.".length);
                    }
                    return schema2.parseType(repl).name;
                  }, (strToRegType) => ({ strToRegType }));
              }
              return null;
            }
          }
          exports2.RegTypeImpl = RegTypeImpl;
        },
        /* 47 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.RegClassImpl = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatype_base_1 = __webpack_require__(9);
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(14);
          const context_1 = __webpack_require__(4);
          class RegClassImpl extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_private_1.DataType.regclass;
            }
            doCanCast(_to) {
              switch (_to.primary) {
                case interfaces_private_1.DataType.text:
                case interfaces_private_1.DataType.integer:
                  return true;
              }
              return null;
            }
            doCast(a, to) {
              const { schema: schema2 } = (0, context_1.buildCtx)();
              switch (to.primary) {
                case interfaces_private_1.DataType.text:
                  return a.setType(datatypes_1.Types.text()).setConversion((raw) => {
                    return raw === null || raw === void 0 ? void 0 : raw.toString();
                  }, (toText) => ({ toText }));
                case interfaces_private_1.DataType.integer:
                  return a.setType(datatypes_1.Types.text()).setConversion((raw) => {
                    var _a, _b;
                    const cls = (0, utils_1.parseRegClass)(raw);
                    if (typeof cls === "number") {
                      return (_b = (_a = schema2.getObjectByRegOrName(cls)) === null || _a === void 0 ? void 0 : _a.reg.classId) !== null && _b !== void 0 ? _b : cls;
                    }
                    return schema2.getObjectByRegOrName(raw).reg.classId;
                  }, (toText) => ({ toText }));
              }
              throw new Error("failed to cast");
            }
            doCanBuildFrom(from) {
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return true;
              }
              return false;
            }
            doBuildFrom(value2, from) {
              const { schema: schema2 } = (0, context_1.buildCtx)();
              switch (from.primary) {
                case interfaces_private_1.DataType.text:
                  return value2.setConversion((str) => {
                    var _a, _b;
                    const cls = (0, utils_1.parseRegClass)(str);
                    if (typeof cls === "number") {
                      return (_b = (_a = schema2.getObjectByRegOrName(cls)) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : cls;
                    }
                    return schema2.getObject(cls).name;
                  }, (strToRegClass) => ({ strToRegClass }));
              }
              return null;
            }
          }
          exports2.RegClassImpl = RegClassImpl;
        },
        /* 48 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.INetType = void 0;
          const datatype_base_1 = __webpack_require__(9);
          const interfaces_1 = __webpack_require__(3);
          class INetType extends datatype_base_1.TypeBase {
            get primary() {
              return interfaces_1.DataType.inet;
            }
            doCanCast(to) {
              return to.primary === interfaces_1.DataType.text;
            }
            doCast(value2, to) {
              return value2;
            }
            prefer(type) {
              return this;
            }
            doCanBuildFrom(from) {
              return from.primary === interfaces_1.DataType.text;
            }
            doBuildFrom(value2, from) {
              return value2.setConversion((x) => {
                var _a;
                const [_, a, b, c, d, __, m] = (_a = /^(\d+)\.(\d+)\.(\d+)\.(\d+)(\/(\d+))?$/.exec(x)) !== null && _a !== void 0 ? _a : [];
                if ([a, b, c, d].some(notByte) || notMask(m)) {
                  throw new interfaces_1.QueryError(`invalid input syntax for type inet: ${x}`);
                }
                return x;
              }, (toInet) => ({ toInet }));
            }
          }
          exports2.INetType = INetType;
          function notByte(b) {
            return !b || b.length > 1 && b[0] === "0" || parseInt(b, 10) > 255;
          }
          function notMask(b) {
            return b && (b.length > 1 && b[0] === "0" || parseInt(b, 10) > 32);
          }
        },
        /* 49 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.MemoryTable = void 0;
          const interfaces_1 = __webpack_require__(3);
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const btree_index_1 = __webpack_require__(63);
          const selection_1 = __webpack_require__(10);
          const utils_1 = __webpack_require__(1);
          const immutable_1 = __webpack_require__(16);
          const column_1 = __webpack_require__(65);
          const alias_1 = __webpack_require__(25);
          const transform_base_1 = __webpack_require__(5);
          const foreign_key_1 = __webpack_require__(67);
          const datatypes_1 = __webpack_require__(2);
          const context_1 = __webpack_require__(4);
          const subscription_1 = __webpack_require__(68);
          const wrapped_1 = __webpack_require__(69);
          const index_cst_1 = __webpack_require__(30);
          class ColumnManager {
            constructor() {
              this.map = /* @__PURE__ */ new Map();
              this.get = this.map.get.bind(this.map);
              this.has = this.map.has.bind(this.map);
              this.values = this.map.values.bind(this.map);
            }
            get columns() {
              if (!this._columns) {
                this._columns = Object.freeze(Array.from(this.map.values(), (c) => c.expression));
              }
              return this._columns;
            }
            invalidateColumns() {
              this._columns = void 0;
            }
            set(name, colDef) {
              this.invalidateColumns();
              return this.map.set(name, colDef);
            }
            delete(name) {
              this.invalidateColumns();
              return this.map.delete(name);
            }
          }
          class MemoryTable extends transform_base_1.DataSourceBase {
            constructor(schema2, t2, _schema) {
              var _a;
              super(schema2);
              this.handlers = /* @__PURE__ */ new Map();
              this.it = 0;
              this.cstGen = 0;
              this.hasPrimary = null;
              this.readonly = false;
              this.hidden = false;
              this.dataId = Symbol();
              this.serialsId = Symbol();
              this.constraintsByName = /* @__PURE__ */ new Map();
              this.indexByHashAndName = /* @__PURE__ */ new Map();
              this.columnMgr = new ColumnManager();
              this.changeHandlers = /* @__PURE__ */ new Map();
              this.truncateHandlers = /* @__PURE__ */ new Set();
              this.drophandlers = /* @__PURE__ */ new Set();
              this.indexHandlers = /* @__PURE__ */ new Set();
              this.name = _schema.name;
              this.selection = (0, alias_1.buildAlias)(this, this.name);
              for (const s of _schema.fields) {
                this.addColumn(s, t2);
              }
              for (const c of (_a = _schema.constraints) !== null && _a !== void 0 ? _a : []) {
                this.addConstraint(c, t2);
              }
            }
            get isExecutionWithNoResult() {
              return false;
            }
            get reg() {
              if (!this._reg) {
                throw new interfaces_1.QueryError(`relation "${this.name}" does not exist`);
              }
              return this._reg;
            }
            get columns() {
              return this.columnMgr.columns;
            }
            get type() {
              return "table";
            }
            get debugId() {
              return this.name;
            }
            entropy(t2) {
              return this.bin(t2).size;
            }
            isOriginOf(a) {
              return a.origin === this.selection;
            }
            register() {
              this._reg = this.ownerSchema._reg_register(this);
              return this;
            }
            stats(t2) {
              return {
                count: this.bin(t2).size
              };
            }
            rename(name) {
              const on = this.name;
              if (on === name) {
                return this;
              }
              this.name = name;
              this.ownerSchema._reg_rename(this, on, name);
              this.selection.name = this.name;
              this.db.onSchemaChange();
              return this;
            }
            getColumn(column, nullIfNotFound) {
              var _a;
              return (_a = (0, utils_1.colByName)(this.columnMgr.map, column, nullIfNotFound)) === null || _a === void 0 ? void 0 : _a.expression;
            }
            explain(e) {
              return {
                _: "table",
                table: this.name
              };
            }
            addColumn(column, t2) {
              var _a, _b;
              if ("dataType" in column) {
                const tp = {
                  ...column,
                  name: column.name.name,
                  type: this.ownerSchema.getType(column.dataType)
                };
                delete tp.dataType;
                return this.addColumn(tp, t2);
              }
              if (this.columnMgr.has(column.name)) {
                throw new interfaces_1.QueryError(`Column "${column.name}" already exists`);
              }
              const type = typeof column.type === "string" ? this.ownerSchema.getType(column.type) : column.type;
              const cref = new column_1.ColRef(this, (0, selection_1.columnEvaluator)(this.selection, column.name, type), column, column.name);
              if (column.serial) {
                t2.set(this.serialsId, t2.getMap(this.serialsId).set(column.name, 0));
              }
              this.columnMgr.set(column.name, cref);
              try {
                if ((_a = column.constraints) === null || _a === void 0 ? void 0 : _a.length) {
                  cref.addConstraints(column.constraints, t2);
                }
                const hasDefault = (_b = column.constraints) === null || _b === void 0 ? void 0 : _b.some((x) => x.type === "default");
                if (!hasDefault) {
                  this.remapData(t2, (x) => {
                    var _a2;
                    return x[column.name] = (_a2 = x[column.name]) !== null && _a2 !== void 0 ? _a2 : null;
                  });
                }
              } catch (e) {
                this.columnMgr.delete(column.name);
                throw e;
              }
              this.db.onSchemaChange();
              this.selection.rebuild();
              return cref;
            }
            getColumnRef(column, nullIfNotFound) {
              const got = this.columnMgr.get(column);
              if (!got) {
                if (nullIfNotFound) {
                  return null;
                }
                throw new interfaces_1.QueryError(`Column "${column}" not found`);
              }
              return got;
            }
            bin(t2) {
              return t2.getMap(this.dataId);
            }
            setBin(t2, val) {
              return t2.set(this.dataId, val);
            }
            on(event, handler) {
              let lst = this.handlers.get(event);
              if (!lst) {
                this.handlers.set(event, lst = /* @__PURE__ */ new Set());
              }
              lst.add(handler);
              return {
                unsubscribe: () => lst.delete(handler)
              };
            }
            raise(event) {
              const got = this.handlers.get(event);
              for (const h of got !== null && got !== void 0 ? got : []) {
                h();
              }
              this.db.raiseTable(this.name, event);
            }
            setReadonly() {
              this.readonly = true;
              return this;
            }
            setHidden() {
              this.hidden = true;
              return this;
            }
            *enumerate(t2) {
              this.raise("seq-scan");
              for (const v of this.bin(t2).values()) {
                yield (0, utils_1.deepCloneSimple)(v);
              }
            }
            find(template, columns) {
              return (0, utils_1.findTemplate)(this.selection, this.db.data, template, columns);
            }
            remapData(t2, modify) {
              const converted = this.bin(t2).map((x) => {
                const copy2 = { ...x };
                modify(copy2);
                return copy2;
              });
              this.setBin(t2, converted);
            }
            insert(toInsert) {
              const ret = this.doInsert(this.db.data, (0, utils_1.deepCloneSimple)(toInsert));
              if (ret == null) {
                return null;
              }
              return (0, utils_1.deepCloneSimple)(ret);
            }
            doInsert(t2, toInsert, opts) {
              if (this.readonly) {
                throw new interfaces_1.PermissionDeniedError(this.name);
              }
              const newId = this.name + "_" + this.it++;
              (0, interfaces_private_1.setId)(toInsert, newId);
              let serials = t2.getMap(this.serialsId);
              for (const [k, v] of serials.entries()) {
                if (!(0, utils_1.nullIsh)(toInsert[k])) {
                  continue;
                }
                toInsert[k] = v + 1;
                serials = serials.set(k, v + 1);
              }
              t2.set(this.serialsId, serials);
              for (const c of this.columnMgr.values()) {
                c.setDefaults(toInsert, t2);
              }
              const changePlan = this.changePlan(t2, null, toInsert, opts);
              changePlan.before();
              const onConflict = opts === null || opts === void 0 ? void 0 : opts.onConflict;
              if (onConflict) {
                if ("ignore" in onConflict) {
                  if (onConflict.ignore === "all") {
                    for (const map2 of this.indexByHashAndName.values()) {
                      for (const k of map2.values()) {
                        if (!k.index.unique) {
                          continue;
                        }
                        const key = k.index.buildKey(toInsert, t2);
                        const found = k.index.eqFirst(key, t2);
                        if (found) {
                          return null;
                        }
                      }
                    }
                  } else {
                    const index = onConflict.ignore;
                    const key = index.buildKey(toInsert, t2);
                    const found = index.eqFirst(key, t2);
                    if (found) {
                      return found;
                    }
                  }
                } else {
                  const index = onConflict.onIndex;
                  const key = index.buildKey(toInsert, t2);
                  const got = index.eqFirst(key, t2);
                  if (got) {
                    onConflict.update(got, toInsert, t2);
                    return this.update(t2, got);
                  }
                }
              }
              for (const c of this.columnMgr.values()) {
                c.checkConstraints(toInsert, t2);
              }
              changePlan.after();
              this.indexElt(t2, toInsert);
              this.setBin(t2, this.bin(t2).set(newId, toInsert));
              return toInsert;
            }
            changePlan(t2, old, neu, _opts) {
              const opts = _opts !== null && _opts !== void 0 ? _opts : {};
              let iter;
              if (!old || !neu) {
                iter = () => this.changeHandlers.values();
              } else {
                const ret = [];
                const global = this.changeHandlers.get(null);
                if (global) {
                  ret.push(global);
                }
                for (const def of this.columnMgr.values()) {
                  const h = this.changeHandlers.get(def);
                  if (!h) {
                    continue;
                  }
                  const oldVal = old[def.expression.id];
                  const neuVal = neu[def.expression.id];
                  if (def.expression.type.equals(oldVal, neuVal)) {
                    continue;
                  }
                  ret.push(h);
                }
                iter = ret[Symbol.iterator].bind(ret);
              }
              return {
                before: () => {
                  const ran = /* @__PURE__ */ new Set();
                  for (const { before } of iter()) {
                    for (const b of before) {
                      if (!b || ran.has(b)) {
                        continue;
                      }
                      b(old, neu, t2, opts);
                      ran.add(b);
                    }
                  }
                },
                after: () => {
                  const ran = /* @__PURE__ */ new Set();
                  for (const { after } of iter()) {
                    for (const a of after) {
                      if (!a || ran.has(a)) {
                        continue;
                      }
                      a(old, neu, t2, opts);
                      ran.add(a);
                    }
                  }
                }
              };
            }
            update(t2, toUpdate) {
              var _a;
              if (this.readonly) {
                throw new interfaces_1.PermissionDeniedError(this.name);
              }
              const bin = this.bin(t2);
              const id = (0, interfaces_private_1.getId)(toUpdate);
              const exists = (_a = bin.get(id)) !== null && _a !== void 0 ? _a : null;
              for (const c of this.columnMgr.values()) {
                c.setDefaults(toUpdate, t2);
              }
              const changePlan = this.changePlan(t2, exists, toUpdate, null);
              changePlan.before();
              changePlan.after();
              for (const c of this.columnMgr.values()) {
                c.checkConstraints(toUpdate, t2);
              }
              if (exists) {
                for (const map2 of this.indexByHashAndName.values()) {
                  for (const k of map2.values()) {
                    k.index.delete(exists, t2);
                  }
                }
              }
              this.indexElt(t2, toUpdate);
              this.setBin(t2, bin.delete(id).set(id, toUpdate));
              return toUpdate;
            }
            delete(t2, toDelete) {
              const id = (0, interfaces_private_1.getId)(toDelete);
              const bin = this.bin(t2);
              const got = bin.get(id);
              if (!id || !got) {
                throw new Error("Unexpected error: an operation has been asked on an item which does not belong to this table");
              }
              const changePlan = this.changePlan(t2, toDelete, null, null);
              changePlan.before();
              changePlan.after();
              for (const map2 of this.indexByHashAndName.values()) {
                for (const k of map2.values()) {
                  k.index.delete(got, t2);
                }
              }
              this.setBin(t2, bin.delete(id));
              return got;
            }
            truncate(t2, _opts) {
              const opts = _opts !== null && _opts !== void 0 ? _opts : {};
              for (const h of this.truncateHandlers) {
                h(t2, opts);
              }
              for (const map2 of this.indexByHashAndName.values()) {
                for (const k of map2.values()) {
                  k.index.truncate(t2);
                }
              }
              this.setBin(t2, (0, immutable_1.Map)());
            }
            indexElt(t2, toInsert) {
              for (const map2 of this.indexByHashAndName.values()) {
                for (const k of map2.values()) {
                  k.index.add(toInsert, t2);
                }
              }
            }
            hasItem(item, t2) {
              const id = (0, interfaces_private_1.getId)(item);
              return this.bin(t2).has(id);
            }
            getIndex(...forValues) {
              var _a, _b;
              if (!forValues.length || forValues.some((x) => !x || !this.isOriginOf(x))) {
                return null;
              }
              const ihash = (0, utils_1.indexHash)(forValues);
              if (((_a = this.hasPrimary) === null || _a === void 0 ? void 0 : _a.hash) === ihash) {
                return this.hasPrimary;
              }
              const map2 = this.indexByHashAndName.get(ihash);
              const got = map2 === null || map2 === void 0 ? void 0 : map2.values().next().value;
              return (_b = got === null || got === void 0 ? void 0 : got.index) !== null && _b !== void 0 ? _b : null;
            }
            constraintNameGen(constraintName) {
              return constraintName !== null && constraintName !== void 0 ? constraintName : this.name + "_constraint_" + ++this.cstGen;
            }
            addCheck(_t, check, constraintName) {
              constraintName = this.constraintNameGen(constraintName);
              this.checkNoConstraint(constraintName);
              const getter = (0, context_1.withSelection)(this.selection, () => (0, expression_builder_1.buildValue)(check).cast(datatypes_1.Types.bool));
              const checkVal = (t2, v) => {
                const value2 = getter.get(v, t2);
                if (value2 === false) {
                  throw new interfaces_1.QueryError(`check constraint "${constraintName}" is violated by some row`);
                }
              };
              for (const v of this.enumerate(_t)) {
                checkVal(_t, v);
              }
              const sub = this.onBeforeChange("all", (old, neu, ct) => {
                if (!neu) {
                  return;
                }
                checkVal(ct, neu);
              });
              const ret = new subscription_1.SubscriptionConstraint(constraintName, () => sub.unsubscribe());
              return new wrapped_1.ConstraintWrapper(this.constraintsByName, ret);
            }
            createIndex(t2, expressions, _type, _indexName) {
              var _a;
              if (this.readonly) {
                throw new interfaces_1.PermissionDeniedError(this.name);
              }
              if (!_indexName && _type === "primary") {
                _indexName = `${this.name}_pkey`;
              }
              if (Array.isArray(expressions)) {
                const keys2 = [];
                for (const e of expressions) {
                  const getter = this.selection.getColumn(e.name);
                  keys2.push({
                    value: getter
                  });
                }
                return this.createIndex(t2, {
                  columns: keys2,
                  primary: _type === "primary",
                  notNull: _type === "primary",
                  unique: !!_type,
                  indexName: _indexName
                });
              }
              if (!((_a = expressions === null || expressions === void 0 ? void 0 : expressions.columns) === null || _a === void 0 ? void 0 : _a.length)) {
                throw new interfaces_1.QueryError("Empty index");
              }
              if (expressions.primary && this.hasPrimary) {
                throw new interfaces_1.QueryError("Table " + this.name + " already has a primary key");
              }
              if (expressions.primary) {
                expressions.notNull = true;
                expressions.unique = true;
              }
              const ihash = (0, utils_1.indexHash)(expressions.columns.map((x) => x.value));
              const indexName = this.determineIndexRelName(expressions.indexName, ihash, expressions.ifNotExists, "idx");
              if (!indexName) {
                return null;
              }
              this.checkNoConstraint(indexName);
              const index = new btree_index_1.BIndex(t2, indexName, expressions.columns, this, ihash, !!expressions.unique, !!expressions.notNull, expressions.predicate);
              const bin = this.bin(t2);
              for (const e of bin.values()) {
                index.add(e, t2);
              }
              this.indexHandlers.forEach((h) => h("create", index));
              for (const col of index.expressions) {
                for (const used of col.usedColumns) {
                  this.getColumnRef(used.id).usedInIndexes.add(index);
                }
              }
              const indexesByHash = this.indexByHashAndName.get(ihash) || /* @__PURE__ */ new Map();
              indexesByHash.set(indexName, { index, expressions: index.expressions });
              this.indexByHashAndName.set(ihash, indexesByHash);
              if (expressions.primary) {
                this.hasPrimary = index;
              }
              const ret = new index_cst_1.IndexConstraint(indexName, index, this);
              this.constraintsByName.set(indexName, ret);
              return ret;
            }
            determineIndexRelName(indexName, ihash, ifNotExists, sufix) {
              if (indexName) {
                if (this.ownerSchema.getOwnObject(indexName)) {
                  if (ifNotExists) {
                    return null;
                  }
                  throw new interfaces_1.QueryError(`relation "${indexName}" already exists`);
                }
                return indexName;
              } else {
                const baseName = indexName = `${this.name}_${ihash}_${sufix}`;
                let i = 1;
                while (this.ownerSchema.getOwnObject(indexName)) {
                  indexName = baseName + i++;
                }
                return indexName;
              }
            }
            dropIndex(t2, uName) {
              var _a, _b, _c;
              const u = (0, interfaces_private_1.asIndex)(this.ownerSchema.getOwnObject(uName));
              if (!u || !this.indexByHashAndName.has(u.hash) || !((_a = this.indexByHashAndName.get(u.hash)) === null || _a === void 0 ? void 0 : _a.has(uName))) {
                throw new interfaces_1.QueryError("Cannot drop index that does not belong to this table: " + uName);
              }
              this.indexHandlers.forEach((h) => h("drop", u));
              (_b = this.indexByHashAndName.get(u.hash)) === null || _b === void 0 ? void 0 : _b.delete(uName);
              if (((_c = this.indexByHashAndName.get(u.hash)) === null || _c === void 0 ? void 0 : _c.size) == 0) {
                this.indexByHashAndName.delete(u.hash);
              }
              u.dropFromData(t2);
              this.ownerSchema._reg_unregister(u);
              this.constraintsByName.delete(uName);
              if (this.hasPrimary === u) {
                this.hasPrimary = null;
              }
              for (const col of u.expressions) {
                for (const used of col.usedColumns) {
                  this.getColumnRef(used.id).usedInIndexes.delete(u);
                }
              }
            }
            onIndex(sub) {
              this.indexHandlers.add(sub);
              return {
                unsubscribe: () => this.indexHandlers.delete(sub)
              };
            }
            listIndices() {
              return [].concat(...[...this.indexByHashAndName.values()].map((indexMap) => [...indexMap.values()].map((x) => ({
                name: x.index.name,
                expressions: x.expressions.map((x2) => x2.id)
              }))));
            }
            get primaryIndex() {
              return this.hasPrimary && {
                name: this.hasPrimary.name,
                expressions: this.hasPrimary.expressions.map((x) => x.id)
              };
            }
            addForeignKey(cst, t2) {
              var _a;
              const ihash = (0, utils_1.indexHash)(cst.localColumns.map((x) => x.name));
              const constraintName = this.determineIndexRelName((_a = cst.constraintName) === null || _a === void 0 ? void 0 : _a.name, ihash, false, "fk");
              if (!constraintName) {
                return null;
              }
              const ret = new foreign_key_1.ForeignKey(constraintName).install(t2, cst, this);
              return new wrapped_1.ConstraintWrapper(this.constraintsByName, ret);
            }
            getConstraint(constraint) {
              return this.constraintsByName.get(constraint);
            }
            addConstraint(cst, t2) {
              var _a, _b, _c;
              switch (cst.type) {
                case "foreign key":
                  return this.addForeignKey(cst, t2);
                case "primary key":
                  return this.createIndex(t2, cst.columns, "primary", (_a = cst.constraintName) === null || _a === void 0 ? void 0 : _a.name);
                case "unique":
                  return this.createIndex(t2, cst.columns, "unique", (_b = cst.constraintName) === null || _b === void 0 ? void 0 : _b.name);
                case "check":
                  return this.addCheck(t2, cst.expr, (_c = cst.constraintName) === null || _c === void 0 ? void 0 : _c.name);
                default:
                  throw interfaces_1.NotSupported.never(cst, "constraint type");
              }
            }
            checkNoConstraint(name) {
              if (this.constraintsByName.has(name)) {
                throw new interfaces_1.QueryError(`relation "${name}" already exists`, "42P07");
              }
            }
            onBeforeChange(columns, check) {
              return this._subChange("before", columns, check);
            }
            onCheckChange(columns, check) {
              return this._subChange("before", columns, check);
            }
            *getColumns() {
              for (const c of this.columns) {
                yield {
                  name: c.id,
                  type: c.type,
                  nullable: !this.columnMgr.get(c.id).notNull
                };
              }
            }
            _subChange(key, columns, check) {
              const unsubs = [];
              const add = (ref) => {
                let ch = this.changeHandlers.get(ref);
                if (!ch) {
                  this.changeHandlers.set(ref, ch = {
                    after: /* @__PURE__ */ new Set(),
                    before: /* @__PURE__ */ new Set()
                  });
                }
                ch[key].add(check);
                unsubs.push(() => ch[key].delete(check));
              };
              if (columns === "all") {
                add(null);
              } else {
                for (const c of columns) {
                  const ref = typeof c === "string" ? this.getColumnRef(c) : c;
                  add(ref);
                }
              }
              return {
                unsubscribe: () => {
                  for (const u of unsubs) {
                    u();
                  }
                }
              };
            }
            drop(t2, cascade) {
              this.drophandlers.forEach((d) => d(t2, cascade));
              t2.delete(this.dataId);
              for (const map2 of this.indexByHashAndName.values()) {
                for (const i of map2.values()) {
                  i.index.dropFromData(t2);
                }
              }
              return this.ownerSchema._reg_unregister(this);
            }
            onDrop(sub) {
              this.drophandlers.add(sub);
              return {
                unsubscribe: () => {
                  this.drophandlers.delete(sub);
                }
              };
            }
            onTruncate(sub) {
              this.truncateHandlers.add(sub);
              return {
                unsubscribe: () => {
                  this.truncateHandlers.delete(sub);
                }
              };
            }
          }
          exports2.MemoryTable = MemoryTable;
        },
        /* 50 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.RestrictiveIndex = void 0;
          class RestrictiveIndex {
            constructor(base, filter3) {
              this.base = base;
              this.filter = filter3;
            }
            match(raw, t2) {
              return this.filter.hasItem(raw, t2);
            }
            get expressions() {
              return this.base.expressions;
            }
            stats(t2, key) {
              return null;
            }
            iterateKeys() {
              return null;
            }
            eqFirst(rawKey, t2) {
              for (const i of this.base.enumerate({
                key: rawKey,
                t: t2,
                type: "eq"
              })) {
                if (this.match(i, t2)) {
                  return i;
                }
              }
              return null;
            }
            entropy(t2) {
              return this.base.entropy(t2);
            }
            *enumerate(op) {
              for (const i of this.base.enumerate(op)) {
                if (this.match(i, op.t)) {
                  yield i;
                }
              }
            }
            explain(e) {
              return {
                _: "indexRestriction",
                lookup: this.base.explain(e),
                for: this.filter.explain(e)
                // criteria: this.restrict.explain(e),
              };
            }
          }
          exports2.RestrictiveIndex = RestrictiveIndex;
        },
        /* 51 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildCount = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const context_1 = __webpack_require__(4);
          function buildCount(base, call) {
            return (0, context_1.withSelection)(base, () => {
              const args = call.args;
              if ((0, utils_1.isSelectAllArgList)(args)) {
                return new CountStar(base);
              }
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError("COUNT expects one argument, given " + args.length);
              }
              const what = (0, expression_builder_1.buildValue)(args[0]);
              return new CountExpr(what);
            });
          }
          exports2.buildCount = buildCount;
          class CountStar {
            constructor(on) {
              this.on = on;
            }
            get type() {
              return datatypes_1.Types.bigint;
            }
            computeFromIndex(key, index, t2) {
              const stats = index.stats(t2, key);
              return stats === null || stats === void 0 ? void 0 : stats.count;
            }
            computeNoGroup(t2) {
              var _a;
              return (_a = this.on.stats(t2)) === null || _a === void 0 ? void 0 : _a.count;
            }
            createGroup() {
              let cnt = 0;
              return {
                feedItem: () => cnt++,
                finish: () => cnt
              };
            }
          }
          class CountExpr {
            constructor(exp) {
              this.exp = exp;
            }
            get type() {
              return datatypes_1.Types.bigint;
            }
            createGroup(t2) {
              let cnt = 0;
              return {
                feedItem: (item) => {
                  const value2 = this.exp.get(item, t2);
                  if (!(0, utils_1.nullIsh)(value2)) {
                    cnt++;
                  }
                },
                finish: () => cnt
              };
            }
          }
        },
        /* 52 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildMinMax = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const utils_1 = __webpack_require__(1);
          const interfaces_1 = __webpack_require__(3);
          const context_1 = __webpack_require__(4);
          class MinMax {
            constructor(exp, isMax) {
              this.exp = exp;
              this.isMax = isMax;
            }
            get type() {
              return this.exp.type;
            }
            createGroup(t2) {
              let val = null;
              return {
                feedItem: (item) => {
                  const value2 = this.exp.get(item, t2);
                  if (!(0, utils_1.nullIsh)(value2) && ((0, utils_1.nullIsh)(val) || (this.isMax ? val < value2 : val > value2))) {
                    val = value2;
                  }
                },
                finish: () => val
              };
            }
          }
          function buildMinMax(base, args, op) {
            return (0, context_1.withSelection)(base, () => {
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError(op.toUpperCase() + " expects one argument, given " + args.length);
              }
              const what = (0, expression_builder_1.buildValue)(args[0]);
              switch (what.type.primary) {
                case interfaces_1.DataType.bigint:
                case interfaces_1.DataType.integer:
                case interfaces_1.DataType.decimal:
                case interfaces_1.DataType.date:
                case interfaces_1.DataType.float:
                case interfaces_1.DataType.text:
                case interfaces_1.DataType.time:
                case interfaces_1.DataType.timetz:
                case interfaces_1.DataType.timestamp:
                case interfaces_1.DataType.timestamptz:
                  break;
                default:
                  throw new interfaces_private_1.QueryError(`function min(${what.type.primary}) does not exist`, "42883");
              }
              return new MinMax(what, op === "max");
            });
          }
          exports2.buildMinMax = buildMinMax;
        },
        /* 53 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildSum = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const utils_1 = __webpack_require__(1);
          const context_1 = __webpack_require__(4);
          class SumExpr {
            constructor(exp) {
              this.exp = exp;
            }
            get type() {
              return datatypes_1.Types.bigint;
            }
            createGroup(t2) {
              let val = null;
              return {
                feedItem: (item) => {
                  const value2 = this.exp.get(item, t2);
                  if (!(0, utils_1.nullIsh)(value2)) {
                    val = (0, utils_1.nullIsh)(val) ? value2 : val + value2;
                  }
                },
                finish: () => val
              };
            }
          }
          function buildSum(base, call) {
            return (0, context_1.withSelection)(base, () => {
              const args = call.args;
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError("SUM expects one argument, given " + args.length);
              }
              const what = (0, expression_builder_1.buildValue)(args[0]);
              return new SumExpr(what);
            });
          }
          exports2.buildSum = buildSum;
        },
        /* 54 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildArrayAgg = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const context_1 = __webpack_require__(4);
          class ArrayAggExpr {
            constructor(exp) {
              this.exp = exp;
            }
            get type() {
              return datatypes_1.Types.integer.asArray();
            }
            createGroup(t2) {
              let val = [];
              return {
                feedItem: (item) => {
                  const value2 = this.exp.get(item, t2);
                  val = [...val, value2];
                },
                finish: () => val
              };
            }
          }
          function buildArrayAgg(base, call) {
            return (0, context_1.withSelection)(base, () => {
              const args = call.args;
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError("ARRAY_AGG expects one argument, given " + args.length);
              }
              const what = (0, expression_builder_1.buildValue)(args[0]);
              return new ArrayAggExpr(what);
            });
          }
          exports2.buildArrayAgg = buildArrayAgg;
        },
        /* 55 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildAvg = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const utils_1 = __webpack_require__(1);
          const context_1 = __webpack_require__(4);
          class AvgExpr {
            constructor(exp) {
              this.exp = exp;
            }
            get type() {
              return datatypes_1.Types.bigint;
            }
            createGroup(t2) {
              let full = [];
              return {
                feedItem: (item) => {
                  const value2 = this.exp.get(item, t2);
                  if (!(0, utils_1.nullIsh)(value2)) {
                    full.push(value2);
                  }
                },
                finish: () => full.length === 0 ? null : (0, utils_1.sum)(full) / full.length
              };
            }
          }
          function buildAvg(base, call) {
            return (0, context_1.withSelection)(base, () => {
              const args = call.args;
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError("AVG expects one argument, given " + args.length);
              }
              const what = (0, expression_builder_1.buildValue)(args[0]);
              return new AvgExpr(what);
            });
          }
          exports2.buildAvg = buildAvg;
        },
        /* 56 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildJsonAgg = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const context_1 = __webpack_require__(4);
          const expression_builder_1 = __webpack_require__(6);
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(2);
          class JsonAggExpr {
            constructor(exp, type) {
              this.exp = exp;
              this.type = type;
            }
            createGroup(t2) {
              let full = [];
              return {
                feedItem: (item) => {
                  const value2 = this.exp.get(item, t2);
                  if (!(0, utils_1.nullIsh)(value2)) {
                    full.push(value2);
                  }
                },
                finish: () => full.length === 0 ? null : full
              };
            }
          }
          function buildJsonAgg(base, call, fn) {
            return (0, context_1.withSelection)(base, () => {
              const args = call.args;
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError(fn + " expects one argument, given " + args.length);
              }
              const type = fn === "json_agg" ? datatypes_1.Types.json : datatypes_1.Types.jsonb;
              const what = (0, expression_builder_1.buildValue)(args[0]);
              return new JsonAggExpr(what, type);
            });
          }
          exports2.buildJsonAgg = buildJsonAgg;
        },
        /* 57 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildBoolAgg = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const context_1 = __webpack_require__(4);
          const expression_builder_1 = __webpack_require__(6);
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(2);
          class BoolAgg {
            constructor(exp, isOr) {
              this.exp = exp;
              this.isOr = isOr;
            }
            get type() {
              return datatypes_1.Types.bool;
            }
            createGroup(t2) {
              let result = null;
              return {
                feedItem: (item) => {
                  if (result === this.isOr) {
                    return;
                  }
                  const value2 = this.exp.get(item, t2);
                  if ((0, utils_1.nullIsh)(value2)) {
                    return;
                  }
                  result = !!value2;
                },
                finish: () => result
              };
            }
          }
          function buildBoolAgg(base, call, fn) {
            return (0, context_1.withSelection)(base, () => {
              const args = call.args;
              if (args.length !== 1) {
                throw new interfaces_private_1.QueryError(fn + " expects one argument, given " + args.length);
              }
              const what = (0, expression_builder_1.buildValue)(args[0]).cast(datatypes_1.Types.bool);
              return new BoolAgg(what, fn === "bool_or");
            });
          }
          exports2.buildBoolAgg = buildBoolAgg;
        },
        /* 58 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Deletion = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const mutation_base_1 = __webpack_require__(20);
          const context_1 = __webpack_require__(4);
          class Deletion extends mutation_base_1.MutationDataSourceBase {
            constructor(ast) {
              const { schema: schema2 } = (0, context_1.buildCtx)();
              const table = (0, interfaces_private_1.asTable)(schema2.getObject(ast.from));
              const mutatedSel = table.selection.filter(ast.where);
              super(table, mutatedSel, ast);
            }
            performMutation(t2) {
              const rows = [];
              for (const item of this.mutatedSel.enumerate(t2)) {
                this.table.delete(t2, item);
                rows.push(item);
              }
              return rows;
            }
          }
          exports2.Deletion = Deletion;
        },
        /* 59 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Update = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const mutation_base_1 = __webpack_require__(20);
          const context_1 = __webpack_require__(4);
          const select_1 = __webpack_require__(12);
          const selection_1 = __webpack_require__(10);
          const join_1 = __webpack_require__(24);
          class Update extends mutation_base_1.MutationDataSourceBase {
            constructor(ast) {
              const { schema: schema2 } = (0, context_1.buildCtx)();
              const into = (0, interfaces_private_1.asTable)(schema2.getObject(ast.table));
              let mutatedSel;
              let fetchObjectToUpdate;
              if (ast.from) {
                mutatedSel = (0, select_1.buildSelect)({
                  type: "select",
                  // join from:
                  from: [
                    ast.from,
                    {
                      type: "table",
                      name: ast.table,
                      join: {
                        type: "INNER JOIN",
                        on: ast.where
                      }
                    }
                  ],
                  // // select the whole updated record
                  columns: [{
                    expr: {
                      type: "ref",
                      table: ast.table,
                      name: "*"
                    }
                  }]
                });
                if (!(mutatedSel instanceof selection_1.Selection)) {
                  throw new Error("Invalid select-from statement");
                }
                mutatedSel = mutatedSel.base;
                if (!(mutatedSel instanceof join_1.JoinSelection)) {
                  throw new Error("Invalid select-from statement");
                }
                fetchObjectToUpdate = (x) => x[">joined"];
              } else {
                mutatedSel = into.selection.filter(ast.where);
              }
              super(into, mutatedSel, ast);
              this.setter = (0, mutation_base_1.createSetter)(this.table, this.mutatedSel, ast.sets);
              this.fetchObjectToUpdate = fetchObjectToUpdate;
            }
            performMutation(t2) {
              const rows = [];
              for (const i of this.mutatedSel.enumerate(t2)) {
                const data = this.fetchObjectToUpdate ? this.fetchObjectToUpdate(i) : i;
                this.setter(t2, data, i);
                rows.push(this.table.update(t2, data));
              }
              return rows;
            }
          }
          exports2.Update = Update;
        },
        /* 60 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Insert = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const join_1 = __webpack_require__(24);
          const mutation_base_1 = __webpack_require__(20);
          const array_filter_1 = __webpack_require__(29);
          const context_1 = __webpack_require__(4);
          const select_1 = __webpack_require__(12);
          const index_cst_1 = __webpack_require__(30);
          class Insert extends mutation_base_1.MutationDataSourceBase {
            constructor(ast) {
              const { schema: schema2 } = (0, context_1.buildCtx)();
              const table = (0, interfaces_private_1.asTable)(schema2.getObject(ast.into));
              const selection = table.selection.setAlias(ast.into.alias);
              super(table, selection, ast);
              this.valueRawSource = ast.insert.type === "values" ? (0, select_1.buildValues)(ast.insert, true) : (0, select_1.buildSelect)(ast.insert);
              (0, context_1.withSelection)(this, () => this.visit(ast));
            }
            visit(ast) {
              var _a, _b;
              this.insertColumns = (_b = (_a = ast.columns) === null || _a === void 0 ? void 0 : _a.map((x) => x.name)) !== null && _b !== void 0 ? _b : this.table.selection.columns.map((x) => x.id).slice(0, this.valueRawSource.columns.length);
              if (this.valueRawSource.columns.length > this.insertColumns.length) {
                throw new interfaces_private_1.QueryError(`INSERT has more expressions than target columns`);
              }
              this.valueConvertedSource = this.insertColumns.map((col, i) => {
                const value2 = this.valueRawSource.columns[i];
                const insertInto = this.table.selection.getColumn(col);
                const canConvert = ast.insert.type === "values" ? value2.type.canCast(insertInto.type) : value2.type.canConvertImplicit(insertInto.type);
                if (!canConvert) {
                  throw new interfaces_private_1.QueryError(`column "${col}" is of type ${insertInto.type.name} but expression is of type ${value2.type.name}`);
                }
                return value2.type === datatypes_1.Types.default ? value2 : value2.cast(insertInto.type);
              });
              let ignoreConflicts = void 0;
              if (ast.onConflict) {
                let onIndex = null;
                const _on = ast.onConflict.on;
                switch (_on === null || _on === void 0 ? void 0 : _on.type) {
                  case "on expr":
                    const exprs = _on.exprs;
                    const on = (0, context_1.withSelection)(this.table.selection, () => exprs.map((x) => (0, expression_builder_1.buildValue)(x)));
                    onIndex = this.table.getIndex(...on);
                    break;
                  case "on constraint":
                    const cst = this.table.getConstraint(_on.constraint.name);
                    if (cst instanceof index_cst_1.IndexConstraint) {
                      onIndex = cst.index;
                    }
                    break;
                  case void 0:
                    break;
                  default:
                    throw interfaces_private_1.NotSupported.never(_on, 'unexpected "on conflict" type');
                }
                if (!!_on && !(onIndex === null || onIndex === void 0 ? void 0 : onIndex.unique)) {
                  throw new interfaces_private_1.QueryError(`There is no unique or exclusion constraint matching the ON CONFLICT specification`);
                }
                if (ast.onConflict.do === "do nothing") {
                  ignoreConflicts = { ignore: onIndex !== null && onIndex !== void 0 ? onIndex : "all" };
                } else {
                  if (!onIndex) {
                    throw new interfaces_private_1.QueryError(`ON CONFLICT DO UPDATE requires inference specification or constraint name`);
                  }
                  const subject = new join_1.JoinSelection(
                    this.mutatedSel,
                    new array_filter_1.ArrayFilter(this.table.selection, []).setAlias("excluded"),
                    {
                      type: "LEFT JOIN",
                      on: { type: "boolean", value: false }
                    },
                    false
                  );
                  const setter = (0, mutation_base_1.createSetter)(this.table, subject, ast.onConflict.do.sets);
                  const _where = ast.onConflict.where;
                  const where = _where && (0, context_1.withSelection)(subject, () => (0, expression_builder_1.buildValue)(_where));
                  ignoreConflicts = {
                    onIndex,
                    update: (item, excluded, t2) => {
                      const jitem = subject.buildItem(item, excluded);
                      if (where) {
                        const whereClause = where.get(jitem, t2);
                        if (whereClause !== true) {
                          return;
                        }
                      }
                      setter(t2, item, jitem);
                    }
                  };
                }
              }
              this.opts = {
                onConflict: ignoreConflicts,
                overriding: ast.overriding
              };
            }
            performMutation(t2) {
              const values2 = [];
              for (const o of this.valueRawSource.enumerate(t2)) {
                const nv = [];
                for (let i = 0; i < this.insertColumns.length; i++) {
                  const _custom = this.valueConvertedSource[i].get(o, t2);
                  nv.push(_custom);
                }
                values2.push(nv);
              }
              const ret = [];
              for (const val of values2) {
                if (val.length !== this.insertColumns.length) {
                  throw new interfaces_private_1.QueryError("Insert columns / values count mismatch");
                }
                const toInsert = {};
                for (let i = 0; i < val.length; i++) {
                  const v = val[i];
                  const col = this.valueConvertedSource[i];
                  if (col.type === datatypes_1.Types.default) {
                    continue;
                  }
                  toInsert[this.insertColumns[i]] = v;
                }
                const insertedRow = this.table.doInsert(t2, toInsert, this.opts);
                if (insertedRow) {
                  ret.push(insertedRow);
                }
              }
              return ret;
            }
          }
          exports2.Insert = Insert;
        },
        /* 61 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ValuesTable = void 0;
          const interfaces_1 = __webpack_require__(3);
          const interfaces_private_1 = __webpack_require__(0);
          const readonly_table_1 = __webpack_require__(8);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const context_1 = __webpack_require__(4);
          let cnt = 0;
          class ValuesTable extends readonly_table_1.ReadOnlyTable {
            constructor(alias, items, columnNames, acceptDefault) {
              super((0, context_1.buildCtx)().schema);
              this.symbol = Symbol();
              (0, context_1.withSelection)((0, context_1.buildCtx)().schema.dualTable.selection, () => {
                const len = new Set(items.map((x) => x.length));
                if (len.size !== 1) {
                  throw new interfaces_1.QueryError("VALUES lists must all be the same length");
                }
                if (columnNames && columnNames.length > items[0].length) {
                  throw new interfaces_1.QueryError(`table "${alias}" has ${items[0].length} columns available but ${columnNames.length} columns specified`);
                }
                let builtVals = items.map((vals) => vals.map((e) => {
                  if (acceptDefault && e.type === "default") {
                    return "default";
                  }
                  return (0, expression_builder_1.buildValue)(e);
                }));
                const types = items[0].map((_, i) => {
                  return preferedType(builtVals.map((x) => {
                    const v = x[i];
                    return v === "default" ? null : v.type;
                  }));
                });
                this._schema = {
                  name: alias,
                  fields: types.map((type, i) => {
                    var _a;
                    return {
                      type: type !== null && type !== void 0 ? type : datatypes_1.Types.default,
                      name: (_a = columnNames === null || columnNames === void 0 ? void 0 : columnNames[i]) !== null && _a !== void 0 ? _a : `column${i + 1}`
                    };
                  })
                };
                this.assignments = builtVals.map((vals) => vals.map((v, i) => v === "default" ? v : v.cast(types[i])));
              });
            }
            entropy(t2) {
              return 0;
            }
            enumerate(t2) {
              const ret = this.assignments.map((vals) => {
                const ret2 = { [this.symbol]: true };
                (0, interfaces_private_1.setId)(ret2, "vtbl" + ++cnt);
                for (let i = 0; i < vals.length; i++) {
                  const v = vals[i];
                  ret2[this._schema.fields[i].name] = v === "default" ? null : v.get({}, t2);
                }
                return ret2;
              });
              return ret;
            }
            hasItem(value2, t2) {
              return !!value2[this.symbol];
            }
          }
          exports2.ValuesTable = ValuesTable;
          function preferedType(types) {
            return types.reduce((a, b) => {
              if (!a) {
                return b;
              }
              if (!b) {
                return a;
              }
              const ret = a.prefer(b);
              if (!ret) {
                throw new interfaces_1.QueryError("Incompatible value types");
              }
              return ret;
            }, types[0]);
          }
        },
        /* 62 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.FunctionCallTable = void 0;
          const context_1 = __webpack_require__(4);
          const transform_base_1 = __webpack_require__(5);
          const selection_1 = __webpack_require__(10);
          const utils_1 = __webpack_require__(1);
          class FunctionCallTable extends transform_base_1.DataSourceBase {
            constructor(cols, evaluator) {
              super((0, context_1.buildCtx)().schema);
              this.evaluator = evaluator;
              this.symbol = Symbol();
              this.columns = cols.map((c) => (0, selection_1.columnEvaluator)(this, c.name, c.type).setOrigin(this));
              this.colsByName = (0, utils_1.fromEntries)(this.columns.map((c) => [c.id, c]));
            }
            get isExecutionWithNoResult() {
              return false;
            }
            entropy(t2) {
              return 0;
            }
            enumerate(t2) {
              const results = this.evaluator.get(null, t2);
              for (const result of results !== null && results !== void 0 ? results : []) {
                result[this.symbol] = true;
              }
              return results;
            }
            hasItem(value2, t2) {
              return !!value2[this.symbol];
            }
            getColumn(column, nullIfNotFound) {
              return (0, utils_1.colByName)(this.colsByName, column, nullIfNotFound);
            }
            getIndex(forValue) {
              return null;
            }
            isOriginOf(value2) {
              return value2.origin === this;
            }
            explain(e) {
              throw new Error("Method not implemented.");
            }
            stats(t2) {
              throw new Error("Method not implemented.");
            }
          }
          exports2.FunctionCallTable = FunctionCallTable;
        },
        /* 63 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.BIndex = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const functional_red_black_tree_1 = __importDefault(__webpack_require__(64));
          const interfaces_1 = __webpack_require__(3);
          const immutable_1 = __webpack_require__(16);
          const utils_1 = __webpack_require__(1);
          class BIndex {
            constructor(t2, name, cols, onTable, hash2, unique, notNull, predicate) {
              this.name = name;
              this.cols = cols;
              this.onTable = onTable;
              this.hash = hash2;
              this.unique = unique;
              this.notNull = notNull;
              this.predicate = predicate;
              this.treeBinId = Symbol();
              this.treeCountId = Symbol();
              this.reg = onTable.ownerSchema._reg_register(this);
              this.truncate(t2);
              this.expressions = cols.map((x) => x.value);
            }
            get type() {
              return "index";
            }
            get ownerSchema() {
              return this.onTable.ownerSchema;
            }
            drop(t2) {
              this.onTable.dropIndex(t2, this.name);
            }
            compare(_a, _b) {
              for (let i = 0; i < this.expressions.length; i++) {
                const k = this.cols[i];
                const a = _a[i];
                const b = _b[i];
                const an = (0, utils_1.nullIsh)(a);
                const bn = (0, utils_1.nullIsh)(b);
                if (an || bn) {
                  if (an === bn) {
                    continue;
                  }
                  return (an ? -1 : 1) * (k.nullsLast ? 1 : -1);
                }
                if (k.value.type.equals(a, b)) {
                  continue;
                }
                return k.value.type.gt(a, b) ? 1 : -1;
              }
              return 0;
            }
            buildKey(raw, t2) {
              return this.expressions.map((k) => k.get(raw, t2));
            }
            truncate(t2) {
              const asBinary = (0, functional_red_black_tree_1.default)((a, b) => {
                return this.compare(a, b);
              });
              this.setBin(t2, asBinary);
            }
            dropFromData(t2) {
              t2.delete(this.treeBinId);
            }
            bin(t2) {
              return t2.get(this.treeBinId);
            }
            setBin(t2, val) {
              return t2.set(this.treeBinId, val);
            }
            setCount(t2, val) {
              return t2.set(this.treeCountId, val);
            }
            getCount(t2) {
              var _c;
              return (_c = t2.get(this.treeCountId)) !== null && _c !== void 0 ? _c : 0;
            }
            hasKey(key, t2) {
              const it = this.bin(t2).find(key);
              return it.valid;
            }
            add(raw, t2) {
              if (this.predicate) {
                const val = this.predicate.get(raw, t2);
                if ((0, utils_1.nullIsh)(val) || val === false) {
                  return;
                }
              }
              const id = (0, interfaces_private_1.getId)(raw);
              const key = this.buildKey(raw, t2);
              const hasNil = (0, utils_1.hasNullish)(...key);
              if (this.notNull && hasNil) {
                throw new interfaces_1.QueryError("Cannot add a null record in index " + this.name);
              }
              if (this.unique && !hasNil && this.hasKey(key, t2)) {
                const idCols = this.cols.map((it) => it.value.id);
                throw new interfaces_1.QueryError({
                  error: `insert into "${this.onTable.name}" (${Object.keys(raw).join(", ")}) values (${Object.keys(raw).map((_, i) => `$${i + 1}`).join(", ")}) returning "${idCols}" - duplicate key value violates unique constraint "${this.onTable.name}_pkey"`,
                  details: `Key (${idCols})=(${key}) already exists.`,
                  code: "23505"
                });
              }
              let tree = this.bin(t2);
              let keyValues = tree.find(key);
              if (keyValues.valid) {
                if (keyValues.value.has(id)) {
                  return;
                }
                tree = keyValues.update(keyValues.value.set(id, raw));
              } else {
                tree = tree.insert(key, (0, immutable_1.Map)().set(id, raw));
              }
              this.setBin(t2, tree);
              this.setCount(t2, this.getCount(t2) + 1);
            }
            delete(raw, t2) {
              const key = this.buildKey(raw, t2);
              let tree = this.bin(t2);
              let keyValues = tree.find(key);
              if (!keyValues.valid) {
                return;
              }
              const id = (0, interfaces_private_1.getId)(raw);
              if (!keyValues.value.has(id)) {
                return;
              }
              const newKeyValues = keyValues.value.delete(id);
              if (!newKeyValues.size) {
                tree = keyValues.remove();
              } else {
                tree = keyValues.update(newKeyValues);
              }
              this.setBin(t2, tree);
              this.setCount(t2, this.getCount(t2) - 1);
            }
            eqFirst(rawKey, t2) {
              for (const r of this.eq(rawKey, t2, false)) {
                return (0, utils_1.deepCloneSimple)(r);
              }
              return null;
            }
            *nin(rawKey, t2) {
              rawKey.sort((a, b) => this.compare(a, b));
              const kit = rawKey[Symbol.iterator]();
              let cur = kit.next();
              const bin = this.bin(t2);
              let it = bin.begin;
              while (!cur.done) {
                while (it.valid && this.compare(it.key, cur.value) < 0) {
                  yield* it.value.values();
                  it.next();
                }
                if (this.compare(it.key, cur.value) === 0) {
                  it = bin.gt(cur.value);
                }
                cur = kit.next();
              }
              while (it.valid) {
                yield* it.value.values();
                it.next();
              }
            }
            entropy(op) {
              var _c;
              const bin = this.bin(op.t);
              if (!bin.length) {
                return 0;
              }
              const all = (_c = op.t.get(this.treeCountId)) !== null && _c !== void 0 ? _c : 0;
              const e = this._keyCount(op);
              return e * all / bin.length;
            }
            stats(t2, key) {
              var _c, _d;
              if (!key) {
                return {
                  count: (_c = t2.get(this.treeCountId)) !== null && _c !== void 0 ? _c : 0
                };
              }
              const found = this.bin(t2).get(key);
              return {
                count: (_d = found === null || found === void 0 ? void 0 : found.size) !== null && _d !== void 0 ? _d : 0
              };
            }
            iterateKeys(t2) {
              const bin = this.bin(t2);
              return bin.keys;
            }
            _keyCount(op) {
              const bin = this.bin(op.t);
              switch (op.type) {
                case "eq": {
                  const begin = bin.find(op.key);
                  if (!begin.valid) {
                    return 0;
                  }
                  const end = bin.gt(op.key);
                  if (!end.valid) {
                    return bin.length - begin.index;
                  }
                  return end.index - begin.index + 1;
                }
                case "neq": {
                  let cnt = 0;
                  const first3 = bin.find(op.key);
                  if (!first3.valid) {
                    return bin.length;
                  }
                  cnt += first3.valid ? first3.index : 0;
                  const end = bin.gt(op.key);
                  cnt += end.valid ? bin.length - end.index : 0;
                  return cnt;
                }
                case "ge": {
                  const found = bin.ge(op.key);
                  return found.valid ? bin.length - found.index : 0;
                }
                case "gt": {
                  const found = bin.gt(op.key);
                  return found.valid ? bin.length - found.index : 0;
                }
                case "le": {
                  const found = bin.gt(op.key);
                  return found.valid ? found.index : bin.length;
                }
                case "lt": {
                  const found = bin.ge(op.key);
                  return found.valid ? found.index : bin.length;
                }
                case "inside": {
                  const begin = bin.ge(op.lo);
                  if (!begin.valid) {
                    return 0;
                  }
                  const end = bin.gt(op.hi);
                  if (!end.valid) {
                    return bin.length - begin.index;
                  }
                  return end.index - begin.index;
                }
                case "outside": {
                  let cnt = 0;
                  const first3 = bin.lt(op.lo);
                  cnt += first3.valid ? first3.index + 1 : 0;
                  const end = bin.gt(op.hi);
                  cnt += end.valid ? bin.length - end.index : 0;
                  return cnt;
                }
                case "nin": {
                  let cnt = bin.length;
                  for (const e of op.keys) {
                    const f = bin.find(e);
                    if (f.valid) {
                      cnt--;
                    }
                  }
                  return cnt;
                }
                default:
                  throw interfaces_1.NotSupported.never(op["type"]);
              }
            }
            *enumerate(op) {
              for (const x of this._enumerate(op)) {
                yield (0, utils_1.deepCloneSimple)(x);
              }
            }
            _enumerate(op) {
              switch (op.type) {
                case "eq":
                  return this.eq(op.key, op.t, op.matchNull);
                case "neq":
                  return this.neq(op.key, op.t, op.matchNull);
                case "ge":
                  return this.ge(op.key, op.t);
                case "le":
                  return this.le(op.key, op.t);
                case "gt":
                  return this.gt(op.key, op.t);
                case "lt":
                  return this.lt(op.key, op.t);
                case "outside":
                  return this.outside(op.lo, op.hi, op.t);
                case "inside":
                  return this.inside(op.lo, op.hi, op.t);
                case "nin":
                  return this.nin(op.keys, op.t);
                default:
                  throw interfaces_1.NotSupported.never(op["type"]);
              }
            }
            *eq(key, t2, matchNull) {
              if (!matchNull && key.some(utils_1.nullIsh)) {
                return;
              }
              const it = this.bin(t2).find(key);
              while (it.valid && this.compare(it.key, key) === 0) {
                yield* it.value.values();
                it.next();
              }
            }
            *neq(key, t2, matchNull) {
              if (!matchNull && key.some(utils_1.nullIsh)) {
                return;
              }
              const bin = this.bin(t2);
              let it = bin.begin;
              while (it.valid && this.compare(it.key, key) < 0) {
                yield* it.value.values();
                it.next();
              }
              it = bin.gt(key);
              while (it.valid) {
                yield* it.value.values();
                it.next();
              }
            }
            *gt(key, t2) {
              const it = this.bin(t2).gt(key);
              while (it.valid) {
                yield* it.value.values();
                it.next();
              }
            }
            *ge(key, t2) {
              const it = this.bin(t2).ge(key);
              while (it.valid) {
                yield* it.value.values();
                it.next();
              }
            }
            *lt(key, t2) {
              const bin = this.bin(t2);
              const limit = bin.lt(key);
              const it = bin.begin;
              if (!limit.valid) {
                while (it.valid) {
                  yield* it.value.values();
                  it.next();
                }
                return;
              }
              while (it.valid && limit.index >= it.index) {
                yield* it.value.values();
                it.next();
              }
            }
            *le(key, t2) {
              const bin = this.bin(t2);
              const limit = bin.le(key);
              const it = bin.begin;
              if (!limit.valid) {
                while (it.valid) {
                  yield* it.value.values();
                  it.next();
                }
                return;
              }
              while (it.valid && limit.index >= it.index) {
                yield* it.value.values();
                it.next();
              }
            }
            *outside(lo, hi, t2) {
              yield* this.lt(lo, t2);
              yield* this.gt(hi, t2);
            }
            *inside(lo, hi, t2) {
              const it = this.bin(t2).ge(lo);
              while (it.valid && this.compare(it.key, hi) <= 0) {
                yield* it.value.values();
                it.next();
              }
            }
            explain(e) {
              return {
                _: "btree",
                onTable: this.onTable.name,
                btree: this.expressions.map((x) => x.id)
              };
            }
          }
          exports2.BIndex = BIndex;
        },
        /* 64 */
        /***/
        function(module3, exports2) {
          module3.exports = require_rbtree();
        },
        /* 65 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ColRef = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const selection_1 = __webpack_require__(10);
          const generated_1 = __webpack_require__(66);
          const expression_builder_1 = __webpack_require__(6);
          const context_1 = __webpack_require__(4);
          class ColRef {
            constructor(table, expression, _schema, name) {
              this.table = table;
              this.expression = expression;
              this.name = name;
              this.notNull = false;
              this.usedInIndexes = /* @__PURE__ */ new Set();
              this.drophandlers = /* @__PURE__ */ new Set();
            }
            addConstraints(clist, t2) {
              var _a, _b, _c;
              const notNull = clist.some((x) => x.type === "not null" || x.type === "primary key");
              const acceptNil = clist.some((x) => x.type === "null");
              if (notNull && acceptNil) {
                throw new interfaces_private_1.QueryError(`conflicting NULL/NOT NULL declarations for column "${this.name}" of table "${this.table.name}"`);
              }
              for (const c of clist) {
                const cname = c.constraintName;
                switch (c.type) {
                  case "not null":
                  case "null":
                    break;
                  case "primary key":
                    this.table.createIndex(t2, {
                      columns: [{ value: this.expression }],
                      primary: true,
                      // default constraint name:
                      indexName: (_a = cname === null || cname === void 0 ? void 0 : cname.name) !== null && _a !== void 0 ? _a : `${this.table.name}_pkey`
                    });
                    break;
                  case "unique":
                    this.table.createIndex(t2, {
                      columns: [{ value: this.expression }],
                      notNull,
                      unique: true,
                      // default constraint name:
                      indexName: (_b = cname === null || cname === void 0 ? void 0 : cname.name) !== null && _b !== void 0 ? _b : `${this.table.name}_${this.name}_key`
                    });
                    break;
                  case "default":
                    this.alter({
                      type: "set default",
                      default: c.default,
                      updateExisting: true
                    }, t2);
                    break;
                  case "check":
                    this.table.addCheck(t2, c.expr, cname === null || cname === void 0 ? void 0 : cname.name);
                    break;
                  case "add generated":
                    new generated_1.GeneratedIdentityConstraint((_c = c.constraintName) === null || _c === void 0 ? void 0 : _c.name, this).install(t2, c);
                    break;
                  case "reference":
                    this.table.addForeignKey({
                      ...c,
                      type: "foreign key",
                      localColumns: [{ name: this.name }]
                    }, t2);
                    break;
                  default:
                    throw interfaces_private_1.NotSupported.never(c, "add constraint type");
                }
              }
              if (notNull) {
                this.addNotNullConstraint(t2);
              }
              this.table.db.onSchemaChange();
              return this;
            }
            addNotNullConstraint(t2) {
              const bin = this.table.bin(t2);
              for (const e of bin.values()) {
                const val = this.expression.get(e, t2);
                if ((0, utils_1.nullIsh)(val)) {
                  throw new interfaces_private_1.QueryError(`Cannot add not null constraint on column "${this.expression.id}": it contains null values`);
                }
              }
              this.notNull = true;
              this.table.db.onSchemaChange();
            }
            rename(to, t2) {
              if (this.table.getColumnRef(to, true)) {
                throw new interfaces_private_1.QueryError(`Column "${to}" already exists`);
              }
              this.table.remapData(t2, (v) => {
                const ov = v[this.expression.id];
                delete v[this.expression.id];
                v[to] = ov;
              });
              this.replaceExpression(to, this.expression.type);
              this.table.db.onSchemaChange();
              this.table.selection.rebuild();
              this.name = to;
              return this;
            }
            alter(alter, t2) {
              var _a;
              switch (alter.type) {
                case "drop default":
                  this.default = null;
                  break;
                case "set default":
                  if (alter.default.type === "null") {
                    this.default = null;
                    break;
                  }
                  const df = (0, context_1.withSelection)(this.table.selection, () => (0, expression_builder_1.buildValue)(alter.default));
                  if (!df.isConstant) {
                    throw new interfaces_private_1.QueryError("cannot use column references in default expression");
                  }
                  if (alter.updateExisting) {
                    const defVal = df.get();
                    this.table.remapData(t2, (x) => x[this.expression.id] = defVal);
                  }
                  this.default = df;
                  break;
                case "set not null":
                  this.addNotNullConstraint(t2);
                  break;
                case "drop not null":
                  this.notNull = false;
                  break;
                case "set type":
                  const newType = this.table.ownerSchema.getType(alter.dataType);
                  const conv = this.expression.cast(newType);
                  const eid = this.expression.id;
                  this.table.remapData(t2, (x) => x[this.expression.id] = conv.get(x, t2));
                  this.replaceExpression(eid, newType);
                  break;
                case "add generated":
                  new generated_1.GeneratedIdentityConstraint((_a = alter.constraintName) === null || _a === void 0 ? void 0 : _a.name, this).install(t2, alter);
                  break;
                default:
                  throw interfaces_private_1.NotSupported.never(alter, "alter column type");
              }
              this.table.db.onSchemaChange();
              this.table.selection.rebuild();
              return this;
            }
            replaceExpression(newId, newType) {
              const on = this.expression.id;
              const nn = newId;
              this.expression = (0, selection_1.columnEvaluator)(this.table, newId, newType);
              this.table.columnMgr.delete(on);
              this.table.columnMgr.set(nn, this);
            }
            drop(t2) {
              const on = this.expression.id;
              if (!this.table.columnMgr.has(on)) {
                throw new Error("Corrupted table");
              }
              for (const u of this.usedInIndexes) {
                this.table.dropIndex(t2, u.name);
              }
              this.table.remapData(t2, (x) => delete x[this.expression.id]);
              this.table.columnMgr.delete(on);
              this.table.selection.rebuild();
              this.drophandlers.forEach((d) => d(t2, false));
              this.table.db.onSchemaChange();
            }
            checkConstraints(toInsert, t2) {
              if (!this.notNull) {
                return;
              }
              const col = this.expression.get(toInsert, t2);
              if ((0, utils_1.nullIsh)(col)) {
                throw new interfaces_private_1.QueryError(`null value in column "${this.expression.id}" violates not-null constraint`);
              }
            }
            setDefaults(toInsert, t2) {
              const col = this.expression.get(toInsert, t2);
              if (col !== void 0) {
                return;
              }
              if (!this.default) {
                toInsert[this.expression.id] = null;
              } else {
                toInsert[this.expression.id] = this.default.get();
              }
            }
            onDrop(sub) {
              this.drophandlers.add(sub);
              return {
                unsubscribe: () => {
                  this.drophandlers.delete(sub);
                }
              };
            }
          }
          exports2.ColRef = ColRef;
        },
        /* 66 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.GeneratedIdentityConstraint = void 0;
          const interfaces_1 = __webpack_require__(3);
          const utils_1 = __webpack_require__(1);
          class GeneratedIdentityConstraint {
            constructor(name, column) {
              this.name = name;
              this.column = column;
              this.subs = [];
            }
            get table() {
              return this.column.table;
            }
            get schema() {
              return this.table.ownerSchema;
            }
            uninstall(t2) {
              for (const s of this.subs) {
                s.unsubscribe();
              }
              ;
              this.subs = [];
            }
            install(ct, _c) {
              var _a, _b;
              if (!this.column.notNull) {
                const tableCreation = !this.schema.getTable(this.table.name, true);
                if (tableCreation) {
                  this.column.alter({
                    type: "set not null"
                  }, ct);
                } else {
                  throw new interfaces_1.QueryError(`column "${this.column.name}" of relation "${this.table.name}" must be declared NOT NULL before identity can be added`);
                }
              }
              const seq = this.schema.createSequence(ct, _c.sequence, (_a = _c.sequence) === null || _a === void 0 ? void 0 : _a.name);
              const mode = (_b = _c.always) !== null && _b !== void 0 ? _b : "always";
              this.subs.push(this.table.onBeforeChange([this.column], (old, neu, dt, opts) => {
                var _a2;
                if (old) {
                  return;
                }
                const gen = () => neu[this.column.name] = seq.nextValue(dt);
                if ((0, utils_1.nullIsh)(neu[this.column.name])) {
                  gen();
                  return;
                }
                switch (mode) {
                  case "by default":
                    switch ((_a2 = opts.overriding) !== null && _a2 !== void 0 ? _a2 : "system") {
                      case "system":
                        break;
                      default:
                        gen();
                        break;
                    }
                    break;
                  case "always":
                    if (opts.overriding !== "system") {
                      throw new interfaces_1.QueryError({
                        error: `cannot insert into column "${this.column.name}"`,
                        details: ` Column "${this.column.name}" is an identity column defined as GENERATED ALWAYS.`,
                        hint: "Use OVERRIDING SYSTEM VALUE to override."
                      });
                    }
                    break;
                  default:
                    throw interfaces_1.NotSupported.never(mode);
                }
              }));
              this.subs.push(this.table.onTruncate((t2, { restartIdentity }) => {
                if (!restartIdentity) {
                  return;
                }
                seq.restart(t2);
              }));
            }
          }
          exports2.GeneratedIdentityConstraint = GeneratedIdentityConstraint;
        },
        /* 67 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ForeignKey = void 0;
          const interfaces_1 = __webpack_require__(3);
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          class ForeignKey {
            constructor(name) {
              this.name = name;
              this.unsubs = [];
            }
            get db() {
              return this.table.ownerSchema.db;
            }
            get schema() {
              return this.table.ownerSchema;
            }
            install(_t, cst, table) {
              var _a, _b, _c;
              const ftable = (0, interfaces_private_1.asTable)(table.ownerSchema.getObject(cst.foreignTable, { beingCreated: table }));
              const cols = cst.localColumns.map((x) => table.getColumnRef(x.name));
              const fcols = cst.foreignColumns.map((x) => ftable.getColumnRef(x.name));
              this.table = table;
              this.foreignTable = ftable;
              if (cols.length !== fcols.length) {
                throw new interfaces_1.QueryError("Foreign key count mismatch");
              }
              cols.forEach((c, i) => {
                if (fcols[i].expression.type !== c.expression.type) {
                  throw new interfaces_1.QueryError(`Foreign key column type mismatch`);
                }
              });
              if (((_a = cst.match) !== null && _a !== void 0 ? _a : "simple") !== "simple" && cols.length !== 1) {
                throw new interfaces_1.NotSupported(`matching mode '${cst.match}' on mutliple columns foreign keys`);
              }
              const findex = ftable.getIndex(...fcols.map((x) => x.expression));
              if (!(findex === null || findex === void 0 ? void 0 : findex.unique)) {
                throw new interfaces_1.QueryError(`there is no unique constraint matching given keys for referenced table "${ftable.name}"`);
              }
              if (this.db.options.autoCreateForeignKeyIndices) {
                table.createIndex(_t, {
                  ifNotExists: true,
                  columns: cols.map((x) => ({
                    value: x.expression
                  }))
                });
              }
              const onUpdate = (_b = cst.onUpdate) !== null && _b !== void 0 ? _b : "no action";
              const onDelete = (_c = cst.onDelete) !== null && _c !== void 0 ? _c : "no action";
              this.unsubs.push(ftable.onBeforeChange(cst.foreignColumns.map((x) => x.name), (old, neu, dt) => {
                if (!old) {
                  return;
                }
                const oVals = fcols.map((x) => old[x.expression.id]);
                if (oVals.some(utils_1.nullIsh)) {
                  return;
                }
                const equals3 = cst.localColumns.map((x, i) => ({
                  type: "binary",
                  op: "=",
                  left: { type: "ref", name: x.name, table: { name: table.name } },
                  // hack, see #fkcheck
                  right: {
                    type: "constant",
                    value: oVals[i],
                    dataType: fcols[i].expression.type
                    // hack
                  }
                }));
                const expr = equals3.slice(1).reduce((a, b) => ({
                  type: "binary",
                  op: "AND",
                  left: a,
                  right: b
                }), equals3[0]);
                for (const local of table.selection.filter(expr).enumerate(dt)) {
                  switch (neu ? onUpdate : onDelete) {
                    case "no action":
                    case "restrict":
                      throw new interfaces_1.QueryError(`update or delete on table "${ftable.name}" violates foreign key constraint on table "${this.name}"`);
                    case "cascade":
                      if (neu) {
                        for (let i = 0; i < fcols.length; i++) {
                          local[cst.localColumns[i].name] = neu[cst.foreignColumns[i].name];
                        }
                        table.update(dt, local);
                      } else {
                        table.delete(dt, local);
                      }
                      break;
                    case "set default":
                    case "set null":
                      for (const c of cst.localColumns) {
                        local[c.name] = null;
                      }
                      table.update(dt, local);
                      break;
                  }
                }
              }));
              this.unsubs.push(table.onBeforeChange(cst.localColumns.map((x) => x.name), (_, neu, dt) => {
                if (!neu) {
                  return;
                }
                const vals = cols.map((x) => neu[x.expression.id]);
                if (vals.some(utils_1.nullIsh)) {
                  return;
                }
                const equals3 = cst.foreignColumns.map((x, i) => ({
                  type: "binary",
                  op: "=",
                  left: { type: "ref", name: x.name, table: { name: ftable.name } },
                  // hack, see #fkcheck
                  right: {
                    type: "constant",
                    value: vals[i],
                    dataType: cols[i].expression.type
                    // hack
                  }
                }));
                const expr = equals3.slice(1).reduce((a, b) => ({
                  type: "binary",
                  op: "AND",
                  left: a,
                  right: b
                }), equals3[0]);
                let yielded = false;
                for (const _2 of ftable.selection.filter(expr).enumerate(dt)) {
                  yielded = true;
                }
                if (!yielded) {
                  throw new interfaces_1.QueryError(`insert or update on table "${ftable.name}" violates foreign key constraint on table "${this.name}"`);
                }
              }));
              this.unsubs.push(ftable.onDrop((t2, cascade) => {
                if (cascade) {
                  this.uninstall(t2);
                } else {
                  throw new interfaces_1.QueryError({
                    error: `cannot drop table "${ftable.name}" because other objects depend on it`,
                    details: `constraint ${this.name} on table ${table.name} depends on table "${ftable.name}"`,
                    hint: `Use DROP ... CASCADE to drop the dependent objects too.`
                  });
                }
              }));
              this.unsubs.push(ftable.onTruncate((t2, { cascade }) => {
                if (cascade) {
                  this.table.truncate(t2, { cascade: true });
                  return;
                }
                throw new interfaces_1.QueryError({
                  error: `cannot truncate a table referenced in a foreign key constraint`,
                  details: `Table "${table.name}" references "${ftable.name}".`,
                  hint: `HINT:  Truncate table "${table.name}" at the same time, or use TRUNCATE ... CASCADE.`
                });
              }));
              table.onDrop((dt) => {
                this.uninstall(dt);
              });
              return this;
            }
            uninstall(t2) {
              this.unsubs.forEach((x) => x.unsubscribe());
              this.unsubs = [];
            }
          }
          exports2.ForeignKey = ForeignKey;
        },
        /* 68 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.SubscriptionConstraint = void 0;
          class SubscriptionConstraint {
            constructor(name, uninstall) {
              this.name = name;
              this.uninstall = uninstall;
            }
          }
          exports2.SubscriptionConstraint = SubscriptionConstraint;
        },
        /* 69 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ConstraintWrapper = void 0;
          class ConstraintWrapper {
            constructor(refs, inner) {
              this.refs = refs;
              this.inner = inner;
              if (inner.name) {
                refs.set(inner.name, this);
              }
            }
            get name() {
              return this.inner.name;
            }
            uninstall(t2) {
              this.inner.uninstall(t2);
              if (this.name) {
                this.refs.delete(this.name);
              }
            }
          }
          exports2.ConstraintWrapper = ConstraintWrapper;
        },
        /* 70 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.migrate = exports2.readMigrations = void 0;
          const pg_escape_1 = __webpack_require__(31);
          async function readMigrations(migrationPath) {
            const path = require("path");
            const fs = require("fs");
            const migrationsPath = migrationPath || path.join(process.cwd(), "migrations");
            const location = path.resolve(migrationsPath);
            const migrationFiles = await new Promise((resolve, reject) => {
              fs.readdir(location, (err, files) => {
                if (err) {
                  return reject(err);
                }
                resolve(files.map((x) => x.match(/^(\d+).(.*?)\.sql$/)).filter((x) => x !== null).map((x) => ({ id: Number(x[1]), name: x[2], filename: x[0] })).sort((a, b) => Math.sign(a.id - b.id)));
              });
            });
            if (!migrationFiles.length) {
              throw new Error(`No migration files found in '${location}'.`);
            }
            return Promise.all(migrationFiles.map((migration) => new Promise((resolve, reject) => {
              const filename = path.join(location, migration.filename);
              fs.readFile(filename, "utf-8", (err, data) => {
                if (err) {
                  return reject(err);
                }
                const [up, down] = data.split(/^--\s+?down\b/im);
                const migrationData = migration;
                migrationData.up = up.replace(/^-- .*?$/gm, "").trim();
                migrationData.down = down ? down.trim() : "";
                resolve(migrationData);
              });
            })));
          }
          exports2.readMigrations = readMigrations;
          async function migrate(db, config2 = {}) {
            config2.force = config2.force || false;
            config2.table = config2.table || "migrations";
            const { force, table } = config2;
            const migrations = config2.migrations ? config2.migrations : await readMigrations(config2.migrationsPath);
            await db.none(`CREATE TABLE IF NOT EXISTS "${table}" (
  id   INTEGER PRIMARY KEY,
  name TEXT    NOT NULL,
  up   TEXT    NOT NULL,
  down TEXT    NOT NULL
)`);
            let dbMigrations = await db.many(`SELECT id, name, up, down FROM "${table}" ORDER BY id ASC`);
            const lastMigration = migrations[migrations.length - 1];
            for (const migration of dbMigrations.slice().sort((a, b) => Math.sign(b.id - a.id))) {
              if (!migrations.some((x) => x.id === migration.id) || force && migration.id === lastMigration.id) {
                try {
                  await db.none(migration.down);
                  await db.none(`DELETE FROM "${table}" WHERE id = ${migration.id}`);
                  dbMigrations = dbMigrations.filter((x) => x.id !== migration.id);
                } catch (err) {
                  throw err;
                }
              } else {
                break;
              }
            }
            const lastMigrationId = dbMigrations.length ? dbMigrations[dbMigrations.length - 1].id : 0;
            for (const migration of migrations) {
              if (migration.id > lastMigrationId) {
                try {
                  await db.none(migration.up);
                  await db.none(`INSERT INTO "${table}" (id, name, up, down) VALUES (
          ${migration.id},
          ${(0, pg_escape_1.literal)(migration.name)},
          ${(0, pg_escape_1.literal)(migration.up)},
          ${(0, pg_escape_1.literal)(migration.down)})`);
                } catch (err) {
                  throw err;
                }
              }
            }
          }
          exports2.migrate = migrate;
        },
        /* 71 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.EquivalentType = void 0;
          const datatype_base_1 = __webpack_require__(9);
          const interfaces_1 = __webpack_require__(3);
          const datatypes_1 = __webpack_require__(14);
          class EquivalentType extends datatype_base_1.TypeBase {
            constructor(def) {
              super();
              this.def = def;
              if (typeof def.equivalentTo === "string") {
                let eq = datatypes_1.Types[def.equivalentTo];
                if (typeof eq === "function") {
                  eq = eq();
                }
                this.equiv = eq;
              } else {
                this.equiv = def.equivalentTo;
              }
              if (!this.equiv) {
                throw new Error(`Invalid equilvalent type`);
              }
            }
            get primary() {
              return this.def.name;
            }
            doCanCast(to) {
              return to.primary === this.equiv.primary;
            }
            doCast(value2, to) {
              return value2;
            }
            prefer(type) {
              return this;
            }
            doCanBuildFrom(from) {
              return from.primary === this.equiv.primary;
            }
            doBuildFrom(value2, from) {
              return value2.setConversion((x) => {
                if (!this.def.isValid(x)) {
                  throw new interfaces_1.QueryError(`invalid input syntax for type ${(0, interfaces_1.typeDefToStr)(this)}: ${x}`);
                }
                return x;
              }, (val) => ({ val, to: this.equiv.primary }));
            }
          }
          exports2.EquivalentType = EquivalentType;
        },
        /* 72 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.OverloadResolver = void 0;
          const datatypes_1 = __webpack_require__(2);
          const utils_1 = __webpack_require__(1);
          const interfaces_1 = __webpack_require__(3);
          class OverloadResolver {
            constructor(implicitCastOnly) {
              this.implicitCastOnly = implicitCastOnly;
              this.byName = /* @__PURE__ */ new Map();
            }
            add(value2, replaceIfExists) {
              let ret = this.byName.get(value2.name);
              if (!ret) {
                this.byName.set(value2.name, ret = new OverloadNode(datatypes_1.Types.null, this.implicitCastOnly, 0));
              }
              ret.index(value2, replaceIfExists);
            }
            getOverloads(name) {
              const ovr = this.byName.get(name);
              if (!ovr) {
                return [];
              }
              return [...ovr.all()];
            }
            remove(value2) {
              var _a;
              (_a = this.byName.get(value2.name)) === null || _a === void 0 ? void 0 : _a.unindex(value2);
            }
            resolve(name, args) {
              var _a;
              return (_a = this.byName.get(name)) === null || _a === void 0 ? void 0 : _a.resolve(args);
            }
            getExact(name, types) {
              var _a;
              return (_a = this.byName.get(name)) === null || _a === void 0 ? void 0 : _a.getExact(types);
            }
          }
          exports2.OverloadResolver = OverloadResolver;
          class OverloadNode {
            constructor(type, implicitCastOnly, at) {
              this.type = type;
              this.implicitCastOnly = implicitCastOnly;
              this.at = at;
              this.nexts = /* @__PURE__ */ new Map();
            }
            *all() {
              if (this.leaf) {
                yield this.leaf;
              }
              for (const children of this.nexts.values()) {
                for (const child of children) {
                  yield* child.all();
                }
              }
            }
            index(value2, replaceIfExists) {
              if (this.at >= value2.args.length) {
                if (this.leaf && !replaceIfExists) {
                  throw new interfaces_1.QueryError("Function already exists: " + value2.name);
                }
                this.leaf = value2;
                return;
              }
              const arg = value2.args[this.at];
              const primary = arg.type.primary;
              let lst = this.nexts.get(primary);
              if (!lst) {
                this.nexts.set(primary, lst = []);
              }
              let node = lst.find((x) => x.type === arg.type);
              if (!node) {
                lst.push(node = new OverloadNode(arg.type, this.implicitCastOnly, this.at + 1));
              }
              node.index(value2, replaceIfExists);
            }
            unindex(value2) {
              if (this.leaf === value2) {
                this.leaf = null;
                return;
              }
              for (const children of this.nexts.values()) {
                for (const child of children) {
                  child.unindex(value2);
                }
              }
            }
            getExact(types) {
              var _a;
              if (this.at >= types.length) {
                return this.leaf;
              }
              const target = types[this.at];
              const found = (_a = this.nexts.get(target.primary)) === null || _a === void 0 ? void 0 : _a.find((x) => x.type == target);
              return found === null || found === void 0 ? void 0 : found.getExact(types);
            }
            resolve(args) {
              var _a;
              if (this.at >= args.length) {
                return this.leaf;
              }
              const arg = args[this.at];
              const sigsToCheck = (0, utils_1.it)(
                (_a = this.nexts.get(arg.type.primary)) !== null && _a !== void 0 ? _a : (0, utils_1.it)(this.nexts.values()).flatten()
                // else, search all registered overloads
              );
              const match = sigsToCheck.reduce((acc, x) => {
                if (!this.compatible(arg, x.type)) {
                  return acc;
                }
                if (!acc) {
                  return x;
                }
                return acc.type.prefer(x.type) === x.type ? x : acc;
              }, null);
              if (match) {
                return match.resolve(args);
              }
              if (this.leaf && this.leaf.argsVariadic && this.compatible(arg, this.leaf.argsVariadic)) {
                return this.leaf;
              }
              return null;
            }
            compatible(givenArg, expectedArg) {
              var _a;
              if (givenArg.type === expectedArg) {
                return true;
              }
              return givenArg.isConstantLiteral ? givenArg.type.canCast(expectedArg) : (_a = givenArg.type.canConvertImplicit(expectedArg)) !== null && _a !== void 0 ? _a : givenArg.type.canCast(expectedArg);
            }
          }
        },
        /* 73 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Sequence = void 0;
          const utils_1 = __webpack_require__(1);
          const interfaces_private_1 = __webpack_require__(0);
          const interfaces_1 = __webpack_require__(3);
          const datatypes_1 = __webpack_require__(2);
          class Sequence {
            constructor(name, ownerSchema) {
              this.name = name;
              this.ownerSchema = ownerSchema;
              this.symbol = Symbol();
              this.cfg = {};
              this.reg = ownerSchema._reg_register(this);
            }
            get type() {
              return "sequence";
            }
            get cycle() {
              var _a;
              return (_a = this.cfg.cycle) !== null && _a !== void 0 ? _a : false;
            }
            get dataType() {
              var _a;
              return (_a = this.cfg.dataType) !== null && _a !== void 0 ? _a : datatypes_1.Types.integer;
            }
            get inc() {
              var _a;
              return (_a = this.cfg.inc) !== null && _a !== void 0 ? _a : 1;
            }
            get start() {
              var _a;
              return (_a = this.cfg.start) !== null && _a !== void 0 ? _a : this.inc > 0 ? this.min : this.max;
            }
            get max() {
              var _a;
              return (_a = this.cfg.max) !== null && _a !== void 0 ? _a : this.inc > 0 ? Number.MAX_SAFE_INTEGER - 1 : -1;
            }
            get min() {
              var _a;
              return (_a = this.cfg.min) !== null && _a !== void 0 ? _a : this.inc > 0 ? 1 : Number.MIN_SAFE_INTEGER + 1;
            }
            alter(t2, opts) {
              var _a;
              if (!opts) {
                return this;
              }
              const oldCfg = { ...this.cfg };
              try {
                if (!("type" in opts)) {
                  return this.alterOpts(t2, opts);
                }
                switch (opts.type) {
                  case "set options":
                    this.alterOpts(t2, opts);
                    if (opts.restart === true || typeof opts.restart === "number") {
                      if (typeof opts.restart === "number") {
                        if (opts.restart < this.min) {
                          throw new interfaces_1.QueryError(`RESTART value (${opts.restart}) cannot be less than MINVALUE (${this.min})`, "22023");
                        }
                        this.cfg.start = opts.restart;
                      }
                      const data = {
                        currval: (_a = t2.get(this.symbol)) === null || _a === void 0 ? void 0 : _a.currval,
                        nextval: this.start
                      };
                      t2.set(this.symbol, data);
                    }
                    return this;
                  case "set schema":
                    if (opts.newSchema.name === this.ownerSchema.name) {
                      return this;
                    }
                    throw new interfaces_private_1.NotSupported("Sequence schema change");
                  case "rename":
                    const to = opts.newName.name.toLowerCase();
                    this.ownerSchema._reg_rename(this, this.name, to);
                    this.name = to;
                    return this;
                  case "owner to":
                    (0, utils_1.ignore)(opts);
                    return this;
                  default:
                    throw interfaces_private_1.NotSupported.never(opts);
                }
              } catch (e) {
                this.cfg = oldCfg;
                throw e;
              }
            }
            nextValue(t2) {
              var _a;
              let v = (_a = t2.get(this.symbol)) === null || _a === void 0 ? void 0 : _a.nextval;
              if (v === void 0) {
                v = this.start;
              }
              this.setValue(t2, v);
              return v;
            }
            setValue(t2, value2) {
              if (value2 > this.max) {
                throw new interfaces_1.QueryError(`reached maximum value of sequence "${this.name}"`);
              }
              if (value2 < this.min) {
                throw new interfaces_1.QueryError(`reached minimum value of sequence "${this.name}"`);
              }
              const data = {
                currval: value2,
                nextval: value2 + this.inc
              };
              t2.set(this.symbol, data);
            }
            restart(t2) {
              t2.delete(this.symbol);
            }
            currentValue(t2) {
              var _a;
              const v = (_a = t2.get(this.symbol)) === null || _a === void 0 ? void 0 : _a.currval;
              if (v === void 0) {
                throw new interfaces_1.QueryError(`currval of sequence "${this.name}" is not yet defined in this session`, "55000");
              }
              return v;
            }
            alterOpts(t2, opts) {
              var _a, _b;
              if (opts.as) {
                (0, utils_1.ignore)(opts.as);
                this.cfg.dataType = this.ownerSchema.getType(opts.as);
              }
              (0, utils_1.ignore)(opts.cache);
              if (opts.cycle) {
                this.cfg.cycle = opts.cycle === "cycle";
              }
              if (typeof opts.incrementBy === "number") {
                this.cfg.inc = opts.incrementBy;
              }
              if (typeof opts.maxValue === "number") {
                this.cfg.max = opts.maxValue;
              } else if (opts.maxValue) {
                this.cfg.max = void 0;
              }
              if (typeof opts.minValue === "number") {
                this.cfg.min = opts.minValue;
              } else if (opts.maxValue) {
                this.cfg.min = void 0;
              }
              if (typeof opts.startWith === "number") {
                this.cfg.start = opts.startWith;
              }
              if (opts.ownedBy === "none") {
                (_a = this.owner) === null || _a === void 0 ? void 0 : _a.unsubscribe();
              } else if (opts.ownedBy) {
                (_b = this.owner) === null || _b === void 0 ? void 0 : _b.unsubscribe();
                const tbl = (0, interfaces_private_1.asTable)(this.ownerSchema.getObject({
                  name: opts.ownedBy.table,
                  schema: opts.ownedBy.schema
                }));
                const owner = tbl.getColumnRef(opts.ownedBy.column);
                this.owner = (0, utils_1.combineSubs)(owner.onDrop((dt) => this.drop(dt)), tbl.onDrop((dt) => this.drop(dt)));
              }
              if (this.max < this.min) {
                throw new interfaces_1.QueryError("Invalid squeuence min-max");
              }
              if (!this.inc) {
                throw new interfaces_1.QueryError("Invalid increment");
              }
              if (this.start > this.max || this.start < this.min) {
                throw new interfaces_1.QueryError("Invalid sequence starting value");
              }
              return this;
            }
            drop(t2) {
              var _a;
              (_a = this.owner) === null || _a === void 0 ? void 0 : _a.unsubscribe();
              this.owner = void 0;
              t2.delete(this.symbol);
              this.ownerSchema._reg_unregister(this);
            }
          }
          exports2.Sequence = Sequence;
        },
        /* 74 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ExecuteCreateTable = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const exec_utils_1 = __webpack_require__(7);
          const context_1 = __webpack_require__(4);
          class ExecuteCreateTable extends exec_utils_1.ExecHelper {
            constructor(p) {
              super(p);
              const { db } = (0, context_1.buildCtx)();
              this.schema = db.getSchema(p.name.schema);
              let fields = [];
              for (const f of p.columns) {
                switch (f.kind) {
                  case "column":
                    if (!f.dataType.kind && f.dataType.name === interfaces_private_1.DataType.record) {
                      throw new interfaces_private_1.QueryError(`column "${f.name.name}" has pseudo-type record`, "42P16");
                    }
                    (0, utils_1.ignore)(f.collate);
                    const nf = {
                      ...f,
                      name: f.name.name,
                      type: this.schema.getType(f.dataType),
                      serial: !f.dataType.kind && (f.dataType.name === "serial" || f.dataType.name === "bigserial")
                    };
                    delete nf.dataType;
                    fields.push(nf);
                    break;
                  case "like table":
                    throw new interfaces_private_1.NotSupported('"like table" statement');
                  default:
                    throw interfaces_private_1.NotSupported.never(f);
                }
              }
              this.ifNotExists = !!p.ifNotExists;
              this.name = p.name;
              this.toDeclare = {
                name: p.name.name,
                constraints: p.constraints,
                fields
              };
            }
            execute(t2) {
              t2 = t2.fullCommit();
              (0, exec_utils_1.checkExistence)(this.schema, this.name, this.ifNotExists, () => {
                this.schema.declareTable(this.toDeclare);
              });
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.ExecuteCreateTable = ExecuteCreateTable;
        },
        /* 75 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CreateIndexExec = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const exec_utils_1 = __webpack_require__(7);
          const expression_builder_1 = __webpack_require__(6);
          const context_1 = __webpack_require__(4);
          class CreateIndexExec extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, p) {
              var _a;
              super(p);
              const indexName = (_a = p.indexName) === null || _a === void 0 ? void 0 : _a.name;
              this.onTable = (0, interfaces_private_1.asTable)(schema2.getObject(p.table));
              if (p.using && p.using.name.toLowerCase() !== "btree") {
                if (schema2.db.options.noIgnoreUnsupportedIndices) {
                  throw new interfaces_private_1.NotSupported("index type: " + p.using);
                }
                (0, utils_1.ignore)(p);
              }
              this.indexDef = (0, context_1.withSelection)(this.onTable.selection, () => {
                const columns = p.expressions.map((x) => {
                  return {
                    value: (0, expression_builder_1.buildValue)(x.expression),
                    nullsLast: x.nulls === "last",
                    desc: x.order === "desc"
                  };
                });
                const predicate = p.where && (0, expression_builder_1.buildValue)(p.where);
                return {
                  columns,
                  indexName,
                  unique: p.unique,
                  ifNotExists: p.ifNotExists,
                  predicate
                };
              });
            }
            execute(t2) {
              t2 = t2.fullCommit();
              this.onTable.createIndex(t2, this.indexDef);
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.CreateIndexExec = CreateIndexExec;
        },
        /* 76 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Alter = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const exec_utils_1 = __webpack_require__(7);
          class Alter extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, p) {
              super(p);
              this.p = p;
              this.table = (0, interfaces_private_1.asTable)(schema2.getObject(p.table));
              (0, utils_1.ignore)(p.only);
            }
            execute(t2) {
              let ignored = 0;
              t2 = t2.fullCommit();
              for (const change of this.p.changes) {
                let ignoreChange = function() {
                  (0, utils_1.ignore)(change);
                  ignored++;
                };
                switch (change.type) {
                  case "rename":
                    this.table.rename(change.to.name);
                    break;
                  case "add column": {
                    const col2 = this.table.selection.getColumn(change.column.name.name, true);
                    if (col2) {
                      if (change.ifNotExists) {
                        ignoreChange();
                        break;
                      } else {
                        throw new interfaces_private_1.QueryError("Column already exists: " + col2.id);
                      }
                    } else {
                      (0, utils_1.ignore)(change.ifNotExists);
                    }
                    this.table.addColumn(change.column, t2);
                    break;
                  }
                  case "drop column":
                    const col = this.table.getColumnRef(change.column.name, change.ifExists);
                    if (!col) {
                      ignoreChange();
                    } else {
                      col.drop(t2);
                    }
                    break;
                  case "drop constraint":
                    const cst = this.table.getConstraint(change.constraint.name);
                    if (change.ifExists && !cst) {
                      ignoreChange();
                      break;
                    }
                    if (!cst) {
                      throw new interfaces_private_1.QueryError(`constraint "${change.constraint.name}" of relation "${this.table.name}" does not exist`, "42704");
                    }
                    cst.uninstall(t2);
                    break;
                  case "rename column":
                    this.table.getColumnRef(change.column.name).rename(change.to.name, t2);
                    break;
                  case "alter column":
                    this.table.getColumnRef(change.column.name).alter(change.alter, t2);
                    break;
                  case "rename constraint":
                    throw new interfaces_private_1.NotSupported("rename constraint");
                  case "add constraint":
                    this;
                    this.table.addConstraint(change.constraint, t2);
                    break;
                  case "owner":
                    ignoreChange();
                    break;
                  default:
                    throw interfaces_private_1.NotSupported.never(change, "alter request");
                }
              }
              t2 = t2.fork();
              return this.noData(t2, "ALTER");
            }
          }
          exports2.Alter = Alter;
        },
        /* 77 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.AlterSequence = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class AlterSequence extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, p) {
              super(p);
              this.p = p;
              this.seq = (0, interfaces_private_1.asSeq)(schema2.getObject(p.name, {
                nullIfNotFound: p.ifExists
              }));
              if (!this.seq) {
                (0, utils_1.ignore)(this.p);
              }
            }
            execute(t2) {
              var _a;
              t2 = t2.fullCommit();
              (_a = this.seq) === null || _a === void 0 ? void 0 : _a.alter(t2, this.p.change);
              t2 = t2.fork();
              return this.noData(t2, "ALTER");
            }
          }
          exports2.AlterSequence = AlterSequence;
        },
        /* 78 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DropIndex = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class DropIndex extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, statement) {
              super(statement);
              this.idx = (0, utils_1.notNil)(statement.names.map((x) => (0, interfaces_private_1.asIndex)(schema2.getObject(x, {
                nullIfNotFound: statement.ifExists
              }))));
              if (this.idx.length) {
                (0, utils_1.ignore)(statement.concurrently);
              } else {
                (0, utils_1.ignore)(statement);
              }
            }
            execute(t2) {
              t2 = t2.fullCommit();
              for (const idx of this.idx) {
                idx.onTable.dropIndex(t2, idx.name);
              }
              t2 = t2.fork();
              return this.noData(t2, "DROP");
            }
          }
          exports2.DropIndex = DropIndex;
        },
        /* 79 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DropTable = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class DropTable extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, statement) {
              super(statement);
              this.tables = (0, utils_1.notNil)(statement.names.map((x) => (0, interfaces_private_1.asTable)(schema2.getObject(x, {
                nullIfNotFound: statement.ifExists
              }))));
              this.cascade = statement.cascade === "cascade";
              if (!this.tables.length) {
                (0, utils_1.ignore)(statement);
              }
            }
            execute(t2) {
              t2 = t2.fullCommit();
              for (const table of this.tables) {
                table.drop(t2, this.cascade);
              }
              t2 = t2.fork();
              return this.noData(t2, "DROP");
            }
          }
          exports2.DropTable = DropTable;
        },
        /* 80 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DropSequence = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class DropSequence extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, statement) {
              super(statement);
              this.seqs = (0, utils_1.notNil)(statement.names.map((x) => (0, interfaces_private_1.asSeq)(schema2.getObject(x, {
                nullIfNotFound: statement.ifExists
              }))));
              if (!this.seqs.length) {
                (0, utils_1.ignore)(statement);
              }
            }
            execute(t2) {
              t2 = t2.fullCommit();
              for (const seq of this.seqs) {
                seq.drop(t2);
              }
              t2 = t2.fork();
              return this.noData(t2, "DROP");
            }
          }
          exports2.DropSequence = DropSequence;
        },
        /* 81 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.BeginStatementExec = exports2.RollbackExecutor = exports2.CommitExecutor = void 0;
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class CommitExecutor extends exec_utils_1.ExecHelper {
            constructor(statement) {
              super(statement);
            }
            execute(t2) {
              t2 = t2.commit();
              if (!t2.isChild) {
                t2 = t2.fork();
              }
              return this.noData(t2, "COMMIT");
            }
          }
          exports2.CommitExecutor = CommitExecutor;
          class RollbackExecutor extends exec_utils_1.ExecHelper {
            constructor(statement) {
              super(statement);
              (0, utils_1.ignore)(statement);
            }
            execute(t2) {
              t2 = t2.rollback();
              return this.noData(t2, "ROLLBACK");
            }
          }
          exports2.RollbackExecutor = RollbackExecutor;
          class BeginStatementExec extends exec_utils_1.ExecHelper {
            constructor(statement) {
              super(statement);
              (0, utils_1.ignore)(statement);
            }
            execute(t2) {
              t2 = t2.fork();
              return this.noData(t2, "BEGIN");
            }
          }
          exports2.BeginStatementExec = BeginStatementExec;
        },
        /* 82 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TruncateTable = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const context_1 = __webpack_require__(4);
          class TruncateTable extends exec_utils_1.ExecHelper {
            constructor(statement) {
              super(statement);
              if (statement.tables.length !== 1) {
                throw new interfaces_private_1.NotSupported("Multiple truncations");
              }
              this.opts = {
                cascade: statement.cascade === "cascade",
                restartIdentity: statement.identity === "restart"
              };
              const { schema: schema2 } = (0, context_1.buildCtx)();
              this.table = (0, interfaces_private_1.asTable)(schema2.getObject(statement.tables[0]));
            }
            execute(t2) {
              this.table.truncate(t2, this.opts);
              return this.noData(t2, "TRUNCATE");
            }
          }
          exports2.TruncateTable = TruncateTable;
        },
        /* 83 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ShowExecutor = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          class ShowExecutor {
            constructor(statement) {
              this.statement = statement;
            }
            execute(t2) {
              const p = this.statement;
              const got = t2.getMap(interfaces_private_1.GLOBAL_VARS);
              if (!got.has(p.variable.name)) {
                throw new interfaces_private_1.QueryError(`unrecognized configuration parameter "${p.variable.name}"`);
              }
              return {
                state: t2,
                result: {
                  rows: [{ [p.variable.name]: got.get(p.variable.name) }],
                  rowCount: 1,
                  command: "SHOW",
                  fields: [],
                  location: (0, exec_utils_1.locOf)(p)
                }
              };
            }
          }
          exports2.ShowExecutor = ShowExecutor;
        },
        /* 84 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.SetExecutor = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          const exec_utils_1 = __webpack_require__(7);
          class SetExecutor extends exec_utils_1.ExecHelper {
            constructor(p) {
              super(p);
              this.p = p;
              (0, utils_1.ignore)(p);
            }
            execute(t2) {
              const p = this.p;
              if (p.type === "set" && p.set.type === "value") {
                t2.set(interfaces_private_1.GLOBAL_VARS, t2.getMap(interfaces_private_1.GLOBAL_VARS).set(p.variable.name, p.set.value));
              }
              return this.noData(t2, "SET");
            }
          }
          exports2.SetExecutor = SetExecutor;
        },
        /* 85 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CreateEnum = void 0;
          const exec_utils_1 = __webpack_require__(7);
          class CreateEnum extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, st) {
              super(st);
              this.onSchema = schema2.getThisOrSiblingFor(st.name);
              this.values = st.values.map((x) => x.value);
              this.name = st.name.name;
            }
            execute(t2) {
              t2 = t2.fullCommit();
              this.onSchema.registerEnum(this.name, this.values);
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.CreateEnum = CreateEnum;
        },
        /* 86 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CreateView = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          const view_1 = __webpack_require__(35);
          const select_1 = __webpack_require__(12);
          class CreateView extends exec_utils_1.ExecHelper {
            constructor(st, p) {
              var _a;
              super(p);
              this.schema = st.schema.getThisOrSiblingFor(p.name);
              this.existing = (0, interfaces_private_1.asView)(this.schema.getObject(p.name, { nullIfNotFound: true }));
              (0, utils_1.ignore)(p.orReplace);
              this.drop = !!(p.orReplace && this.existing);
              let view = (0, select_1.buildSelect)(p.query);
              if ((_a = p.columnNames) === null || _a === void 0 ? void 0 : _a.length) {
                if (p.columnNames.length > view.columns.length) {
                  throw new interfaces_private_1.QueryError("CREATE VIEW specifies more column names than columns", "42601");
                }
                view = view.select(view.columns.map((x, i) => {
                  var _a2, _b;
                  const alias = (_b = (_a2 = p.columnNames) === null || _a2 === void 0 ? void 0 : _a2[i]) === null || _b === void 0 ? void 0 : _b.name;
                  if (!alias) {
                    return x.id;
                  }
                  return {
                    expr: { type: "ref", name: x.id },
                    alias: { name: alias }
                  };
                }));
              }
              this.toRegister = new view_1.View(this.schema, p.name.name, view);
            }
            execute(t2) {
              t2 = t2.fullCommit();
              if (this.existing && this.drop) {
                this.existing.drop(t2);
              }
              this.toRegister.register();
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.CreateView = CreateView;
        },
        /* 87 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CreateMaterializedView = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const view_1 = __webpack_require__(35);
          const select_1 = __webpack_require__(12);
          class CreateMaterializedView extends exec_utils_1.ExecHelper {
            constructor(st, p) {
              super(p);
              this.schema = st.schema.getThisOrSiblingFor(p.name);
              const existing = this.schema.getObject(p.name, { nullIfNotFound: true });
              if (existing) {
                if (p.ifNotExists) {
                  return;
                }
                throw new interfaces_private_1.QueryError(`Name already exists: ${p.name.name}`);
              }
              const view = (0, select_1.buildSelect)(p.query);
              this.toRegister = new view_1.View(this.schema, p.name.name, view);
            }
            execute(t2) {
              if (!this.toRegister) {
                return this.noData(t2, "CREATE");
              }
              t2 = t2.fullCommit();
              this.toRegister.register();
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.CreateMaterializedView = CreateMaterializedView;
        },
        /* 88 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CreateSchema = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class CreateSchema extends exec_utils_1.ExecHelper {
            constructor(st, p) {
              super(p);
              this.st = st;
              const sch = this.st.schema.db.getSchema(p.name.name, true);
              if (!p.ifNotExists && sch) {
                throw new interfaces_private_1.QueryError("schema already exists! " + p.name);
              }
              if (sch) {
                (0, utils_1.ignore)(p);
              } else {
                this.toCreate = p.name.name;
              }
            }
            execute(t2) {
              t2 = t2.fullCommit();
              if (this.toCreate) {
                this.st.schema.db.createSchema(this.toCreate);
              }
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.CreateSchema = CreateSchema;
        },
        /* 89 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.CreateFunction = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const context_1 = __webpack_require__(4);
          class CreateFunction extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, fn) {
              var _a, _b;
              super(fn);
              if (!fn.language) {
                throw new interfaces_private_1.QueryError("Unspecified function language");
              }
              this.onSchema = schema2.getThisOrSiblingFor(fn.name);
              const lang = schema2.db.getLanguage(fn.language.name);
              const args = (0, context_1.withSelection)(schema2.dualTable.selection, () => fn.arguments.map((a) => {
                var _a2;
                return {
                  name: (_a2 = a.name) === null || _a2 === void 0 ? void 0 : _a2.name,
                  type: schema2.getType(a.type),
                  default: a.default && (0, expression_builder_1.buildValue)(a.default),
                  mode: a.mode
                };
              }));
              let returns = null;
              if (!fn.returns) {
                throw new interfaces_private_1.QueryError("Unspecified function return type");
              }
              if (typeof fn.code !== "string") {
                throw new interfaces_private_1.QueryError("no function body specified");
              }
              switch (fn.returns.kind) {
                case "table":
                  const columns = fn.returns.columns.map((c) => ({
                    name: c.name.name,
                    type: schema2.getType(c.type)
                  }));
                  returns = datatypes_1.Types.record(columns).asArray();
                  break;
                case "array":
                case null:
                case void 0:
                  returns = schema2.getType(fn.returns);
                  break;
                default:
                  throw interfaces_private_1.NotSupported.never(fn.returns);
              }
              let argsVariadic;
              const variad = args.filter((x) => x.mode === "variadic");
              if (variad.length > 1) {
                throw new interfaces_private_1.QueryError(`Expected only one "VARIADIC" argument`);
              } else if (variad.length) {
                argsVariadic = variad[0].type;
              }
              const compiled = lang({
                args,
                code: fn.code,
                returns,
                functionName: fn.name.name,
                schema: schema2
              });
              this.toRegister = {
                name: fn.name.name,
                returns,
                implementation: compiled,
                args: args.filter((x) => x.mode !== "variadic"),
                argsVariadic,
                impure: fn.purity !== "immutable",
                allowNullArguments: fn.onNullInput === "call"
              };
              this.replace = (_a = fn.orReplace) !== null && _a !== void 0 ? _a : false;
              const existing = this.onSchema.getFunction(this.toRegister.name, args.map((x) => x.type));
              if (existing) {
                if (!this.replace) {
                  throw new interfaces_private_1.QueryError(`function ${this.toRegister.name} lready exists with same argument types`, "42723");
                }
                if (existing.returns !== returns) {
                  throw new interfaces_private_1.QueryError(`cannot change return type of existing function`, "42P13");
                }
                for (let i = 0; i < args.length; i++) {
                  const exName = existing.args[i].name;
                  if ((_b = exName !== null && exName !== void 0 ? exName : null !== args[i].name) !== null && _b !== void 0 ? _b : null) {
                    throw new interfaces_private_1.QueryError(`cannot change name of input parameter "${exName}"`, "42P13");
                  }
                }
              }
            }
            execute(t2) {
              t2 = t2.fullCommit();
              this.onSchema.registerFunction(this.toRegister, this.replace);
              t2 = t2.fork();
              return this.noData(t2, "CREATE");
            }
          }
          exports2.CreateFunction = CreateFunction;
        },
        /* 90 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DoStatementExec = void 0;
          const exec_utils_1 = __webpack_require__(7);
          class DoStatementExec extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, st) {
              var _a, _b;
              super(st);
              const lang = schema2.db.getLanguage((_b = (_a = st.language) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "plpgsql");
              this.compiled = lang({
                args: [],
                code: st.code,
                schema: schema2
              });
            }
            execute(t2) {
              this.compiled();
              return this.noData(t2, "DO");
            }
          }
          exports2.DoStatementExec = DoStatementExec;
        },
        /* 91 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.DropType = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const exec_utils_1 = __webpack_require__(7);
          const utils_1 = __webpack_require__(1);
          class DropType extends exec_utils_1.ExecHelper {
            constructor({ schema: schema2 }, statement) {
              super(statement);
              this.types = (0, utils_1.notNil)(statement.names.map((x) => (0, interfaces_private_1.asType)(schema2.getObject(x, {
                nullIfNotFound: statement.ifExists
              }))));
              if (!this.types.length) {
                (0, utils_1.ignore)(statement);
              }
            }
            execute(t2) {
              t2 = t2.fullCommit();
              for (const seq of this.types) {
                seq.drop(t2);
              }
              t2 = t2.fork();
              return this.noData(t2, "DROP");
            }
          }
          exports2.DropType = DropType;
        },
        /* 92 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildFilter = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const expression_builder_1 = __webpack_require__(6);
          const datatypes_1 = __webpack_require__(2);
          const eq_filter_1 = __webpack_require__(93);
          const evaluator_1 = __webpack_require__(11);
          const false_filter_1 = __webpack_require__(94);
          const and_filter_1 = __webpack_require__(95);
          const or_filter_1 = __webpack_require__(96);
          const seq_scan_1 = __webpack_require__(36);
          const in_filter_1 = __webpack_require__(97);
          const not_in_filter_1 = __webpack_require__(98);
          const startswith_filter_1 = __webpack_require__(99);
          const ineq_filter_1 = __webpack_require__(100);
          const utils_1 = __webpack_require__(1);
          const between_filter_1 = __webpack_require__(101);
          const interfaces_1 = __webpack_require__(3);
          const context_1 = __webpack_require__(4);
          function buildFilter(on, filter3, parentName) {
            return (0, context_1.withSelection)(on, () => {
              var _a;
              const where = (0, expression_builder_1.buildValue)(filter3);
              if (!where.type.canConvertImplicit(datatypes_1.Types.bool)) {
                throw new interfaces_1.QueryError(`argument of ${parentName} must be type boolean, not type jsonb`, "42804");
              }
              return (_a = _buildFilter(on, filter3, where)) !== null && _a !== void 0 ? _a : new seq_scan_1.SeqScanFilter(on, where);
            });
          }
          exports2.buildFilter = buildFilter;
          function _buildFilter(on, filter3, built) {
            if (built.index) {
              if (built.index.expressions.length !== 1) {
                throw new Error("Was not expecing multiples expressions filter");
              }
              const itype = built.index.expressions[0].type;
              if (itype !== datatypes_1.Types.bool) {
                throw new interfaces_private_1.CastError(itype.primary, interfaces_private_1.DataType.bool);
              }
              return new eq_filter_1.EqFilter(built, true, "eq", false);
            }
            if (built.isConstant) {
              const val = built.cast(datatypes_1.Types.bool).get();
              if (val) {
                return on;
              }
              return new false_filter_1.FalseFilter(on);
            }
            switch (filter3.type) {
              case "binary":
                return buildBinaryFilter(on, filter3);
              case "unary":
                return buildUnaryFilter(on, filter3);
              case "ternary":
                return buildTernaryFilter(on, filter3);
              default:
                return null;
            }
          }
          function buildUnaryFilter(on, filter3) {
            const { operand, op } = filter3;
            switch (op) {
              case "IS NULL":
              case "IS NOT NULL": {
                const leftValue = (0, expression_builder_1.buildValue)(operand);
                if (leftValue.index) {
                  return new eq_filter_1.EqFilter(leftValue, null, op === "IS NULL" ? "eq" : "neq", true);
                }
                return new seq_scan_1.SeqScanFilter(on, evaluator_1.Value.isNull(leftValue, op === "IS NULL"));
              }
            }
            return null;
          }
          function buildBinaryFilter(on, filter3) {
            var _a;
            const { left, right, op } = filter3;
            switch (op) {
              case "=":
              case "!=":
              case ">":
              case "<":
              case "<=":
              case ">=":
                return buildComparison(on, filter3);
              case "AND":
              case "OR": {
                const leftFilter = buildFilter(on, left, op);
                const rightFilter = buildFilter(on, right, op);
                if (op === "OR" && (leftFilter instanceof seq_scan_1.SeqScanFilter || rightFilter instanceof seq_scan_1.SeqScanFilter)) {
                  return null;
                }
                return op === "AND" ? new and_filter_1.AndFilter([leftFilter, rightFilter]) : new or_filter_1.OrFilter(leftFilter, rightFilter);
              }
              case "IN":
              case "NOT IN": {
                const value2 = (0, expression_builder_1.buildValue)(left);
                let arrayValue = (0, expression_builder_1.buildValue)(right);
                if (arrayValue.type.primary !== interfaces_private_1.DataType.list) {
                  arrayValue = evaluator_1.Value.list([arrayValue]);
                }
                const elementType = arrayValue.type.of.prefer(value2.type);
                const array = arrayValue.cast(elementType.asList());
                if (array.isConstant && ((_a = value2.index) === null || _a === void 0 ? void 0 : _a.expressions.length) === 1) {
                  const arrCst = array.get();
                  if ((0, utils_1.nullIsh)(arrCst)) {
                    return new false_filter_1.FalseFilter(on);
                  }
                  return op === "IN" ? new in_filter_1.InFilter(value2, arrCst) : new not_in_filter_1.NotInFilter(value2, arrCst);
                }
                return new seq_scan_1.SeqScanFilter(on, evaluator_1.Value.in(value2, array, op === "IN"));
              }
              case "LIKE": {
                const value2 = (0, expression_builder_1.buildValue)(left);
                if (value2.index && value2.index.expressions[0].hash === value2.hash) {
                  const valueToCompare = (0, expression_builder_1.buildValue)(right);
                  if (valueToCompare.isConstant) {
                    const str = valueToCompare.get();
                    if ((0, utils_1.nullIsh)(str)) {
                      return new false_filter_1.FalseFilter(on);
                    }
                    const got = /^([^%_]+)([%_]?.+)$/.exec(str);
                    if (got) {
                      const start = got[1];
                      if (start.length === str) {
                        return buildComparison(on, {
                          type: "binary",
                          op: "=",
                          left,
                          right
                        });
                      }
                      const indexed = new startswith_filter_1.StartsWithFilter(value2, start);
                      if (got[2] === "%") {
                        return indexed;
                      }
                      return new seq_scan_1.SeqScanFilter(indexed, (0, expression_builder_1.buildValue)(filter3));
                    }
                  }
                }
              }
            }
            return null;
          }
          function buildComparison(on, filter3) {
            const { op, left, right } = filter3;
            let leftValue = (0, expression_builder_1.buildValue)(left);
            let rightValue = (0, expression_builder_1.buildValue)(right);
            if (leftValue.isConstant && rightValue.isConstant) {
              const global = (0, expression_builder_1.buildValue)(filter3);
              const got = global.get();
              if (got) {
                return on;
              }
              return new false_filter_1.FalseFilter(on);
            }
            if (rightValue.isConstant) {
              rightValue = rightValue.cast(leftValue.type);
            } else if (leftValue.isConstant) {
              leftValue = leftValue.cast(rightValue.type);
            }
            switch (op) {
              case "=":
              case "!=": {
                if (leftValue.index && rightValue.isConstant) {
                  return new eq_filter_1.EqFilter(leftValue, rightValue.get(), op === "=" ? "eq" : "neq", false);
                }
                if (rightValue.index && leftValue.isConstant) {
                  return new eq_filter_1.EqFilter(rightValue, leftValue.get(), op === "=" ? "eq" : "neq", false);
                }
                break;
              }
              case ">":
              case ">=":
              case "<":
              case "<=":
                if (leftValue.index && leftValue.index.expressions[0].hash === leftValue.hash && rightValue.isConstant) {
                  const fop = op === ">" ? "gt" : op === ">=" ? "ge" : op === "<" ? "lt" : "le";
                  return new ineq_filter_1.IneqFilter(leftValue, fop, rightValue.get());
                }
                if (rightValue.index && rightValue.index.expressions[0].hash === rightValue.hash && leftValue.isConstant) {
                  const fop = op === ">" ? "le" : op === ">=" ? "lt" : op === "<" ? "ge" : "gt";
                  return new ineq_filter_1.IneqFilter(rightValue, fop, leftValue.get());
                }
                break;
            }
            return null;
          }
          function buildTernaryFilter(on, filter3) {
            switch (filter3.op) {
              case "BETWEEN":
              case "NOT BETWEEN": {
                const value2 = (0, expression_builder_1.buildValue)(filter3.value);
                const lo = (0, expression_builder_1.buildValue)(filter3.lo);
                const hi = (0, expression_builder_1.buildValue)(filter3.hi);
                const valueIndex = value2.index;
                if (valueIndex && valueIndex.expressions[0].hash === value2.hash && lo.isConstant && hi.isConstant) {
                  const lov = lo.get();
                  const hiv = hi.get();
                  if ((0, utils_1.hasNullish)(lov, hiv)) {
                    return new false_filter_1.FalseFilter(on);
                  }
                  return new between_filter_1.BetweenFilter(value2, lov, hiv, filter3.op === "BETWEEN" ? "inside" : "outside");
                }
              }
            }
            return null;
          }
        },
        /* 93 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.EqFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(1);
          class EqFilter extends transform_base_1.FilterBase {
            constructor(onValue, equalsCst, op, matchNull) {
              super(onValue.origin);
              this.onValue = onValue;
              this.equalsCst = equalsCst;
              this.op = op;
              this.matchNull = matchNull;
              if (onValue.index.expressions.length !== 1) {
                throw new Error("Unexpected index equality expressions count mismatch");
              }
              this.index = this.onValue.index;
              this.opDef = {
                type: op,
                key: [equalsCst],
                t: null,
                matchNull: this.matchNull
              };
            }
            entropy(t2) {
              return this.index.entropy({ ...this.opDef, t: t2 });
            }
            stats(t2) {
              const stats = this.index.stats(t2, [this.equalsCst]);
              if (this.op === "eq" || !stats) {
                return stats;
              }
              const all = this.index.stats(t2);
              if (!all) {
                return null;
              }
              return {
                count: all.count - stats.count
              };
            }
            hasItem(item, t2) {
              const val = this.onValue.get(item, t2);
              if ((0, utils_1.nullIsh)(val)) {
                return false;
              }
              const eq = this.onValue.type.equals(val, this.equalsCst);
              if ((0, utils_1.nullIsh)(eq)) {
                return false;
              }
              return this.op === "eq" ? !!eq : !eq;
            }
            *enumerate(t2) {
              for (const item of this.index.enumerate({ ...this.opDef, t: t2 })) {
                yield item;
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: this.op,
                entropy: this.entropy(e.transaction),
                on: this.onValue.index.explain(e)
              };
            }
          }
          exports2.EqFilter = EqFilter;
        },
        /* 94 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.FalseFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          class FalseFilter extends transform_base_1.FilterBase {
            get index() {
              return null;
            }
            entropy() {
              return 0;
            }
            hasItem() {
              return false;
            }
            enumerate() {
              return [];
            }
            stats(t2) {
              return {
                count: 0
              };
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "empty"
              };
            }
          }
          exports2.FalseFilter = FalseFilter;
        },
        /* 95 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.AndFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const seq_scan_1 = __webpack_require__(36);
          class AndFilter extends transform_base_1.FilterBase {
            constructor(filters) {
              var _a;
              super((_a = filters.find((x) => !(x instanceof seq_scan_1.SeqScanFilter))) !== null && _a !== void 0 ? _a : filters[0]);
              this.filters = filters;
              if (filters.some((f) => f.columns !== this.base.columns)) {
                throw new Error("Column set mismatch");
              }
            }
            get index() {
              return null;
            }
            entropy(t2) {
              var _a;
              if (t2 === ((_a = this.prevEntropy) === null || _a === void 0 ? void 0 : _a.t)) {
                return this.prevEntropy.ret;
              }
              const { best } = this.plan(t2);
              const ret = best.entropy(t2);
              this.prevEntropy = {
                ret,
                t: t2
              };
              return ret;
            }
            hasItem(value2, t2) {
              return this.filters.every((x) => x.hasItem(value2, t2));
            }
            plan(t2) {
              const sorted = [...this.filters].sort((a, b) => a.entropy(t2) > b.entropy(t2) ? 1 : -1);
              const [best] = sorted.splice(0, 1);
              return { best, sorted };
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              const { best, sorted } = this.plan(t2);
              for (const item of best.enumerate(t2)) {
                if (!sorted.every((x) => x.hasItem(item, t2))) {
                  continue;
                }
                yield item;
              }
            }
            explain(e) {
              const { best, sorted } = this.plan(e.transaction);
              return {
                id: e.idFor(this),
                _: "and",
                enumerate: best.explain(e),
                andCheck: sorted.map((x) => x.explain(e))
              };
            }
          }
          exports2.AndFilter = AndFilter;
        },
        /* 96 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.OrFilter = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const transform_base_1 = __webpack_require__(5);
          class OrFilter extends transform_base_1.FilterBase {
            constructor(left, right) {
              super(left);
              this.left = left;
              this.right = right;
              if (left.columns !== right.columns) {
                throw new Error("Column set mismatch");
              }
            }
            entropy(t2) {
              return this.left.entropy(t2) + this.right.entropy(t2);
            }
            hasItem(value2, t2) {
              return this.left.hasItem(value2, t2) || this.right.hasItem(value2, t2);
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              const yielded = /* @__PURE__ */ new Set();
              for (const item of this.left.enumerate(t2)) {
                yield item;
                yielded.add((0, interfaces_private_1.getId)(item));
              }
              for (const item of this.right.enumerate(t2)) {
                const id = (0, interfaces_private_1.getId)(item);
                if (!yielded.has(id)) {
                  yield item;
                }
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "union",
                union: [
                  this.left.explain(e),
                  this.right.explain(e)
                ]
              };
            }
          }
          exports2.OrFilter = OrFilter;
        },
        /* 97 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.InFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const interfaces_1 = __webpack_require__(3);
          const utils_1 = __webpack_require__(1);
          class InFilter extends transform_base_1.FilterBase {
            constructor(onValue, elts) {
              super(onValue.origin);
              this.onValue = onValue;
              this.elts = elts;
              this.index = onValue.index;
              if (this.index.expressions.length !== 1) {
                throw new Error("Only supports IN with signle expressions index");
              }
              if (!Array.isArray(elts)) {
                throw new interfaces_1.QueryError("Cannot iterate element list");
              }
            }
            entropy(t2) {
              let ret = 0;
              for (const a of this.elts) {
                ret += this.index.entropy({
                  type: "eq",
                  key: [a],
                  t: t2
                });
              }
              return ret;
            }
            hasItem(item, t2) {
              const val = this.onValue.get(item, t2);
              return !(0, utils_1.nullIsh)(val) && this.elts.some((x) => this.onValue.type.equals(x, val));
            }
            stats(t2) {
              const elts = this.elts.map((x) => this.index.stats(t2, [x]));
              if (elts.some((x) => !x)) {
                return null;
              }
              const ret = {
                count: 0
              };
              for (const i of elts) {
                ret.count += i.count;
              }
              return ret;
            }
            *enumerate(t2) {
              for (const a of this.elts) {
                yield* this.index.enumerate({
                  type: "eq",
                  key: [a],
                  t: t2
                });
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "eq",
                entropy: this.entropy(e.transaction),
                on: this.index.explain(e)
              };
            }
          }
          exports2.InFilter = InFilter;
        },
        /* 98 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.NotInFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const interfaces_1 = __webpack_require__(3);
          const utils_1 = __webpack_require__(1);
          class NotInFilter extends transform_base_1.FilterBase {
            constructor(onValue, elts) {
              super(onValue.origin);
              this.onValue = onValue;
              this.elts = elts;
              this.index = onValue.index;
              if (this.index.expressions.length !== 1) {
                throw new Error("Only supports IN with signle expressions index");
              }
              if (!Array.isArray(elts)) {
                throw new interfaces_1.QueryError("Cannot iterate element list");
              }
              this.keys = elts.map((x) => [x]);
            }
            entropy(t2) {
              return this.onValue.index.entropy({
                type: "nin",
                keys: this.keys,
                t: t2
              });
            }
            hasItem(item, t2) {
              const val = this.onValue.get(item, t2);
              return !(0, utils_1.nullIsh)(val) && !this.elts.some((x) => this.onValue.type.equals(x, val));
            }
            stats(t2) {
              const all = this.base.stats(t2);
              if (!all) {
                return null;
              }
              const elts = this.elts.map((x) => this.index.stats(t2, [x]));
              if (elts.some((x) => !x)) {
                return null;
              }
              for (const i of elts) {
                all.count -= i.count;
              }
              return all;
            }
            *enumerate(t2) {
              yield* this.index.enumerate({
                type: "nin",
                keys: this.keys,
                t: t2
              });
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "neq",
                entropy: this.entropy(e.transaction),
                on: this.onValue.index.explain(e)
              };
            }
          }
          exports2.NotInFilter = NotInFilter;
        },
        /* 99 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.StartsWithFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(1);
          class StartsWithFilter extends transform_base_1.FilterBase {
            constructor(onValue, startWith) {
              super(onValue.origin);
              this.onValue = onValue;
              this.startWith = startWith;
              if (onValue.index.expressions[0].hash !== this.onValue.hash) {
                throw new Error("Startwith must be the first component of the index");
              }
            }
            get index() {
              return null;
            }
            entropy(t2) {
              return this.onValue.index.entropy({
                type: "ge",
                key: [this.startWith],
                t: t2
              });
            }
            hasItem(item, t2) {
              const get11 = this.onValue.get(item, t2);
              return typeof get11 === "string" && get11.startsWith(this.startWith);
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              const index = this.onValue.index;
              for (const item of index.enumerate({
                type: "ge",
                key: [this.startWith],
                t: t2
              })) {
                const got = this.onValue.get(item, t2);
                if ((0, utils_1.nullIsh)(got) || !got.startsWith(this.startWith)) {
                  break;
                }
                yield item;
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "ineq",
                entropy: this.entropy(e.transaction),
                on: this.onValue.index.explain(e)
              };
            }
          }
          exports2.StartsWithFilter = StartsWithFilter;
        },
        /* 100 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.IneqFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(1);
          class IneqFilter extends transform_base_1.FilterBase {
            constructor(onValue, op, than) {
              super(onValue.origin);
              this.onValue = onValue;
              this.op = op;
              this.than = than;
              this.index = this.onValue.index;
              this.opDef = {
                type: op,
                key: [than],
                t: null
              };
            }
            entropy(t2) {
              return this.onValue.index.entropy({ ...this.opDef, t: t2 });
            }
            hasItem(item, t2) {
              const val = this.onValue.get(item, t2);
              if ((0, utils_1.nullIsh)(val)) {
                return false;
              }
              return !!this.onValue.type[this.op](val, this.than);
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              for (const item of this.index.enumerate({ ...this.opDef, t: t2 })) {
                if (!this.hasItem(item, t2)) {
                  break;
                }
                yield item;
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "ineq",
                entropy: this.entropy(e.transaction),
                on: this.onValue.index.explain(e)
              };
            }
          }
          exports2.IneqFilter = IneqFilter;
        },
        /* 101 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.BetweenFilter = void 0;
          const transform_base_1 = __webpack_require__(5);
          const utils_1 = __webpack_require__(1);
          class BetweenFilter extends transform_base_1.FilterBase {
            constructor(onValue, lo, hi, op) {
              var _a;
              super(onValue.origin);
              this.onValue = onValue;
              this.lo = lo;
              this.hi = hi;
              this.op = op;
              if (((_a = onValue.index.expressions[0]) === null || _a === void 0 ? void 0 : _a.hash) !== onValue.hash) {
                throw new Error("Between index misuse");
              }
              this.opDef = {
                type: op,
                hi: [hi],
                lo: [lo],
                t: null
              };
            }
            entropy(t2) {
              return this.onValue.index.entropy({ ...this.opDef, t: t2 });
            }
            hasItem(value2, t2) {
              const v = this.onValue.get(value2, t2);
              if ((0, utils_1.nullIsh)(v)) {
                return false;
              }
              if (this.op === "inside") {
                return !!this.onValue.type.ge(v, this.lo) && !!this.onValue.type.le(v, this.hi);
              }
              return !!this.onValue.type.lt(v, this.lo) || !!this.onValue.type.gt(v, this.lo);
            }
            enumerate(t2) {
              return this.onValue.index.enumerate({ ...this.opDef, t: t2 });
            }
            stats(t2) {
              return null;
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: this.op,
                entropy: this.entropy(e.transaction),
                on: this.onValue.index.explain(e)
              };
            }
          }
          exports2.BetweenFilter = BetweenFilter;
        },
        /* 102 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            var desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = { enumerable: true, get: function() {
                return m[k];
              } };
            }
            Object.defineProperty(o, k2, desc);
          } : function(o, m, k, k2) {
            if (k2 === void 0)
              k2 = k;
            o[k2] = m[k];
          });
          var __exportStar = this && this.__exportStar || function(m, exports3) {
            for (var p in m)
              if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
                __createBinding(exports3, m, p);
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          __exportStar(__webpack_require__(103), exports2);
        },
        /* 103 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Adapters = void 0;
          const interfaces_1 = __webpack_require__(3);
          const lru_cache_1 = __importDefault(__webpack_require__(22));
          const utils_1 = __webpack_require__(1);
          const pg_utils_1 = __webpack_require__(104);
          const select_1 = __webpack_require__(12);
          const datatypes_1 = __webpack_require__(2);
          const t_custom_enum_1 = __webpack_require__(32);
          function timeoutOrImmediate(fn, time) {
            if (time || typeof setImmediate === "undefined") {
              return setTimeout(fn, time);
            }
            return setImmediate(fn);
          }
          const delay = (time) => new Promise((done) => timeoutOrImmediate(done, time !== null && time !== void 0 ? time : 0));
          function replaceQueryArgs$(sql, values2) {
            return sql.replace(/\$(\d+)/g, (str, istr) => {
              const i = Number.parseInt(istr);
              if (i > values2.length) {
                throw new Error("Unmatched parameter in query " + str);
              }
              const val = values2[i - 1];
              return (0, pg_utils_1.toLiteral)(val);
            });
          }
          class Adapters {
            constructor(db) {
              this.db = db;
            }
            createPg(queryLatency) {
              const that = this;
              class MemPg {
                constructor() {
                  this.connection = this;
                }
                on() {
                }
                release() {
                }
                removeListener() {
                }
                once(what, handler) {
                  if (what === "connect") {
                    timeoutOrImmediate(handler, queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0);
                  }
                }
                end(callback) {
                  if (callback) {
                    callback();
                    return null;
                  } else {
                    return Promise.resolve();
                  }
                }
                connect(callback) {
                  if (callback) {
                    callback(null, this, () => {
                    });
                    return null;
                  } else {
                    return Promise.resolve(this);
                  }
                }
                query(query, valuesOrCallback, callback) {
                  let values2 = null;
                  if (Array.isArray(valuesOrCallback)) {
                    values2 = valuesOrCallback;
                  }
                  if (callback == null && typeof valuesOrCallback === "function") {
                    callback = valuesOrCallback;
                  }
                  const pgquery = this.adaptQuery(query, values2);
                  try {
                    const result = this.adaptResults(query, that.db.public.query(pgquery.text));
                    if (callback) {
                      timeoutOrImmediate(() => callback(null, result), queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0);
                      return null;
                    } else {
                      return new Promise((res) => timeoutOrImmediate(() => res(result), queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0));
                    }
                  } catch (e) {
                    if (callback) {
                      timeoutOrImmediate(() => callback(e), queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0);
                      return null;
                    } else {
                      return new Promise((_, rej) => timeoutOrImmediate(() => rej(e), queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0));
                    }
                  }
                }
                adaptResults(query, res) {
                  if (query.rowMode) {
                    throw new interfaces_1.NotSupported("pg rowMode");
                  }
                  return {
                    ...res,
                    // clone rows to avoid leaking symbols
                    rows: res.rows.map((row) => {
                      const rowCopy = {};
                      for (const [k, v] of Object.entries(row)) {
                        rowCopy[k] = v;
                      }
                      for (const f of res.fields) {
                        const type = f[select_1.TYPE_SYMBOL];
                        const value2 = row[f.name];
                        if (type instanceof datatypes_1.ArrayType && type.of instanceof t_custom_enum_1.CustomEnumType && Array.isArray(value2)) {
                          rowCopy[f.name] = `{${value2.join(",")}}`;
                        }
                      }
                      return rowCopy;
                    }),
                    get fields() {
                      return [];
                    }
                  };
                }
                adaptQuery(query, values2) {
                  var _a, _b;
                  if (typeof query === "string") {
                    query = {
                      text: query,
                      values: values2
                    };
                  } else {
                    query = { ...query };
                  }
                  if (!((_a = query.values) === null || _a === void 0 ? void 0 : _a.length)) {
                    return query;
                  }
                  if ((_b = query.types) === null || _b === void 0 ? void 0 : _b.getTypeParser) {
                    throw new interfaces_1.NotSupported("getTypeParser is not supported");
                  }
                  query.text = replaceQueryArgs$(query.text, query.values);
                  return query;
                }
              }
              return {
                Pool: MemPg,
                Client: MemPg
              };
            }
            /**
             * @deprecated Use `createTypeormDataSource` instead.
             */
            createTypeormConnection(postgresOptions, queryLatency) {
              var _a;
              const that = this;
              postgresOptions.postgres = that.createPg(queryLatency);
              if ((postgresOptions === null || postgresOptions === void 0 ? void 0 : postgresOptions.type) !== "postgres") {
                throw new interfaces_1.NotSupported((_a = "Only postgres supported, found " + (postgresOptions === null || postgresOptions === void 0 ? void 0 : postgresOptions.type)) !== null && _a !== void 0 ? _a : "<null>");
              }
              const { getConnectionManager } = require("typeorm");
              const created = getConnectionManager().create(postgresOptions);
              created.driver.postgres = that.createPg(queryLatency);
              return created.connect();
            }
            createTypeormDataSource(postgresOptions, queryLatency) {
              var _a;
              const that = this;
              postgresOptions.postgres = that.createPg(queryLatency);
              if ((postgresOptions === null || postgresOptions === void 0 ? void 0 : postgresOptions.type) !== "postgres") {
                throw new interfaces_1.NotSupported((_a = "Only postgres supported, found " + (postgresOptions === null || postgresOptions === void 0 ? void 0 : postgresOptions.type)) !== null && _a !== void 0 ? _a : "<null>");
              }
              const nr = require("typeorm");
              const { DataSource: DataSource2 } = nr;
              const created = new DataSource2(postgresOptions);
              created.driver.postgres = that.createPg(queryLatency);
              return created;
            }
            createSlonik(queryLatency) {
              const { createMockPool, createMockQueryResult } = require("slonik");
              return createMockPool({
                query: async (sql, args) => {
                  await delay(queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0);
                  const formatted = replaceQueryArgs$(sql, args);
                  const ret = this.db.public.many(formatted);
                  return createMockQueryResult(ret);
                }
              });
            }
            createPgPromise(queryLatency) {
              const pgp = require("pg-promise")();
              pgp.pg = this.createPg(queryLatency);
              const db = pgp("pg-mem");
              if ((0, utils_1.compareVersions)("10.8.7", db.$config.version) < 0) {
                throw new Error(`\u{1F480} pg-mem cannot be used with pg-promise@${db.$config.version},

       \u{1F449} you must install version pg-promise@10.8.7 or newer:

                npm i pg-promise@latest -S

            See https://github.com/vitaly-t/pg-promise/issues/743 for details`);
              }
              return db;
            }
            createPgNative(queryLatency) {
              queryLatency = queryLatency !== null && queryLatency !== void 0 ? queryLatency : 0;
              const prepared = new lru_cache_1.default({
                max: 1e3,
                maxAge: 5e3
              });
              function handlerFor(a, b) {
                return typeof a === "function" ? a : b;
              }
              const that = this;
              return class Client {
                async connect(a, b) {
                  const handler = handlerFor(a, b);
                  await delay(queryLatency);
                  handler === null || handler === void 0 ? void 0 : handler();
                }
                connectSync() {
                }
                async prepare(name, sql, npar, callback) {
                  await delay(queryLatency);
                  this.prepareSync(name, sql, npar);
                  callback();
                }
                prepareSync(name, sql, npar) {
                  prepared.set(name, sql);
                }
                async execute(name, a, b) {
                  const handler = handlerFor(a, b);
                  const pars = Array.isArray(a) ? a : [];
                  await delay(queryLatency);
                  try {
                    const rows = this.executeSync(name, pars);
                    handler(null, rows);
                  } catch (e) {
                    handler(e);
                  }
                }
                executeSync(name, pars) {
                  pars = Array.isArray(pars) ? pars : [];
                  const prep = prepared.get(name);
                  if (!prep) {
                    throw new Error("Unkown prepared statement " + name);
                  }
                  return this.querySync(prep, pars);
                }
                async query(sql, b, c) {
                  const handler = handlerFor(b, c);
                  const params = Array.isArray(b) ? b : [];
                  try {
                    await delay(queryLatency);
                    const result = this.querySync(sql, params);
                    handler(null, result);
                  } catch (e) {
                    handler === null || handler === void 0 ? void 0 : handler(e);
                  }
                }
                querySync(sql, params) {
                  sql = replaceQueryArgs$(sql, params);
                  const ret = that.db.public.many(sql);
                  return ret;
                }
              };
            }
            createKnex(queryLatency, knexConfig) {
              const knex = require_knex2()({
                connection: {},
                ...knexConfig,
                client: "pg"
              });
              knex.client.driver = this.createPg(queryLatency);
              knex.client.version = "pg-mem";
              return knex;
            }
            createKysely(queryLatency, kyselyConfig) {
              const { Kysely, PostgresDialect } = require("kysely");
              const pg = this.createPg(queryLatency);
              return new Kysely({
                ...kyselyConfig,
                dialect: new PostgresDialect({
                  pool: new pg.Pool()
                })
              });
            }
            async createMikroOrm(mikroOrmOptions, queryLatency) {
              const { MikroORM } = require("@mikro-orm/core");
              const { AbstractSqlDriver, PostgreSqlConnection, PostgreSqlPlatform } = require("@mikro-orm/postgresql");
              const that = this;
              class PgMemConnection extends PostgreSqlConnection {
                createKnexClient(type) {
                  return that.createKnex();
                }
              }
              class PgMemDriver extends AbstractSqlDriver {
                constructor(config2) {
                  super(config2, new PostgreSqlPlatform(), PgMemConnection, ["knex", "pg"]);
                }
              }
              if (!this._mikroPatched) {
                this.db.public.interceptQueries((q) => {
                  if (q === `set names 'utf8';`) {
                    return [];
                  }
                  return null;
                });
                this._mikroPatched = true;
              }
              const orm = await MikroORM.init({
                ...mikroOrmOptions,
                dbName: "public",
                driver: PgMemDriver
              });
              return orm;
            }
          }
          exports2.Adapters = Adapters;
        },
        /* 104 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.normalizeQueryConfig = exports2.toLiteral = void 0;
          const utils_1 = __webpack_require__(1);
          const buffer_node_1 = __webpack_require__(21);
          const pg_escape_1 = __webpack_require__(31);
          const json_stable_stringify_1 = __importDefault(__webpack_require__(28));
          function toLiteral(val) {
            return prepareValue(val);
          }
          exports2.toLiteral = toLiteral;
          var prepareValue = function(val, seen) {
            if ((0, utils_1.nullIsh)(val)) {
              return "null";
            }
            if ((0, buffer_node_1.isBuf)(val)) {
              return (0, pg_escape_1.literal)((0, buffer_node_1.bufToString)(val));
            }
            if (val instanceof Date) {
              return (0, pg_escape_1.literal)(dateToString(val));
            }
            if (Array.isArray(val)) {
              if (val.length === 0)
                return `'{}'`;
              return `ARRAY[${val.map((x) => toLiteral(x)).join(", ")}]`;
            }
            if (typeof val === "object") {
              return prepareObject(val, seen);
            }
            return (0, pg_escape_1.literal)(val.toString());
          };
          function prepareObject(val, seen) {
            if (val && typeof val.toPostgres === "function") {
              seen = seen || [];
              if (seen.indexOf(val) !== -1) {
                throw new Error('circular reference detected while preparing "' + val + '" for query');
              }
              seen.push(val);
              return prepareValue(val.toPostgres(prepareValue), seen);
            }
            return (0, pg_escape_1.literal)((0, json_stable_stringify_1.default)(val));
          }
          function pad(number, digits) {
            number = "" + number;
            while (number.length < digits) {
              number = "0" + number;
            }
            return number;
          }
          function dateToString(date) {
            var offset = -date.getTimezoneOffset();
            var year = date.getFullYear();
            var isBCYear = year < 1;
            if (isBCYear)
              year = Math.abs(year) + 1;
            var ret = pad(year, 4) + "-" + pad(date.getMonth() + 1, 2) + "-" + pad(date.getDate(), 2) + "T" + pad(date.getHours(), 2) + ":" + pad(date.getMinutes(), 2) + ":" + pad(date.getSeconds(), 2) + "." + pad(date.getMilliseconds(), 3);
            if (offset < 0) {
              ret += "-";
              offset *= -1;
            } else {
              ret += "+";
            }
            ret += pad(Math.floor(offset / 60), 2) + ":" + pad(offset % 60, 2);
            if (isBCYear)
              ret += " BC";
            return ret;
          }
          function dateToStringUTC(date) {
            var year = date.getUTCFullYear();
            var isBCYear = year < 1;
            if (isBCYear)
              year = Math.abs(year) + 1;
            var ret = pad(year, 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + "T" + pad(date.getUTCHours(), 2) + ":" + pad(date.getUTCMinutes(), 2) + ":" + pad(date.getUTCSeconds(), 2) + "." + pad(date.getUTCMilliseconds(), 3);
            ret += "+00:00";
            if (isBCYear)
              ret += " BC";
            return ret;
          }
          function normalizeQueryConfig(config2, values2, callback) {
            config2 = typeof config2 === "string" ? { text: config2 } : config2;
            if (values2) {
              if (typeof values2 === "function") {
                config2.callback = values2;
              } else {
                config2.values = values2;
              }
            }
            if (callback) {
              config2.callback = callback;
            }
            return config2;
          }
          exports2.normalizeQueryConfig = normalizeQueryConfig;
        },
        /* 105 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Transaction = void 0;
          const immutable_1 = __webpack_require__(16);
          const interfaces_1 = __webpack_require__(3);
          class Transaction {
            constructor(parent, data) {
              this.parent = parent;
              this.data = data;
              this.transientData = {};
              this.origData = data;
            }
            static root() {
              return new Transaction(null, (0, immutable_1.Map)());
            }
            get isChild() {
              return !!this.parent;
            }
            clone() {
              return new Transaction(null, this.data);
            }
            fork() {
              return new Transaction(this, this.data);
            }
            commit() {
              if (!this.parent) {
                return this;
              }
              if (this.parent.data !== this.origData) {
                throw new interfaces_1.NotSupported("Concurrent transactions");
              }
              this.parent.data = this.data;
              return this.parent;
            }
            delete(identity) {
              this.data = this.data.delete(identity);
            }
            set(identity, data) {
              this.data = this.data.set(identity, data);
              return data;
            }
            get(identity) {
              return this.data.get(identity);
            }
            getMap(identity) {
              let got = this.data.get(identity);
              if (!got) {
                this.data = this.data.set(identity, got = (0, immutable_1.Map)());
              }
              return got;
            }
            getSet(identity) {
              let got = this.data.get(identity);
              if (!got) {
                this.data = this.data.set(identity, got = (0, immutable_1.Set)());
              }
              return got;
            }
            fullCommit() {
              const ret = this.commit();
              return ret.isChild ? ret.fullCommit() : ret;
            }
            rollback() {
              var _a;
              return (_a = this.parent) !== null && _a !== void 0 ? _a : this;
            }
            setTransient(identity, data) {
              this.transientData[identity] = data;
              return data;
            }
            /** Set transient data, which will only exist within the scope of the current statement */
            getTransient(identity) {
              return this.transientData[identity];
            }
            clearTransientData() {
              this.transientData = {};
            }
          }
          exports2.Transaction = Transaction;
        },
        /* 106 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildLimit = void 0;
          const transform_base_1 = __webpack_require__(5);
          const expression_builder_1 = __webpack_require__(6);
          const context_1 = __webpack_require__(4);
          function buildLimit(on, limit) {
            return (0, context_1.withSelection)(on, () => {
              const l = limit.limit && (0, expression_builder_1.buildValue)(limit.limit);
              const o = limit.offset && (0, expression_builder_1.buildValue)(limit.offset);
              return new LimitFilter(on, l, o);
            });
          }
          exports2.buildLimit = buildLimit;
          class LimitFilter extends transform_base_1.FilterBase {
            constructor(selection, take2, skip2) {
              super(selection);
              this.selection = selection;
              this.take = take2;
              this.skip = skip2;
            }
            get index() {
              return null;
            }
            entropy(t2) {
              return this.selection.entropy(t2);
            }
            hasItem(raw, t2) {
              return this.base.hasItem(raw, t2);
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              var _a, _b, _c, _d;
              let skip2 = (_b = (_a = this.skip) === null || _a === void 0 ? void 0 : _a.get(null, t2)) !== null && _b !== void 0 ? _b : 0;
              let take2 = (_d = (_c = this.take) === null || _c === void 0 ? void 0 : _c.get(null, t2)) !== null && _d !== void 0 ? _d : Number.MAX_SAFE_INTEGER;
              if (take2 <= 0) {
                return;
              }
              for (const raw of this.selection.enumerate(t2)) {
                if (skip2 > 0) {
                  skip2--;
                  continue;
                }
                yield raw;
                take2--;
                if (!take2) {
                  return;
                }
              }
            }
            explain(e) {
              var _a, _b;
              return {
                id: e.idFor(this),
                _: "limit",
                take: (_a = this.take) === null || _a === void 0 ? void 0 : _a.explain(e),
                skip: (_b = this.skip) === null || _b === void 0 ? void 0 : _b.explain(e),
                on: this.selection.explain(e)
              };
            }
          }
        },
        /* 107 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildUnion = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const transform_base_1 = __webpack_require__(5);
          const interfaces_1 = __webpack_require__(3);
          const selection_1 = __webpack_require__(10);
          const datatypes_1 = __webpack_require__(14);
          const utils_1 = __webpack_require__(1);
          function buildUnion(left, right) {
            var _a;
            if (left.columns.length !== right.columns.length) {
              throw new interfaces_1.QueryError("each UNION query must have the same number of columns");
            }
            const cols = Array(left.columns.length);
            for (let i = 0; i < left.columns.length; i++) {
              const l = left.columns[i];
              const r = right.columns[i];
              const type = (0, datatypes_1.reconciliateTypes)([l, r], true);
              if (!type) {
                throw new interfaces_1.QueryError(`UNION types ${l.type.name} and ${r.type.name} cannot be matched`);
              }
              cols[i] = {
                name: (_a = l.id) !== null && _a !== void 0 ? _a : "column" + i,
                type,
                lval: l.cast(type),
                rval: r.cast(type)
              };
            }
            return new Union(cols, left, right);
          }
          exports2.buildUnion = buildUnion;
          class Union extends transform_base_1.DataSourceBase {
            constructor(cols, left, right) {
              super(left.ownerSchema);
              this.cols = cols;
              this.left = left;
              this.right = right;
              this.colsByName = /* @__PURE__ */ new Map();
              this.columns = cols.map((x) => (0, selection_1.columnEvaluator)(this, x.name, x.type));
              for (const c of this.columns) {
                this.colsByName.set(c.id, c);
              }
            }
            get isExecutionWithNoResult() {
              return false;
            }
            isAggregation() {
              return false;
            }
            entropy(t2) {
              return this.left.entropy(t2) + this.right.entropy(t2);
            }
            hasItem(raw, t2) {
              return this.left.hasItem(raw, t2) || this.right.hasItem(raw, t2);
            }
            stats(t2) {
              return null;
            }
            *enumerate(t2) {
              for (const raw of this.left.enumerate(t2)) {
                const ret = {};
                (0, interfaces_private_1.setId)(ret, (0, interfaces_private_1.getId)(raw));
                for (const c of this.cols) {
                  ret[c.name] = c.lval.get(raw, t2);
                }
                yield ret;
              }
              for (const raw of this.right.enumerate(t2)) {
                const ret = {};
                (0, interfaces_private_1.setId)(ret, (0, interfaces_private_1.getId)(raw));
                for (const c of this.cols) {
                  ret[c.name] = c.rval.get(raw, t2);
                }
                yield ret;
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "union",
                union: [
                  this.left.explain(e),
                  this.right.explain(e)
                ]
              };
            }
            getColumn(column, nullIfNotFound) {
              return (0, utils_1.colByName)(this.colsByName, column, nullIfNotFound);
            }
            getIndex(...forValue) {
              return null;
            }
            isOriginOf(a) {
              return a.origin === this || this.left.isOriginOf(a);
            }
          }
        },
        /* 108 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildDistinct = void 0;
          const expression_builder_1 = __webpack_require__(6);
          const transform_base_1 = __webpack_require__(5);
          const object_hash_1 = __importDefault(__webpack_require__(15));
          const context_1 = __webpack_require__(4);
          function buildDistinct(on, exprs) {
            return (0, context_1.withSelection)(on, () => {
              const vals = exprs && exprs.length > 0 ? exprs.map((v) => (0, expression_builder_1.buildValue)(v)) : on.columns;
              return new Distinct(on, vals);
            });
          }
          exports2.buildDistinct = buildDistinct;
          class Distinct extends transform_base_1.FilterBase {
            constructor(selection, exprs) {
              super(selection);
              this.exprs = exprs;
            }
            get index() {
              return null;
            }
            entropy(t2) {
              return this.base.entropy(t2);
            }
            hasItem(raw, t2) {
              return this.base.hasItem(raw, t2);
            }
            stats(t2) {
              return this.base.stats(t2);
            }
            *enumerate(t2) {
              const got = /* @__PURE__ */ new Set();
              for (const i of this.base.enumerate(t2)) {
                const vals = this.exprs.map((v) => v.type.hash(v.get(i, t2)));
                const hash2 = vals.length === 1 ? vals[0] : (0, object_hash_1.default)(vals);
                if (got.has(hash2)) {
                  continue;
                }
                got.add(hash2);
                yield i;
              }
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "distinct",
                of: this.base.explain(e)
              };
            }
          }
        },
        /* 109 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.buildOrderBy = void 0;
          const transform_base_1 = __webpack_require__(5);
          const expression_builder_1 = __webpack_require__(6);
          const utils_1 = __webpack_require__(1);
          const context_1 = __webpack_require__(4);
          function buildOrderBy(on, order) {
            return new OrderBy(on, order);
          }
          exports2.buildOrderBy = buildOrderBy;
          class OrderBy extends transform_base_1.FilterBase {
            constructor(selection, order) {
              super(selection);
              this.selection = selection;
              this.order = (0, context_1.withSelection)(selection, () => order.map((x) => {
                var _a;
                const order2 = (_a = x.order) !== null && _a !== void 0 ? _a : "ASC";
                return {
                  by: (0, expression_builder_1.buildValue)(x.by),
                  order: order2,
                  nullsLast: order2 === "ASC" ? x.nulls !== "FIRST" : x.nulls === "LAST"
                };
              }));
            }
            get index() {
              return null;
            }
            isAggregation() {
              return this.selection.isAggregation();
            }
            getAggregation(name, call) {
              return this.asAggreg.getAggregation(name, call);
            }
            checkIfIsKey(got) {
              return this.asAggreg.checkIfIsKey(got);
            }
            get asAggreg() {
              if (!this.selection.isAggregation()) {
                throw new Error("Not an aggregation");
              }
              return this.selection;
            }
            entropy(t2) {
              const ret = this.selection.entropy(t2);
              return ret * Math.log(ret + 1);
            }
            hasItem(raw, t2) {
              return this.base.hasItem(raw, t2);
            }
            stats(t2) {
              return this.base.stats(t2);
            }
            getIndex(...forValue) {
              return this.base.getIndex(...forValue);
            }
            enumerate(t2) {
              const all = [...this.base.enumerate(t2)];
              all.sort((a, b) => {
                for (const o of this.order) {
                  const aval = o.by.get(a, t2);
                  const bval = o.by.get(b, t2);
                  const na = (0, utils_1.nullIsh)(aval);
                  const nb = (0, utils_1.nullIsh)(bval);
                  if (na && nb) {
                    continue;
                  }
                  if (na || nb) {
                    return nb === o.nullsLast ? -1 : 1;
                  }
                  if (o.by.type.equals(aval, bval)) {
                    continue;
                  }
                  if (o.by.type.gt(aval, bval)) {
                    return o.order === "ASC" ? 1 : -1;
                  }
                  return o.order === "ASC" ? -1 : 1;
                }
                return 0;
              });
              return all;
            }
            explain(e) {
              return {
                id: e.idFor(this),
                _: "orderBy",
                of: this.selection.explain(e)
              };
            }
          }
        },
        /* 110 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.setupPgCatalog = void 0;
          const datatypes_1 = __webpack_require__(2);
          const interfaces_private_1 = __webpack_require__(0);
          const pg_attribute_list_1 = __webpack_require__(111);
          const pg_class_1 = __webpack_require__(112);
          const pg_constraints_list_1 = __webpack_require__(113);
          const pg_index_list_1 = __webpack_require__(114);
          const pg_namespace_list_1 = __webpack_require__(115);
          const pg_type_list_1 = __webpack_require__(116);
          const functions_1 = __webpack_require__(117);
          const pg_range_1 = __webpack_require__(122);
          const expression_builder_1 = __webpack_require__(6);
          const pg_database_1 = __webpack_require__(123);
          const binary_operators_1 = __webpack_require__(124);
          const sql_function_language_1 = __webpack_require__(125);
          function setupPgCatalog(db) {
            const catalog = db.createSchema("pg_catalog");
            catalog._registerType(datatypes_1.Types.bool)._registerType(datatypes_1.Types.citext)._registerTypeSizeable(interfaces_private_1.DataType.timestamp, datatypes_1.Types.timestamp)._registerTypeSizeable(interfaces_private_1.DataType.timestamptz, datatypes_1.Types.timestamptz)._registerType(datatypes_1.Types.uuid)._registerType(datatypes_1.Types.date)._registerType(datatypes_1.Types.time)._registerType(datatypes_1.Types.timetz)._registerType(datatypes_1.Types.jsonb)._registerType(datatypes_1.Types.regtype)._registerType(datatypes_1.Types.regclass)._registerType(datatypes_1.Types.json)._registerType(datatypes_1.Types.null)._registerType(datatypes_1.Types.float)._registerType(datatypes_1.Types.integer)._registerType(datatypes_1.Types.bigint)._registerType(datatypes_1.Types.bytea)._registerType(datatypes_1.Types.point)._registerType(datatypes_1.Types.line)._registerType(datatypes_1.Types.lseg)._registerType(datatypes_1.Types.box)._registerType(datatypes_1.Types.path)._registerType(datatypes_1.Types.polygon)._registerType(datatypes_1.Types.circle)._registerType(datatypes_1.Types.interval)._registerType(datatypes_1.Types.inet)._registerType(datatypes_1.Types.record([]))._registerTypeSizeable(interfaces_private_1.DataType.text, datatypes_1.Types.text);
            new pg_constraints_list_1.PgConstraintTable(catalog).register();
            new pg_class_1.PgClassListTable(catalog).register();
            new pg_namespace_list_1.PgNamespaceTable(catalog).register();
            new pg_attribute_list_1.PgAttributeTable(catalog).register();
            new pg_index_list_1.PgIndexTable(catalog).register();
            new pg_type_list_1.PgTypeTable(catalog).register();
            new pg_range_1.PgRange(catalog).register();
            new pg_database_1.PgDatabaseTable(catalog).register();
            const tbl = catalog.declareTable({
              name: "current_schema",
              fields: [
                { name: "current_schema", type: datatypes_1.Types.text() }
              ]
            }, true);
            tbl.insert({ current_schema: "public" });
            tbl.setHidden().setReadonly();
            addFns(catalog, functions_1.allFunctions);
            catalog.registerFunction({
              name: "set_config",
              args: [datatypes_1.Types.text(), datatypes_1.Types.text(), datatypes_1.Types.bool],
              returns: datatypes_1.Types.text(),
              impure: true,
              implementation: (cfg, val, is_local) => {
                return val;
              }
            });
            catalog.registerFunction({
              name: "substring",
              args: [datatypes_1.Types.text(), datatypes_1.Types.integer],
              returns: datatypes_1.Types.text(),
              implementation: expression_builder_1.sqlSubstring
            });
            catalog.registerFunction({
              name: "substring",
              args: [datatypes_1.Types.text(), datatypes_1.Types.integer, datatypes_1.Types.integer],
              returns: datatypes_1.Types.text(),
              implementation: expression_builder_1.sqlSubstring
            });
            catalog.registerFunction({
              // required for Sequelize introspection
              name: "pg_get_indexdef",
              args: [datatypes_1.Types.integer],
              returns: datatypes_1.Types.text(),
              implementation: (indexId) => {
                throw new Error('This stub implementation of "pg_get_indexdef" should not be called');
              }
            });
            db.getSchema("pg_catalog").registerFunction({
              name: "col_description",
              args: [interfaces_private_1.DataType.integer, interfaces_private_1.DataType.integer],
              returns: interfaces_private_1.DataType.text,
              implementation: (x) => "Fake description provided by pg-mem"
            });
            (0, binary_operators_1.registerCommonOperators)(catalog);
            (0, sql_function_language_1.registerSqlFunctionLanguage)(db);
            catalog.setReadonly();
          }
          exports2.setupPgCatalog = setupPgCatalog;
          function addFns(catalog, fns) {
            for (const f of fns) {
              catalog.registerFunction(f);
            }
          }
        },
        /* 111 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgAttributeTable = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class PgAttributeTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_attribute",
                fields: [
                  { name: "attrelid", type: datatypes_1.Types.integer },
                  { name: "attname", type: datatypes_1.Types.text() },
                  { name: "atttypid", type: datatypes_1.Types.integer },
                  { name: "attstattarget", type: datatypes_1.Types.integer },
                  { name: "attlen", type: datatypes_1.Types.integer },
                  { name: "attnum", type: datatypes_1.Types.integer },
                  { name: "attndims", type: datatypes_1.Types.integer },
                  { name: "attcacheoff", type: datatypes_1.Types.integer },
                  { name: "atttypmod", type: datatypes_1.Types.integer },
                  { name: "attbyval", type: datatypes_1.Types.bool },
                  { name: "attstorage", type: datatypes_1.Types.text(1) },
                  { name: "attalign", type: datatypes_1.Types.text(1) },
                  { name: "attnotnull", type: datatypes_1.Types.bool },
                  { name: "atthasdef", type: datatypes_1.Types.bool },
                  { name: "atthasmissing", type: datatypes_1.Types.bool },
                  { name: "attidntity", type: datatypes_1.Types.text(1) },
                  { name: "attisdropped", type: datatypes_1.Types.bool },
                  { name: "attislocal", type: datatypes_1.Types.bool },
                  { name: "attinhcount", type: datatypes_1.Types.integer },
                  { name: "attcollation", type: datatypes_1.Types.integer },
                  { name: "attacl", type: datatypes_1.Types.jsonb },
                  { name: "attoptions", type: datatypes_1.Types.text().asArray() },
                  { name: "attfdwoptions", type: datatypes_1.Types.text().asArray() },
                  { name: "attmissingval", type: datatypes_1.Types.jsonb }
                  // anyarray
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
            getIndex(forValue) {
              return null;
            }
          }
          exports2.PgAttributeTable = PgAttributeTable;
        },
        /* 112 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgClassListTable = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          const IS_SCHEMA = Symbol("_is_pg_classlist");
          class PgClassListTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_class",
                fields: [
                  { name: "oid", type: datatypes_1.Types.integer },
                  { name: "relname", type: datatypes_1.Types.text() },
                  { name: "relnamespace", type: datatypes_1.Types.integer },
                  { name: "reltype", type: datatypes_1.Types.integer },
                  { name: "reloftype", type: datatypes_1.Types.integer },
                  { name: "relowner", type: datatypes_1.Types.integer },
                  { name: "relam", type: datatypes_1.Types.integer },
                  { name: "relfilenode", type: datatypes_1.Types.integer },
                  { name: "reltablespace", type: datatypes_1.Types.integer },
                  { name: "relpages", type: datatypes_1.Types.integer },
                  { name: "reltyples", type: datatypes_1.Types.integer },
                  { name: "relallvisible", type: datatypes_1.Types.integer },
                  { name: "reltoastrelid", type: datatypes_1.Types.integer },
                  { name: "relhashindex", type: datatypes_1.Types.bool },
                  { name: "relisshared", type: datatypes_1.Types.bool },
                  { name: "relpersistence", type: datatypes_1.Types.text(1) },
                  { name: "relkind", type: datatypes_1.Types.text(1) },
                  { name: "relnatts", type: datatypes_1.Types.integer },
                  { name: "relchecks", type: datatypes_1.Types.integer },
                  { name: "relhasoids", type: datatypes_1.Types.bool },
                  { name: "relhasrules", type: datatypes_1.Types.bool },
                  { name: "relhastriggers", type: datatypes_1.Types.bool },
                  { name: "relhassubclass", type: datatypes_1.Types.bool },
                  { name: "relrowsecurity", type: datatypes_1.Types.bool },
                  { name: "relforcerowsecurity", type: datatypes_1.Types.bool },
                  { name: "relispopulated", type: datatypes_1.Types.bool },
                  { name: "relreplident", type: datatypes_1.Types.text(1) },
                  { name: "relispartition", type: datatypes_1.Types.bool },
                  { name: "relrewrite", type: datatypes_1.Types.integer },
                  { name: "relfrozenxid", type: datatypes_1.Types.integer },
                  { name: "relminmxid", type: datatypes_1.Types.integer },
                  { name: "relacl", type: datatypes_1.Types.text() },
                  { name: "reloptions", type: datatypes_1.Types.text().asArray() },
                  { name: "relpartbound", type: datatypes_1.Types.jsonb }
                  // pg_nod_tr
                ]
              };
            }
            get ownSymbol() {
              return IS_SCHEMA;
            }
            // private indexes: { [key: string]: _IIndex } = {
            //     'oid': new CustomIndex(this, {
            //         get size() {
            //             return this.size
            //         },
            //         column: this.selection.getColumn('oid'),
            //         byColumnValue: (oid: string, t: _Transaction) => {
            //             return [this.byOid(oid, t)]
            //         }
            //     }),
            //     'relname': new CustomIndex(this, {
            //         get size() {
            //             return this.size
            //         },
            //         column: this.selection.getColumn('relname'),
            //         byColumnValue: (oid: string, t: _Transaction) => {
            //             return [this.byRelName(oid, t)];
            //         }
            //     }),
            // }
            // private byOid(oid: string, t: _Transaction) {
            //     const { type, id } = parseOid(oid);
            //     switch (type) {
            //         case 'table':
            //             return this.makeTable(this.schema.getTable(id, true)!);
            //         case 'index':
            //             return null;
            //         // return this.makeTable(this.db.getIndex(id, true));
            //         default:
            //             throw NotSupported.never(type);
            //     }
            // }
            // private byRelName(name: string, t: _Transaction) {
            //     return this.schema.getTable(name, true);
            //     // ?? this.db.getIndex(name, true);
            // }
            entropy(t2) {
              return 0;
            }
            *enumerate() {
            }
            makeInedx(t2) {
              if (!t2) {
                return null;
              }
              throw new Error("todo");
            }
            makeTable(t2) {
              if (!t2) {
                return null;
              }
              throw new Error("todo");
            }
            hasItem(value2) {
              return !!(value2 === null || value2 === void 0 ? void 0 : value2[IS_SCHEMA]);
            }
          }
          exports2.PgClassListTable = PgClassListTable;
        },
        /* 113 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgConstraintTable = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatypes_1 = __webpack_require__(2);
          const table_index_1 = __webpack_require__(27);
          const readonly_table_1 = __webpack_require__(8);
          const IS_SCHEMA = Symbol("_is_pgconstraint");
          class PgConstraintTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_constraint",
                fields: [
                  { name: "oid", type: datatypes_1.Types.integer },
                  { name: "conname", type: datatypes_1.Types.text() },
                  { name: "connamespace", type: datatypes_1.Types.integer },
                  { name: "contype", type: datatypes_1.Types.text(1) },
                  { name: "condeferrable", type: datatypes_1.Types.bool },
                  { name: "condeferred", type: datatypes_1.Types.bool },
                  { name: "convalidated", type: datatypes_1.Types.bool },
                  { name: "conrelid", type: datatypes_1.Types.integer },
                  { name: "contypid", type: datatypes_1.Types.integer },
                  { name: "conindid", type: datatypes_1.Types.integer },
                  { name: "conparentid", type: datatypes_1.Types.integer },
                  { name: "confrelid", type: datatypes_1.Types.integer },
                  { name: "confupdtype", type: datatypes_1.Types.text(1) },
                  { name: "confdeltype", type: datatypes_1.Types.text(1) },
                  { name: "confmatchtype", type: datatypes_1.Types.text(1) },
                  { name: "conislocal", type: datatypes_1.Types.bool },
                  { name: "coninhcount", type: datatypes_1.Types.integer },
                  { name: "connoinherit", type: datatypes_1.Types.bool },
                  { name: "conkey", type: datatypes_1.Types.integer.asArray() },
                  { name: "confkey", type: datatypes_1.Types.integer.asArray() },
                  { name: "conpfeqop", type: datatypes_1.Types.integer.asArray() },
                  { name: "conppeqop", type: datatypes_1.Types.integer.asArray() },
                  { name: "conffeqop", type: datatypes_1.Types.integer.asArray() },
                  { name: "conexclop", type: datatypes_1.Types.integer.asArray() },
                  { name: "conbin", type: datatypes_1.Types.text() },
                  { name: "consrc", type: datatypes_1.Types.text() }
                ]
              };
            }
            get ownSymbol() {
              return IS_SCHEMA;
            }
            entropy(t2) {
              return this.db.listSchemas().reduce((tot, s) => tot + s.tablesCount(t2) * 10 * 3, 0);
            }
            *enumerate(t2) {
              for (const schema2 of this.db.listSchemas()) {
                for (const it of schema2.listTables(t2)) {
                  yield* this.itemsByTable(it, t2);
                }
              }
            }
            make(table, i, t2) {
              if (!t2) {
                return null;
              }
              let ret = {};
              for (const { name } of this._schema.fields) {
                ret[name] = null;
              }
              ret = {
                ...ret,
                // table_catalog: 'pgmem',
                [IS_SCHEMA]: true
              };
              (0, interfaces_private_1.setId)(ret, `/schema/${table.ownerSchema.name}/pg_constraint/${table.name}/${i}`);
              return ret;
            }
            hasItem(value2) {
              return !!(value2 === null || value2 === void 0 ? void 0 : value2[IS_SCHEMA]);
            }
            getIndex(forValue) {
              if (forValue.id === "table_name") {
                return new table_index_1.TableIndex(this, forValue);
              }
              return null;
            }
          }
          exports2.PgConstraintTable = PgConstraintTable;
        },
        /* 114 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgIndexTable = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class PgIndexTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_index",
                fields: [
                  { name: "indexrelid", type: datatypes_1.Types.integer },
                  { name: "indrelid", type: datatypes_1.Types.integer },
                  { name: "indnatts", type: datatypes_1.Types.integer },
                  { name: "indnkyatts", type: datatypes_1.Types.integer },
                  { name: "indisunique", type: datatypes_1.Types.bool },
                  { name: "indisprimary", type: datatypes_1.Types.bool },
                  { name: "indisxclusion", type: datatypes_1.Types.bool },
                  { name: "indimmediate", type: datatypes_1.Types.bool },
                  { name: "indisclustered", type: datatypes_1.Types.bool },
                  { name: "indisvalid", type: datatypes_1.Types.bool },
                  { name: "indcheckxmin", type: datatypes_1.Types.bool },
                  { name: "indisready", type: datatypes_1.Types.bool },
                  { name: "indisliv", type: datatypes_1.Types.bool },
                  { name: "indisreplident", type: datatypes_1.Types.bool },
                  { name: "indkey", type: datatypes_1.Types.integer.asArray() },
                  { name: "indcollation", type: datatypes_1.Types.integer.asArray() },
                  { name: "indclass", type: datatypes_1.Types.integer.asArray() },
                  { name: "indoption", type: datatypes_1.Types.integer.asArray() },
                  { name: "indeexprs", type: datatypes_1.Types.jsonb },
                  { name: "indpred", type: datatypes_1.Types.jsonb }
                  // pg_node_tree
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.PgIndexTable = PgIndexTable;
        },
        /* 115 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgNamespaceTable = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class PgNamespaceTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_namespace",
                fields: [
                  { name: "oid", type: datatypes_1.Types.integer },
                  { name: "nspname", type: datatypes_1.Types.text() },
                  { name: "nspowner", type: datatypes_1.Types.integer },
                  { name: "nspacl", type: datatypes_1.Types.jsonb }
                  // aclitem[]
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.PgNamespaceTable = PgNamespaceTable;
        },
        /* 116 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgTypeTable = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class PgTypeTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_type",
                fields: [
                  { name: "oid", type: datatypes_1.Types.integer },
                  { name: "typname", type: datatypes_1.Types.text() },
                  { name: "typnamespace", type: datatypes_1.Types.integer },
                  { name: "typowner", type: datatypes_1.Types.integer },
                  { name: "typlen", type: datatypes_1.Types.integer },
                  { name: "typbyval", type: datatypes_1.Types.bool },
                  { name: "typtype", type: datatypes_1.Types.text(1) },
                  { name: "typispreferred", type: datatypes_1.Types.bool },
                  { name: "typisdefined", type: datatypes_1.Types.bool },
                  { name: "typdlim", type: datatypes_1.Types.text(1) },
                  { name: "typrelid", type: datatypes_1.Types.integer },
                  { name: "typelem", type: datatypes_1.Types.integer },
                  { name: "typarray", type: datatypes_1.Types.integer },
                  { name: "typinput", type: datatypes_1.Types.text() },
                  { name: "typoutput", type: datatypes_1.Types.text() },
                  { name: "typreceive", type: datatypes_1.Types.text() },
                  { name: "typsend", type: datatypes_1.Types.text() },
                  { name: "typmodin", type: datatypes_1.Types.text() },
                  { name: "typmodout", type: datatypes_1.Types.text() },
                  { name: "typanalyze", type: datatypes_1.Types.text() },
                  { name: "typalign", type: datatypes_1.Types.text(1) },
                  { name: "typstorage", type: datatypes_1.Types.text(1) },
                  { name: "typnotnull", type: datatypes_1.Types.bool },
                  { name: "typbasetype", type: datatypes_1.Types.integer },
                  { name: "typtypmod", type: datatypes_1.Types.integer },
                  { name: "typndims", type: datatypes_1.Types.integer },
                  { name: "typcollation", type: datatypes_1.Types.integer },
                  { name: "typdfaultbin", type: datatypes_1.Types.text() },
                  { name: "typdefault", type: datatypes_1.Types.text() },
                  { name: "typacl", type: datatypes_1.Types.jsonb }
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.PgTypeTable = PgTypeTable;
        },
        /* 117 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.allFunctions = void 0;
          const string_1 = __webpack_require__(118);
          const date_1 = __webpack_require__(119);
          const system_1 = __webpack_require__(120);
          const sequence_fns_1 = __webpack_require__(121);
          exports2.allFunctions = [
            ...string_1.stringFunctions,
            ...date_1.dateFunctions,
            ...system_1.systemFunctions,
            ...sequence_fns_1.sequenceFunctions
          ];
        },
        /* 118 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.stringFunctions = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          exports2.stringFunctions = [
            {
              name: "lower",
              args: [interfaces_private_1.DataType.text],
              returns: interfaces_private_1.DataType.text,
              implementation: (x) => x === null || x === void 0 ? void 0 : x.toLowerCase()
            },
            {
              name: "upper",
              args: [interfaces_private_1.DataType.text],
              returns: interfaces_private_1.DataType.text,
              implementation: (x) => x === null || x === void 0 ? void 0 : x.toUpperCase()
            },
            {
              name: "concat",
              args: [interfaces_private_1.DataType.text],
              argsVariadic: interfaces_private_1.DataType.text,
              returns: interfaces_private_1.DataType.text,
              allowNullArguments: true,
              implementation: (...x) => x === null || x === void 0 ? void 0 : x.join("")
            }
          ];
        },
        /* 119 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.dateFunctions = void 0;
          const moment_1 = __importDefault(__webpack_require__(17));
          const interfaces_private_1 = __webpack_require__(0);
          const utils_1 = __webpack_require__(1);
          exports2.dateFunctions = [
            {
              name: "to_date",
              args: [interfaces_private_1.DataType.text, interfaces_private_1.DataType.text],
              returns: interfaces_private_1.DataType.date,
              implementation: (data, format) => {
                if ((0, utils_1.nullIsh)(data) || (0, utils_1.nullIsh)(format)) {
                  return null;
                }
                const ret = moment_1.default.utc(data, format);
                if (!ret.isValid()) {
                  throw new interfaces_private_1.QueryError(`The text '${data}' does not match the date format ${format}`);
                }
                return ret.toDate();
              }
            },
            {
              name: "now",
              returns: interfaces_private_1.DataType.timestamptz,
              impure: true,
              implementation: () => /* @__PURE__ */ new Date()
            }
          ];
        },
        /* 120 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.systemFunctions = void 0;
          const datatypes_1 = __webpack_require__(2);
          exports2.systemFunctions = [
            {
              // ugly hack...
              name: "current_schema",
              returns: datatypes_1.Types.text(),
              implementation: () => "public"
            }
          ];
        },
        /* 121 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.sequenceFunctions = void 0;
          const utils_1 = __webpack_require__(1);
          const datatypes_1 = __webpack_require__(2);
          const interfaces_1 = __webpack_require__(3);
          const interfaces_private_1 = __webpack_require__(0);
          function getSeq(id) {
            const { transaction, schema: schema2 } = (0, utils_1.executionCtx)();
            if (!transaction) {
              throw new interfaces_1.QueryError("cannot query sequence value in this context");
            }
            return {
              t: transaction,
              seq: (0, interfaces_private_1.asSeq)(schema2.getObjectByRegOrName(id))
            };
          }
          const lastVal = Symbol();
          exports2.sequenceFunctions = [
            {
              name: "nextval",
              args: [datatypes_1.Types.regclass],
              returns: datatypes_1.Types.integer,
              implementation: (seqId) => {
                const { seq, t: t2 } = getSeq(seqId);
                const ret = seq.nextValue(t2);
                t2.set(lastVal, ret);
                return ret;
              },
              impure: true
            },
            {
              name: "currval",
              args: [datatypes_1.Types.regclass],
              returns: datatypes_1.Types.integer,
              implementation: (seqId) => {
                const { seq, t: t2 } = getSeq(seqId);
                return seq.currentValue(t2);
              },
              impure: true
            },
            {
              name: "lastval",
              returns: datatypes_1.Types.integer,
              implementation: (seqId) => {
                const { transaction } = (0, utils_1.executionCtx)();
                if (!transaction) {
                  throw new interfaces_1.QueryError("cannot query lastval in this context");
                }
                return transaction.get(lastVal);
              },
              impure: true
            },
            {
              name: "setval",
              args: [datatypes_1.Types.regclass, datatypes_1.Types.integer],
              returns: datatypes_1.Types.integer,
              implementation: (seqId, val) => {
                const { seq, t: t2 } = getSeq(seqId);
                if (typeof val !== "number") {
                  throw new interfaces_1.QueryError("Invalid setval() value");
                }
                seq.setValue(t2, val);
                return val;
              },
              impure: true
            }
          ];
        },
        /* 122 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgRange = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class PgRange extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_range",
                fields: [
                  { name: "rngtypid", type: datatypes_1.Types.integer },
                  { name: "rngsubtype", type: datatypes_1.Types.integer },
                  { name: "rngcollation", type: datatypes_1.Types.integer },
                  { name: "rngsubopc", type: datatypes_1.Types.integer },
                  { name: "rngcanonical", type: datatypes_1.Types.integer },
                  { name: "rngsubdiff", type: datatypes_1.Types.integer }
                  // oid
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.PgRange = PgRange;
        },
        /* 123 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.PgDatabaseTable = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          const IS_SCHEMA = Symbol("_is_pg_database");
          class PgDatabaseTable extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "pg_database",
                fields: [
                  { name: "oid", type: datatypes_1.Types.integer },
                  { name: "datname", type: datatypes_1.Types.text() },
                  { name: "datdba", type: datatypes_1.Types.integer },
                  { name: "encoding", type: datatypes_1.Types.integer },
                  { name: "datcollate", type: datatypes_1.Types.text() },
                  { name: "datctype", type: datatypes_1.Types.text() },
                  { name: "datistemplate", type: datatypes_1.Types.bool },
                  { name: "datlowconn", type: datatypes_1.Types.bool },
                  { name: "datconlimit", type: datatypes_1.Types.integer },
                  { name: "datlastsysoid", type: datatypes_1.Types.integer },
                  { name: "datfrozenxid", type: datatypes_1.Types.integer },
                  { name: "datminmxid", type: datatypes_1.Types.integer },
                  { name: "dattablespace", type: datatypes_1.Types.integer },
                  { name: "datacl", type: datatypes_1.Types.jsonb }
                ]
              };
            }
            get ownSymbol() {
              return IS_SCHEMA;
            }
            entropy(t2) {
              return this.db.listSchemas().length;
            }
            *enumerate() {
              let i = 48593;
              for (const t2 of this.db.listSchemas()) {
                const ret = {
                  oid: ++i,
                  datname: t2.name,
                  [IS_SCHEMA]: true
                };
                yield (0, interfaces_private_1.setId)(ret, "/schema/pg_database/" + t2.name);
              }
            }
            hasItem(value2) {
              return !!(value2 === null || value2 === void 0 ? void 0 : value2[IS_SCHEMA]);
            }
          }
          exports2.PgDatabaseTable = PgDatabaseTable;
        },
        /* 124 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          var __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : { "default": mod };
          };
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.registerCommonOperators = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatypes_1 = __webpack_require__(2);
          const utils_1 = __webpack_require__(1);
          const moment_1 = __importDefault(__webpack_require__(17));
          function registerCommonOperators(schema2) {
            registerNumericOperators(schema2);
            registerDatetimeOperators(schema2);
            registerJsonOperators(schema2);
            registerTextOperators(schema2);
          }
          exports2.registerCommonOperators = registerCommonOperators;
          function* numberPairs() {
            for (const a of datatypes_1.numbers) {
              for (const b of datatypes_1.numbers) {
                yield [a, b, datatypes_1.numberPriorities[a] < datatypes_1.numberPriorities[b] ? b : a];
              }
            }
          }
          function registerNumericOperators(schema2) {
            for (const [left, right, returns] of numberPairs()) {
              schema2.registerOperator({
                operator: "+",
                commutative: true,
                left,
                right,
                returns,
                implementation: (a, b) => a + b
              });
            }
            for (const [left, right, returns] of numberPairs()) {
              schema2.registerOperator({
                operator: "-",
                commutative: true,
                left,
                right,
                returns,
                implementation: (a, b) => a - b
              });
            }
            for (const [left, right, returns] of numberPairs()) {
              schema2.registerOperator({
                operator: "*",
                commutative: true,
                left,
                right,
                returns,
                implementation: (a, b) => a * b
              });
            }
            for (const [left, right, returns] of numberPairs()) {
              schema2.registerOperator({
                operator: "/",
                commutative: false,
                left,
                right,
                returns,
                implementation: (0, datatypes_1.isInteger)(returns) ? (a, b) => Math.trunc(a / b) : (a, b) => a / b
              });
            }
          }
          function registerDatetimeOperators(schema2) {
            for (const dt of datatypes_1.dateTypes) {
              for (const [operator, f] of [["+", 1], ["-", -1]]) {
                schema2.registerOperator({
                  operator,
                  commutative: operator === "+",
                  left: dt,
                  right: datatypes_1.Types.interval,
                  returns: dt,
                  implementation: (a, b) => (0, moment_1.default)(a).add(f * (0, utils_1.intervalToSec)(b), "seconds").toDate()
                });
              }
            }
            for (const [operator, f] of [["+", 1], ["-", -1]]) {
              schema2.registerOperator({
                operator,
                commutative: operator === "+",
                left: datatypes_1.Types.date,
                right: datatypes_1.Types.integer,
                returns: datatypes_1.Types.date,
                implementation: (a, b) => (0, moment_1.default)(a).add(f * b, "days").toDate()
              });
            }
          }
          function registerJsonOperators(schema2) {
            schema2.registerOperator({
              operator: "@>",
              left: datatypes_1.Types.jsonb,
              right: datatypes_1.Types.jsonb,
              returns: datatypes_1.Types.bool,
              implementation: (a, b) => (0, utils_1.queryJson)(b, a)
            });
            schema2.registerOperator({
              operator: "-",
              left: datatypes_1.Types.jsonb,
              right: datatypes_1.Types.text(),
              returns: datatypes_1.Types.jsonb,
              implementation: (a, b) => {
                if (Array.isArray(a)) {
                  return a.filter((x) => x !== b);
                }
                if (typeof a === "object") {
                  const ret = { ...a };
                  delete ret[b];
                  return ret;
                }
                throw new interfaces_private_1.QueryError("cannot delete from scalar", "22023");
              }
            });
            schema2.registerOperator({
              operator: "-",
              left: datatypes_1.Types.jsonb,
              right: datatypes_1.Types.integer,
              returns: datatypes_1.Types.jsonb,
              implementation: (a, b) => {
                if (Array.isArray(a)) {
                  const ret = [...a];
                  ret.splice(b, 1);
                  return ret;
                }
                if (typeof a === "object") {
                  throw new interfaces_private_1.QueryError("cannot delete from object using integer index", "22023");
                }
                throw new interfaces_private_1.QueryError("cannot delete from scalar", "22023");
              }
            });
          }
          function registerTextOperators(schema2) {
            schema2.registerOperator({
              operator: "||",
              left: datatypes_1.Types.text(),
              right: datatypes_1.Types.text(),
              returns: datatypes_1.Types.text(),
              implementation: (a, b) => a + b
            });
          }
        },
        /* 125 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.registerSqlFunctionLanguage = void 0;
          const parse_cache_1 = __webpack_require__(26);
          const interfaces_1 = __webpack_require__(3);
          const utils_1 = __webpack_require__(1);
          const select_1 = __webpack_require__(12);
          const context_1 = __webpack_require__(4);
          const evaluator_1 = __webpack_require__(11);
          const statement_exec_1 = __webpack_require__(34);
          const datatypes_1 = __webpack_require__(2);
          const t_record_1 = __webpack_require__(19);
          let execId = 0;
          function registerSqlFunctionLanguage(db) {
            db.registerLanguage("sql", ({ code, schema: _schema, args, returns: _returns }) => {
              const schema2 = _schema;
              const returns = _returns;
              const _parsed = (0, parse_cache_1.parseSql)(code);
              let parsed;
              if (Array.isArray(_parsed)) {
                if (_parsed.length !== 1) {
                  throw new interfaces_1.QueryError(`Expected 1 statement in function, got ${_parsed.length}`);
                }
                parsed = _parsed[0];
              } else {
                parsed = _parsed;
              }
              switch (parsed.type) {
                case "select":
                case "union":
                case "union all":
                case "with":
                case "with recursive":
                case "values":
                  break;
                default:
                  throw new interfaces_1.NotSupported(`Unsupported statement type in function: ${parsed.type}`);
              }
              const parameterList = (0, evaluator_1.buildParameterList)("", args);
              const statement = new statement_exec_1.StatementExec(schema2, parsed, code);
              const executor = (0, context_1.withParameters)(parameterList, () => statement.compile());
              if (!(executor instanceof select_1.SelectExec)) {
                throw new interfaces_1.NotSupported(`Unsupported statement type in function: ${parsed.type}`);
              }
              let transformResult;
              if (!returns || returns.primary === interfaces_1.DataType.null) {
                transformResult = () => null;
              } else if (datatypes_1.ArrayType.matches(returns) && t_record_1.RecordType.matches(returns.of)) {
                const transformItem = returns.of.transformItemFrom(executor.selection);
                if (!transformItem) {
                  throw new interfaces_1.QueryError(`return type mismatch in function declared to return record`, "42P13");
                }
                transformResult = (v, t2, eid) => v === null || v === void 0 ? void 0 : v.map((x) => {
                  return transformItem(x, t2, eid);
                });
              } else {
                const cols = executor.selection.columns;
                if (cols.length !== 1 || !cols[0].type.canConvertImplicit(returns)) {
                  throw new interfaces_1.QueryError(`return type mismatch in function declared to return ${returns.name}`, "42P13");
                }
                const col = cols[0].cast(returns);
                transformResult = (v, t2) => v[0] ? col.get(v[0], t2) : null;
              }
              const implem = (...args2) => {
                const exec = (0, utils_1.hasExecutionCtx)() ? {
                  // if we have a parent execution context, use it.
                  // except for parameter values, that will be re-bound.
                  ...(0, utils_1.executionCtx)(),
                  parametersValues: args2
                } : {
                  // else, create a brand new execution context.
                  // that is used when a pure function is called with constant arguments:
                  //  => function call will be reduced to a constant based on the
                  //    db state at the time of the statement begining.
                  schema: schema2,
                  transaction: db.data,
                  parametersValues: args2
                };
                const eid = "fne" + execId++;
                return (0, utils_1.pushExecutionCtx)(exec, () => {
                  const ret = executor.execute(exec.transaction);
                  return transformResult(ret.result.rows, exec.transaction, eid);
                });
              };
              return implem;
            });
          }
          exports2.registerSqlFunctionLanguage = registerSqlFunctionLanguage;
        },
        /* 126 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.setupInformationSchema = void 0;
          const columns_list_1 = __webpack_require__(127);
          const table_list_1 = __webpack_require__(128);
          const table_constraints_1 = __webpack_require__(129);
          const key_column_usage_1 = __webpack_require__(130);
          const constraint_column_usage_1 = __webpack_require__(131);
          function setupInformationSchema(db) {
            const schema2 = db.createSchema("information_schema");
            new table_list_1.TablesSchema(schema2).register();
            new columns_list_1.ColumnsListSchema(schema2).register();
            new table_constraints_1.TableConstraints(schema2).register();
            new key_column_usage_1.KeyColumnUsage(schema2).register();
            new constraint_column_usage_1.ConstraintColumnUsage(schema2).register();
            schema2.setReadonly();
          }
          exports2.setupInformationSchema = setupInformationSchema;
        },
        /* 127 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ColumnsListSchema = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatypes_1 = __webpack_require__(2);
          const table_index_1 = __webpack_require__(27);
          const readonly_table_1 = __webpack_require__(8);
          const IS_SCHEMA = Symbol("_is_colmun");
          class ColumnsListSchema extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "columns",
                fields: [
                  { name: "table_catalog", type: datatypes_1.Types.text() },
                  { name: "table_schema", type: datatypes_1.Types.text() },
                  { name: "table_name", type: datatypes_1.Types.text() },
                  { name: "column_name", type: datatypes_1.Types.text() },
                  { name: "ordinal_position", type: datatypes_1.Types.integer },
                  { name: "column_default", type: datatypes_1.Types.text() },
                  { name: "is_nullable", type: datatypes_1.Types.text(3) },
                  { name: "data_type", type: datatypes_1.Types.text() },
                  { name: "character_maximum_length", type: datatypes_1.Types.integer },
                  { name: "character_octet_length", type: datatypes_1.Types.integer },
                  { name: "numeric_precision", type: datatypes_1.Types.integer },
                  { name: "numeric_precision_radix", type: datatypes_1.Types.integer },
                  { name: "numeric_scale", type: datatypes_1.Types.integer },
                  { name: "datetime_precision", type: datatypes_1.Types.integer },
                  { name: "interval_type", type: datatypes_1.Types.text() },
                  { name: "interval_precision", type: datatypes_1.Types.integer },
                  { name: "character_set_catalog", type: datatypes_1.Types.text() },
                  { name: "character_set_schema", type: datatypes_1.Types.text() },
                  { name: "character_set_name", type: datatypes_1.Types.text() },
                  { name: "collation_catalog", type: datatypes_1.Types.text() },
                  { name: "collation_schema", type: datatypes_1.Types.text() },
                  { name: "collation_name", type: datatypes_1.Types.text() },
                  { name: "domain_catalog", type: datatypes_1.Types.text() },
                  { name: "domain_schema", type: datatypes_1.Types.text() },
                  { name: "domain_name", type: datatypes_1.Types.text() },
                  { name: "udt_catalog", type: datatypes_1.Types.text() },
                  { name: "udt_schema", type: datatypes_1.Types.text() },
                  { name: "udt_name", type: datatypes_1.Types.text() },
                  { name: "scope_catalog", type: datatypes_1.Types.text() },
                  { name: "scope_schema", type: datatypes_1.Types.text() },
                  { name: "scope_name", type: datatypes_1.Types.text() },
                  { name: "maximum_cardinality", type: datatypes_1.Types.integer },
                  { name: "dtd_identifier", type: datatypes_1.Types.integer },
                  { name: "is_self_referencing", type: datatypes_1.Types.text(3) },
                  { name: "is_identity", type: datatypes_1.Types.text(3) },
                  { name: "identity_generation", type: datatypes_1.Types.text() },
                  { name: "identity_start", type: datatypes_1.Types.text() },
                  { name: "identity_document", type: datatypes_1.Types.text() },
                  { name: "identity_increment", type: datatypes_1.Types.text() },
                  { name: "identity_maximum", type: datatypes_1.Types.text() },
                  { name: "identity_minimum", type: datatypes_1.Types.text() },
                  { name: "identity_cycle", type: datatypes_1.Types.text(3) },
                  { name: "is_generated", type: datatypes_1.Types.text() },
                  { name: "generation_expression", type: datatypes_1.Types.text() },
                  { name: "is_updatable", type: datatypes_1.Types.text(3) }
                  // <==
                ]
              };
            }
            get ownSymbol() {
              return IS_SCHEMA;
            }
            entropy(t2) {
              return this.db.listSchemas().reduce((tot, s) => tot + s.tablesCount(t2) * 10, 0);
            }
            *enumerate(t2) {
              for (const s of this.db.listSchemas()) {
                for (const it of s.listTables(t2)) {
                  yield* this.itemsByTable(it, t2);
                }
              }
            }
            make(table, i, t2) {
              if (!t2) {
                return null;
              }
              let ret = {};
              for (const { name } of this._schema.fields) {
                ret[name] = null;
              }
              ret = {
                ...ret,
                table_catalog: "pgmem",
                table_schema: "public",
                table_name: table.name,
                column_name: t2.id,
                ordinal_position: i,
                is_nullable: "NO",
                data_type: t2.type.primary,
                numeric_precision: null,
                numeric_precision_radix: null,
                numeric_scale: null,
                udt_catalog: "pgmem",
                udt_schema: "pg_catalog",
                udt_name: t2.type.primary,
                dtd_identifier: i,
                is_self_referencing: "NO",
                is_identity: "NO",
                is_updatable: "YES",
                is_generated: "NEVER",
                identity_cycle: "NO",
                [IS_SCHEMA]: true
              };
              (0, interfaces_private_1.setId)(ret, `/schema/${table.ownerSchema.name}/table/${table.name}/${i}`);
              return ret;
            }
            hasItem(value2) {
              return !!(value2 === null || value2 === void 0 ? void 0 : value2[IS_SCHEMA]);
            }
            getIndex(forValue) {
              if (forValue.id === "table_name") {
                return new table_index_1.TableIndex(this, forValue);
              }
              return null;
            }
          }
          exports2.ColumnsListSchema = ColumnsListSchema;
        },
        /* 128 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TablesSchema = void 0;
          const interfaces_private_1 = __webpack_require__(0);
          const datatypes_1 = __webpack_require__(2);
          const table_index_1 = __webpack_require__(27);
          const readonly_table_1 = __webpack_require__(8);
          const IS_SCHEMA = Symbol("_is_schema");
          class TablesSchema extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "tables",
                fields: [
                  { name: "table_catalog", type: datatypes_1.Types.text() },
                  { name: "table_schema", type: datatypes_1.Types.text() },
                  { name: "table_name", type: datatypes_1.Types.text() },
                  { name: "table_type", type: datatypes_1.Types.text() },
                  { name: "self_referencing_column_name", type: datatypes_1.Types.text() },
                  { name: "reference_generation", type: datatypes_1.Types.text() },
                  { name: "user_defined_type_catalog", type: datatypes_1.Types.text() },
                  { name: "user_defined_type_schema", type: datatypes_1.Types.text() },
                  { name: "user_defined_type_name", type: datatypes_1.Types.text() },
                  { name: "is_insertable_into", type: datatypes_1.Types.text(3) },
                  { name: "is_typed", type: datatypes_1.Types.text(3) },
                  { name: "commit_action", type: datatypes_1.Types.text() }
                ]
              };
            }
            get ownSymbol() {
              return IS_SCHEMA;
            }
            isOriginOf(v) {
              return v.origin === this || v.origin === this.selection;
            }
            entropy(t2) {
              return this.db.listSchemas().reduce((tot, s) => tot + s.tablesCount(t2), 0);
            }
            *enumerate(t2) {
              for (const s of this.db.listSchemas()) {
                for (const it of s.listTables(t2)) {
                  yield this.make(it);
                }
              }
            }
            make(t2) {
              if (!t2) {
                return null;
              }
              const ret = {
                table_catalog: "pgmem",
                table_schema: "public",
                table_name: t2.name,
                table_type: "BASE TABLE",
                self_referencing_column_name: null,
                reference_generation: null,
                user_defined_type_catalog: null,
                user_defined_type_schema: null,
                user_defined_type_name: null,
                is_insertable_into: "YES",
                is_typed: "NO",
                commit_action: null,
                [IS_SCHEMA]: true
              };
              (0, interfaces_private_1.setId)(ret, "/schema/table/" + t2.name);
              return ret;
            }
            hasItem(value2) {
              return !!(value2 === null || value2 === void 0 ? void 0 : value2[IS_SCHEMA]);
            }
            getIndex(forValue) {
              if ((forValue === null || forValue === void 0 ? void 0 : forValue.id) === "table_name") {
                return new table_index_1.TableIndex(this, forValue);
              }
              return null;
            }
          }
          exports2.TablesSchema = TablesSchema;
        },
        /* 129 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TableConstraints = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class TableConstraints extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "table_constraints",
                fields: [
                  { name: "constraint_catalog", type: datatypes_1.Types.text() },
                  { name: "constraint_schema", type: datatypes_1.Types.text() },
                  { name: "constraint_name", type: datatypes_1.Types.text() },
                  { name: "table_catalog", type: datatypes_1.Types.text() },
                  { name: "table_schema", type: datatypes_1.Types.text() },
                  { name: "table_name", type: datatypes_1.Types.text() },
                  { name: "constraint_type", type: datatypes_1.Types.text() },
                  { name: "is_deferrable", type: datatypes_1.Types.bool },
                  { name: "initially_deferred", type: datatypes_1.Types.bool },
                  { name: "enforced", type: datatypes_1.Types.bool }
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.TableConstraints = TableConstraints;
        },
        /* 130 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.KeyColumnUsage = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class KeyColumnUsage extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "key_column_usage",
                fields: [
                  { name: "constraint_catalog", type: datatypes_1.Types.text() },
                  { name: "constraint_schema", type: datatypes_1.Types.text() },
                  { name: "constraint_name", type: datatypes_1.Types.text() },
                  { name: "table_catalog", type: datatypes_1.Types.text() },
                  { name: "table_schema", type: datatypes_1.Types.text() },
                  { name: "table_name", type: datatypes_1.Types.text() },
                  { name: "column_name", type: datatypes_1.Types.text() },
                  { name: "ordinal_position", type: datatypes_1.Types.integer },
                  { name: "position_in_unique_constraint", type: datatypes_1.Types.integer }
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.KeyColumnUsage = KeyColumnUsage;
        },
        /* 131 */
        /***/
        function(module3, exports2, __webpack_require__) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.ConstraintColumnUsage = void 0;
          const datatypes_1 = __webpack_require__(2);
          const readonly_table_1 = __webpack_require__(8);
          class ConstraintColumnUsage extends readonly_table_1.ReadOnlyTable {
            constructor() {
              super(...arguments);
              this._schema = {
                name: "constraint_column_usage",
                fields: [
                  { name: "constraint_catalog", type: datatypes_1.Types.text() },
                  { name: "constraint_schema", type: datatypes_1.Types.text() },
                  { name: "constraint_name", type: datatypes_1.Types.text() },
                  { name: "table_catalog", type: datatypes_1.Types.text() },
                  { name: "table_schema", type: datatypes_1.Types.text() },
                  { name: "table_name", type: datatypes_1.Types.text() },
                  { name: "column_name", type: datatypes_1.Types.text() }
                ]
              };
            }
            entropy() {
              return 0;
            }
            *enumerate() {
            }
            hasItem(value2) {
              return false;
            }
          }
          exports2.ConstraintColumnUsage = ConstraintColumnUsage;
        }
        /******/
      ])
    );
  }
});

// src/app.ts
var import_express = __toESM(require("express"));
var import_express2 = require("@trpc/server/adapters/express");
var import_cors = __toESM(require("cors"));
var import_trpc_panel = require("trpc-panel");

// src/trpc/index.ts
var import_server = require("@trpc/server");

// ../node_modules/superjson/dist/double-indexed-kv.js
var DoubleIndexedKV = class {
  constructor() {
    this.keyToValue = /* @__PURE__ */ new Map();
    this.valueToKey = /* @__PURE__ */ new Map();
  }
  set(key, value2) {
    this.keyToValue.set(key, value2);
    this.valueToKey.set(value2, key);
  }
  getByKey(key) {
    return this.keyToValue.get(key);
  }
  getByValue(value2) {
    return this.valueToKey.get(value2);
  }
  clear() {
    this.keyToValue.clear();
    this.valueToKey.clear();
  }
};

// ../node_modules/superjson/dist/registry.js
var Registry = class {
  constructor(generateIdentifier) {
    this.generateIdentifier = generateIdentifier;
    this.kv = new DoubleIndexedKV();
  }
  register(value2, identifier) {
    if (this.kv.getByValue(value2)) {
      return;
    }
    if (!identifier) {
      identifier = this.generateIdentifier(value2);
    }
    this.kv.set(identifier, value2);
  }
  clear() {
    this.kv.clear();
  }
  getIdentifier(value2) {
    return this.kv.getByValue(value2);
  }
  getValue(identifier) {
    return this.kv.getByKey(identifier);
  }
};

// ../node_modules/superjson/dist/class-registry.js
var ClassRegistry = class extends Registry {
  constructor() {
    super((c) => c.name);
    this.classToAllowedProps = /* @__PURE__ */ new Map();
  }
  register(value2, options) {
    if (typeof options === "object") {
      if (options.allowProps) {
        this.classToAllowedProps.set(value2, options.allowProps);
      }
      super.register(value2, options.identifier);
    } else {
      super.register(value2, options);
    }
  }
  getAllowedProps(value2) {
    return this.classToAllowedProps.get(value2);
  }
};

// ../node_modules/superjson/dist/util.js
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  const values2 = [];
  for (const key in record) {
    if (record.hasOwnProperty(key)) {
      values2.push(record[key]);
    }
  }
  return values2;
}
function find(record, predicate) {
  const values2 = valuesOfObj(record);
  if ("find" in values2) {
    return values2.find(predicate);
  }
  const valuesNotNever = values2;
  for (let i = 0; i < valuesNotNever.length; i++) {
    const value2 = valuesNotNever[i];
    if (predicate(value2)) {
      return value2;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(([key, value2]) => run(value2, key));
}
function includes(arr, value2) {
  return arr.indexOf(value2) !== -1;
}
function findArr(record, predicate) {
  for (let i = 0; i < record.length; i++) {
    const value2 = record[i];
    if (predicate(value2)) {
      return value2;
    }
  }
  return void 0;
}

// ../node_modules/superjson/dist/custom-transformer-registry.js
var CustomTransformerRegistry = class {
  constructor() {
    this.transfomers = {};
  }
  register(transformer) {
    this.transfomers[transformer.name] = transformer;
  }
  findApplicable(v) {
    return find(this.transfomers, (transformer) => transformer.isApplicable(v));
  }
  findByName(name) {
    return this.transfomers[name];
  }
};

// ../node_modules/superjson/dist/is.js
var getType = (payload) => Object.prototype.toString.call(payload).slice(8, -1);
var isUndefined = (payload) => typeof payload === "undefined";
var isNull = (payload) => payload === null;
var isPlainObject = (payload) => {
  if (typeof payload !== "object" || payload === null)
    return false;
  if (payload === Object.prototype)
    return false;
  if (Object.getPrototypeOf(payload) === null)
    return true;
  return Object.getPrototypeOf(payload) === Object.prototype;
};
var isEmptyObject = (payload) => isPlainObject(payload) && Object.keys(payload).length === 0;
var isArray = (payload) => Array.isArray(payload);
var isString = (payload) => typeof payload === "string";
var isNumber = (payload) => typeof payload === "number" && !isNaN(payload);
var isBoolean = (payload) => typeof payload === "boolean";
var isRegExp = (payload) => payload instanceof RegExp;
var isMap = (payload) => payload instanceof Map;
var isSet = (payload) => payload instanceof Set;
var isSymbol = (payload) => getType(payload) === "Symbol";
var isDate = (payload) => payload instanceof Date && !isNaN(payload.valueOf());
var isError = (payload) => payload instanceof Error;
var isNaNValue = (payload) => typeof payload === "number" && isNaN(payload);
var isPrimitive = (payload) => isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
var isBigint = (payload) => typeof payload === "bigint";
var isInfinite = (payload) => payload === Infinity || payload === -Infinity;
var isTypedArray = (payload) => ArrayBuffer.isView(payload) && !(payload instanceof DataView);
var isURL = (payload) => payload instanceof URL;

// ../node_modules/superjson/dist/pathstringifier.js
var escapeKey = (key) => key.replace(/\./g, "\\.");
var stringifyPath = (path) => path.map(String).map(escapeKey).join(".");
var parsePath = (string2) => {
  const result = [];
  let segment = "";
  for (let i = 0; i < string2.length; i++) {
    let char = string2.charAt(i);
    const isEscapedDot = char === "\\" && string2.charAt(i + 1) === ".";
    if (isEscapedDot) {
      segment += ".";
      i++;
      continue;
    }
    const isEndOfSegment = char === ".";
    if (isEndOfSegment) {
      result.push(segment);
      segment = "";
      continue;
    }
    segment += char;
  }
  const lastSegment = segment;
  result.push(lastSegment);
  return result;
};

// ../node_modules/superjson/dist/transformer.js
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var simpleRules = [
  simpleTransformation(isUndefined, "undefined", () => null, () => void 0),
  simpleTransformation(isBigint, "bigint", (v) => v.toString(), (v) => {
    if (typeof BigInt !== "undefined") {
      return BigInt(v);
    }
    console.error("Please add a BigInt polyfill.");
    return v;
  }),
  simpleTransformation(isDate, "Date", (v) => v.toISOString(), (v) => new Date(v)),
  simpleTransformation(isError, "Error", (v, superJson) => {
    const baseError = {
      name: v.name,
      message: v.message
    };
    superJson.allowedErrorProps.forEach((prop) => {
      baseError[prop] = v[prop];
    });
    return baseError;
  }, (v, superJson) => {
    const e = new Error(v.message);
    e.name = v.name;
    e.stack = v.stack;
    superJson.allowedErrorProps.forEach((prop) => {
      e[prop] = v[prop];
    });
    return e;
  }),
  simpleTransformation(isRegExp, "regexp", (v) => "" + v, (regex) => {
    const body = regex.slice(1, regex.lastIndexOf("/"));
    const flags = regex.slice(regex.lastIndexOf("/") + 1);
    return new RegExp(body, flags);
  }),
  simpleTransformation(
    isSet,
    "set",
    // (sets only exist in es6+)
    // eslint-disable-next-line es5/no-es6-methods
    (v) => [...v.values()],
    (v) => new Set(v)
  ),
  simpleTransformation(isMap, "map", (v) => [...v.entries()], (v) => new Map(v)),
  simpleTransformation((v) => isNaNValue(v) || isInfinite(v), "number", (v) => {
    if (isNaNValue(v)) {
      return "NaN";
    }
    if (v > 0) {
      return "Infinity";
    } else {
      return "-Infinity";
    }
  }, Number),
  simpleTransformation((v) => v === 0 && 1 / v === -Infinity, "number", () => {
    return "-0";
  }, Number),
  simpleTransformation(isURL, "URL", (v) => v.toString(), (v) => new URL(v))
];
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
var symbolRule = compositeTransformation((s, superJson) => {
  if (isSymbol(s)) {
    const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
    return isRegistered;
  }
  return false;
}, (s, superJson) => {
  const identifier = superJson.symbolRegistry.getIdentifier(s);
  return ["symbol", identifier];
}, (v) => v.description, (_, a, superJson) => {
  const value2 = superJson.symbolRegistry.getValue(a[1]);
  if (!value2) {
    throw new Error("Trying to deserialize unknown symbol");
  }
  return value2;
});
var constructorToName = [
  Int8Array,
  Uint8Array,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
  Uint8ClampedArray
].reduce((obj, ctor) => {
  obj[ctor.name] = ctor;
  return obj;
}, {});
var typedArrayRule = compositeTransformation(isTypedArray, (v) => ["typed-array", v.constructor.name], (v) => [...v], (v, a) => {
  const ctor = constructorToName[a[1]];
  if (!ctor) {
    throw new Error("Trying to deserialize unknown typed array");
  }
  return new ctor(v);
});
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass?.constructor) {
    const isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var classRule = compositeTransformation(isInstanceOfRegisteredClass, (clazz, superJson) => {
  const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
  return ["class", identifier];
}, (clazz, superJson) => {
  const allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
  if (!allowedProps) {
    return { ...clazz };
  }
  const result = {};
  allowedProps.forEach((prop) => {
    result[prop] = clazz[prop];
  });
  return result;
}, (v, a, superJson) => {
  const clazz = superJson.classRegistry.getValue(a[1]);
  if (!clazz) {
    throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
  }
  return Object.assign(Object.create(clazz.prototype), v);
});
var customRule = compositeTransformation((value2, superJson) => {
  return !!superJson.customTransformerRegistry.findApplicable(value2);
}, (value2, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value2);
  return ["custom", transformer.name];
}, (value2, superJson) => {
  const transformer = superJson.customTransformerRegistry.findApplicable(value2);
  return transformer.serialize(value2);
}, (v, a, superJson) => {
  const transformer = superJson.customTransformerRegistry.findByName(a[1]);
  if (!transformer) {
    throw new Error("Trying to deserialize unknown custom value");
  }
  return transformer.deserialize(v);
});
var compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
var transformValue = (value2, superJson) => {
  const applicableCompositeRule = findArr(compositeRules, (rule) => rule.isApplicable(value2, superJson));
  if (applicableCompositeRule) {
    return {
      value: applicableCompositeRule.transform(value2, superJson),
      type: applicableCompositeRule.annotation(value2, superJson)
    };
  }
  const applicableSimpleRule = findArr(simpleRules, (rule) => rule.isApplicable(value2, superJson));
  if (applicableSimpleRule) {
    return {
      value: applicableSimpleRule.transform(value2, superJson),
      type: applicableSimpleRule.annotation
    };
  }
  return void 0;
};
var simpleRulesByAnnotation = {};
simpleRules.forEach((rule) => {
  simpleRulesByAnnotation[rule.annotation] = rule;
});
var untransformValue = (json, type, superJson) => {
  if (isArray(type)) {
    switch (type[0]) {
      case "symbol":
        return symbolRule.untransform(json, type, superJson);
      case "class":
        return classRule.untransform(json, type, superJson);
      case "custom":
        return customRule.untransform(json, type, superJson);
      case "typed-array":
        return typedArrayRule.untransform(json, type, superJson);
      default:
        throw new Error("Unknown transformation: " + type);
    }
  } else {
    const transformation = simpleRulesByAnnotation[type];
    if (!transformation) {
      throw new Error("Unknown transformation: " + type);
    }
    return transformation.untransform(json, superJson);
  }
};

// ../node_modules/superjson/dist/accessDeep.js
var getNthKey = (value2, n) => {
  const keys2 = value2.keys();
  while (n > 0) {
    keys2.next();
    n--;
  }
  return keys2.next().value;
};
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getDeep = (object, path) => {
  validatePath(path);
  for (let i = 0; i < path.length; i++) {
    const key = path[i];
    if (isSet(object)) {
      object = getNthKey(object, +key);
    } else if (isMap(object)) {
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(object, row);
      switch (type) {
        case "key":
          object = keyOfRow;
          break;
        case "value":
          object = object.get(keyOfRow);
          break;
      }
    } else {
      object = object[key];
    }
  }
  return object;
};
var setDeep = (object, path, mapper) => {
  validatePath(path);
  if (path.length === 0) {
    return mapper(object);
  }
  let parent = object;
  for (let i = 0; i < path.length - 1; i++) {
    const key = path[i];
    if (isArray(parent)) {
      const index = +key;
      parent = parent[index];
    } else if (isPlainObject(parent)) {
      parent = parent[key];
    } else if (isSet(parent)) {
      const row = +key;
      parent = getNthKey(parent, row);
    } else if (isMap(parent)) {
      const isEnd = i === path.length - 2;
      if (isEnd) {
        break;
      }
      const row = +key;
      const type = +path[++i] === 0 ? "key" : "value";
      const keyOfRow = getNthKey(parent, row);
      switch (type) {
        case "key":
          parent = keyOfRow;
          break;
        case "value":
          parent = parent.get(keyOfRow);
          break;
      }
    }
  }
  const lastKey = path[path.length - 1];
  if (isArray(parent)) {
    parent[+lastKey] = mapper(parent[+lastKey]);
  } else if (isPlainObject(parent)) {
    parent[lastKey] = mapper(parent[lastKey]);
  }
  if (isSet(parent)) {
    const oldValue = getNthKey(parent, +lastKey);
    const newValue = mapper(oldValue);
    if (oldValue !== newValue) {
      parent.delete(oldValue);
      parent.add(newValue);
    }
  }
  if (isMap(parent)) {
    const row = +path[path.length - 2];
    const keyToRow = getNthKey(parent, row);
    const type = +lastKey === 0 ? "key" : "value";
    switch (type) {
      case "key": {
        const newKey = mapper(keyToRow);
        parent.set(newKey, parent.get(keyToRow));
        if (newKey !== keyToRow) {
          parent.delete(keyToRow);
        }
        break;
      }
      case "value": {
        parent.set(keyToRow, mapper(parent.get(keyToRow)));
        break;
      }
    }
  }
  return object;
};

// ../node_modules/superjson/dist/plainer.js
function traverse(tree, walker2, origin = []) {
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, (subtree, key) => traverse(subtree, walker2, [...origin, ...parsePath(key)]));
    return;
  }
  const [nodeValue, children] = tree;
  if (children) {
    forEach(children, (child, key) => {
      traverse(child, walker2, [...origin, ...parsePath(key)]);
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, (type, path) => {
    plain = setDeep(plain, path, (v) => untransformValue(v, type, superJson));
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    const object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach((identicalObjectPath) => {
      plain = setDeep(plain, identicalObjectPath, () => object);
    });
  }
  if (isArray(annotations)) {
    const [root, other] = annotations;
    root.forEach((identicalPath) => {
      plain = setDeep(plain, parsePath(identicalPath), () => plain);
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
var isDeep = (object, superJson) => isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
function addIdentity(object, path, identities) {
  const existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  const result = {};
  let rootEqualityPaths = void 0;
  identitites.forEach((paths) => {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map((path) => path.map(String)).sort((a, b) => a.length - b.length);
    }
    const [representativePath, ...identicalPaths] = paths;
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var walker = (object, identities, superJson, dedupe, path = [], objectsInThisPath = [], seenObjects = /* @__PURE__ */ new Map()) => {
  const primitive = isPrimitive(object);
  if (!primitive) {
    addIdentity(object, path, identities);
    const seen = seenObjects.get(object);
    if (seen) {
      return dedupe ? {
        transformedValue: null
      } : seen;
    }
  }
  if (!isDeep(object, superJson)) {
    const transformed2 = transformValue(object, superJson);
    const result2 = transformed2 ? {
      transformedValue: transformed2.value,
      annotations: [transformed2.type]
    } : {
      transformedValue: object
    };
    if (!primitive) {
      seenObjects.set(object, result2);
    }
    return result2;
  }
  if (includes(objectsInThisPath, object)) {
    return {
      transformedValue: null
    };
  }
  const transformationResult = transformValue(object, superJson);
  const transformed = transformationResult?.value ?? object;
  const transformedValue = isArray(transformed) ? [] : {};
  const innerAnnotations = {};
  forEach(transformed, (value2, index) => {
    if (index === "__proto__" || index === "constructor" || index === "prototype") {
      throw new Error(`Detected property ${index}. This is a prototype pollution risk, please remove it from your object.`);
    }
    const recursiveResult = walker(value2, identities, superJson, dedupe, [...path, index], [...objectsInThisPath, object], seenObjects);
    transformedValue[index] = recursiveResult.transformedValue;
    if (isArray(recursiveResult.annotations)) {
      innerAnnotations[index] = recursiveResult.annotations;
    } else if (isPlainObject(recursiveResult.annotations)) {
      forEach(recursiveResult.annotations, (tree, key) => {
        innerAnnotations[escapeKey(index) + "." + key] = tree;
      });
    }
  });
  const result = isEmptyObject(innerAnnotations) ? {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type] : void 0
  } : {
    transformedValue,
    annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
  };
  if (!primitive) {
    seenObjects.set(object, result);
  }
  return result;
};

// ../node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value2) => a(value2) || b(value2) || !!c && c(value2) || !!d && d(value2) || !!e && e(value2);
}
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
var isNullOrUndefined = isOneOf(isNull2, isUndefined2);

// ../node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}

// ../node_modules/superjson/dist/index.js
var SuperJSON = class {
  /**
   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.
   */
  constructor({ dedupe = false } = {}) {
    this.classRegistry = new ClassRegistry();
    this.symbolRegistry = new Registry((s) => s.description ?? "");
    this.customTransformerRegistry = new CustomTransformerRegistry();
    this.allowedErrorProps = [];
    this.dedupe = dedupe;
  }
  serialize(object) {
    const identities = /* @__PURE__ */ new Map();
    const output = walker(object, identities, this, this.dedupe);
    const res = {
      json: output.transformedValue
    };
    if (output.annotations) {
      res.meta = {
        ...res.meta,
        values: output.annotations
      };
    }
    const equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
    if (equalityAnnotations) {
      res.meta = {
        ...res.meta,
        referentialEqualities: equalityAnnotations
      };
    }
    return res;
  }
  deserialize(payload) {
    const { json, meta } = payload;
    let result = copy(json);
    if (meta?.values) {
      result = applyValueAnnotations(result, meta.values, this);
    }
    if (meta?.referentialEqualities) {
      result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
    }
    return result;
  }
  stringify(object) {
    return JSON.stringify(this.serialize(object));
  }
  parse(string2) {
    return this.deserialize(JSON.parse(string2));
  }
  registerClass(v, options) {
    this.classRegistry.register(v, options);
  }
  registerSymbol(v, identifier) {
    this.symbolRegistry.register(v, identifier);
  }
  registerCustom(transformer, name) {
    this.customTransformerRegistry.register({
      name,
      ...transformer
    });
  }
  allowErrorProps(...props) {
    this.allowedErrorProps.push(...props);
  }
};
SuperJSON.defaultInstance = new SuperJSON();
SuperJSON.serialize = SuperJSON.defaultInstance.serialize.bind(SuperJSON.defaultInstance);
SuperJSON.deserialize = SuperJSON.defaultInstance.deserialize.bind(SuperJSON.defaultInstance);
SuperJSON.stringify = SuperJSON.defaultInstance.stringify.bind(SuperJSON.defaultInstance);
SuperJSON.parse = SuperJSON.defaultInstance.parse.bind(SuperJSON.defaultInstance);
SuperJSON.registerClass = SuperJSON.defaultInstance.registerClass.bind(SuperJSON.defaultInstance);
SuperJSON.registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(SuperJSON.defaultInstance);
SuperJSON.registerCustom = SuperJSON.defaultInstance.registerCustom.bind(SuperJSON.defaultInstance);
SuperJSON.allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(SuperJSON.defaultInstance);
var serialize = SuperJSON.serialize;
var deserialize = SuperJSON.deserialize;
var stringify = SuperJSON.stringify;
var parse = SuperJSON.parse;
var registerClass = SuperJSON.registerClass;
var registerCustom = SuperJSON.registerCustom;
var registerSymbol = SuperJSON.registerSymbol;
var allowErrorProps = SuperJSON.allowErrorProps;

// src/trpc/index.ts
var import_zod = require("zod");
var import_zod_validation_error = require("zod-validation-error");
var t = import_server.initTRPC.context().meta().create({
  transformer: SuperJSON,
  errorFormatter(opts) {
    const { shape, error } = opts;
    if (error.cause instanceof import_zod.ZodError) {
      const validationError = (0, import_zod_validation_error.fromZodError)(error.cause);
      return {
        ...shape,
        data: {
          message: validationError.message
        }
      };
    }
    return shape;
  }
});
var {
  middleware,
  router,
  procedure: publicProcedure,
  mergeRouters
} = t;

// src/entities/index.ts
var entities_exports = {};
__export(entities_exports, {
  Category: () => Category,
  Item: () => Item,
  Message: () => Message,
  Room: () => Room,
  User: () => User
});

// src/entities/item/item.ts
var import_typeorm = require("typeorm");
var Item = class {
  id;
  name;
  description;
  imageUrl;
  price;
  width;
  length;
  x;
  y;
  categories;
  room;
};
__decorateClass([
  (0, import_typeorm.PrimaryGeneratedColumn)("increment")
], Item.prototype, "id", 2);
__decorateClass([
  (0, import_typeorm.Column)("text")
], Item.prototype, "name", 2);
__decorateClass([
  (0, import_typeorm.Column)("text")
], Item.prototype, "description", 2);
__decorateClass([
  (0, import_typeorm.Column)("text")
], Item.prototype, "imageUrl", 2);
__decorateClass([
  (0, import_typeorm.Column)("integer")
], Item.prototype, "price", 2);
__decorateClass([
  (0, import_typeorm.Column)("integer")
], Item.prototype, "width", 2);
__decorateClass([
  (0, import_typeorm.Column)("integer")
], Item.prototype, "length", 2);
__decorateClass([
  (0, import_typeorm.Column)("float", { default: 0 })
], Item.prototype, "x", 2);
__decorateClass([
  (0, import_typeorm.Column)("float", { default: 0 })
], Item.prototype, "y", 2);
__decorateClass([
  (0, import_typeorm.ManyToMany)(() => Category, (category) => category.items),
  (0, import_typeorm.JoinTable)()
], Item.prototype, "categories", 2);
__decorateClass([
  (0, import_typeorm.ManyToOne)(() => Room, (room) => room.items, { nullable: true, onDelete: "CASCADE" })
], Item.prototype, "room", 2);
Item = __decorateClass([
  (0, import_typeorm.Entity)()
], Item);

// src/entities/category/category.ts
var import_typeorm2 = require("typeorm");
var Category = class {
  id;
  name;
  items;
};
__decorateClass([
  (0, import_typeorm2.PrimaryGeneratedColumn)("increment")
], Category.prototype, "id", 2);
__decorateClass([
  (0, import_typeorm2.Column)("text")
], Category.prototype, "name", 2);
__decorateClass([
  (0, import_typeorm2.ManyToMany)(() => Item, (item) => item.categories)
], Category.prototype, "items", 2);
Category = __decorateClass([
  (0, import_typeorm2.Entity)()
], Category);

// src/entities/user/user.ts
var import_typeorm4 = require("typeorm");

// src/entities/message/message.ts
var import_typeorm3 = require("typeorm");
var Message = class {
  id;
  role;
  content;
  user;
};
__decorateClass([
  (0, import_typeorm3.PrimaryGeneratedColumn)("increment")
], Message.prototype, "id", 2);
__decorateClass([
  (0, import_typeorm3.Column)("text")
], Message.prototype, "role", 2);
__decorateClass([
  (0, import_typeorm3.Column)("text")
], Message.prototype, "content", 2);
__decorateClass([
  (0, import_typeorm3.ManyToOne)(() => User, (user) => user.rooms, { onDelete: "CASCADE" })
], Message.prototype, "user", 2);
Message = __decorateClass([
  (0, import_typeorm3.Entity)()
], Message);

// src/entities/user/user.ts
var User = class {
  id;
  email;
  password;
  rooms;
  messages;
};
__decorateClass([
  (0, import_typeorm4.PrimaryGeneratedColumn)("increment")
], User.prototype, "id", 2);
__decorateClass([
  (0, import_typeorm4.Unique)(["email"]),
  (0, import_typeorm4.Column)("text")
], User.prototype, "email", 2);
__decorateClass([
  (0, import_typeorm4.Column)("text", { select: false })
], User.prototype, "password", 2);
__decorateClass([
  (0, import_typeorm4.OneToMany)(() => Room, (room) => room.user, { cascade: true })
], User.prototype, "rooms", 2);
__decorateClass([
  (0, import_typeorm4.OneToMany)(() => Message, (message) => message.user, { cascade: true })
], User.prototype, "messages", 2);
User = __decorateClass([
  (0, import_typeorm4.Entity)()
], User);

// src/entities/room/room.ts
var import_typeorm5 = require("typeorm");
var Room = class {
  id;
  name;
  width;
  length;
  area;
  user;
  items;
};
__decorateClass([
  (0, import_typeorm5.PrimaryGeneratedColumn)("increment")
], Room.prototype, "id", 2);
__decorateClass([
  (0, import_typeorm5.Column)("text")
], Room.prototype, "name", 2);
__decorateClass([
  (0, import_typeorm5.Column)("float")
], Room.prototype, "width", 2);
__decorateClass([
  (0, import_typeorm5.Column)("float")
], Room.prototype, "length", 2);
__decorateClass([
  (0, import_typeorm5.Column)("float", { default: 0 })
], Room.prototype, "area", 2);
__decorateClass([
  (0, import_typeorm5.ManyToOne)(() => User, (user) => user.rooms, { onDelete: "CASCADE" })
], Room.prototype, "user", 2);
__decorateClass([
  (0, import_typeorm5.OneToMany)(() => Item, (item) => item.room, {
    nullable: true
  })
], Room.prototype, "items", 2);
Room = __decorateClass([
  (0, import_typeorm5.Entity)()
], Room);

// src/modules/user/login/index.ts
var import_server2 = require("@trpc/server");
var import_bcrypt = __toESM(require("bcrypt"));
var import_jsonwebtoken = __toESM(require("jsonwebtoken"));

// src/config.ts
var import_config = require("dotenv/config");
var import_zod2 = __toESM(require("zod"));
var { env } = process;
if (!env.NODE_ENV)
  env.NODE_ENV = "development";
var isTest = env.NODE_ENV === "test";
var isDevTest = env.NODE_ENV === "development" || isTest;
var isInMemory = env.DB_TYPE === "pg-mem";
var schema = import_zod2.default.object({
  env: import_zod2.default.enum(["development", "production", "staging", "test"]).default("development"),
  isCi: import_zod2.default.coerce.boolean().default(false),
  port: import_zod2.default.coerce.number().default(3e3),
  auth: import_zod2.default.object({
    tokenKey: import_zod2.default.string().default(() => {
      if (isDevTest) {
        return "";
      }
      throw new Error(
        "You must provide a token key in production env!"
      );
    }),
    expiresIn: import_zod2.default.string().default("7d"),
    passwordCost: import_zod2.default.coerce.number().default(isDevTest ? 6 : 12)
  }),
  database: import_zod2.default.object({
    type: import_zod2.default.enum([
      "postgres",
      "mysql",
      "mariadb",
      "better-sqlite3",
      "pg-mem"
    ]).default("postgres"),
    host: import_zod2.default.string().default("localhost"),
    port: import_zod2.default.coerce.number().default(5432),
    database: isInMemory ? import_zod2.default.string().optional() : import_zod2.default.string(),
    username: isInMemory ? import_zod2.default.string().optional() : import_zod2.default.string(),
    password: isInMemory ? import_zod2.default.string().optional() : import_zod2.default.string(),
    // By default, log and synchronize the database schema only for tests and development.
    logging: import_zod2.default.preprocess(
      coerceBoolean,
      import_zod2.default.boolean().default(isDevTest)
    ),
    synchronize: import_zod2.default.preprocess(
      coerceBoolean,
      import_zod2.default.boolean().default(isDevTest)
    )
  }),
  ai: import_zod2.default.object({
    apiKey: import_zod2.default.string().default(() => {
      if (isDevTest) {
        return "";
      }
      throw new Error(
        "You must provide an API key in production env!"
      );
    })
  })
}).readonly();
var config = schema.parse({
  env: env.NODE_ENV,
  port: env.PORT,
  isCi: env.CI,
  auth: {
    tokenKey: env.TOKEN_KEY,
    expiresIn: env.TOKEN_EXPIRES_IN,
    passwordCost: env.PASSWORD_COST
  },
  database: {
    type: env.DB_TYPE,
    host: env.DB_HOST,
    port: env.DB_PORT,
    database: env.DB_NAME,
    username: env.DB_USER,
    password: env.DB_PASSWORD,
    logging: env.DB_LOGGING,
    synchronize: env.DB_SYNC
  },
  ai: {
    apiKey: env.OPENAI_API_KEY
  }
});
var config_default = config;
function coerceBoolean(value2) {
  if (typeof value2 === "string") {
    return value2 === "true" || value2 === "1";
  }
  return void 0;
}

// src/modules/user/tokenPayload.ts
var import_zod3 = __toESM(require("zod"));
var tokenPayloadSchema = import_zod3.default.object({
  user: import_zod3.default.object({
    id: import_zod3.default.number()
  })
});
function prepareTokenPayload(user) {
  return tokenPayloadSchema.parse({ user });
}

// src/modules/user/login/schema.ts
var import_zod4 = require("zod");
var loginSchema = import_zod4.z.object({
  email: import_zod4.z.string().toLowerCase().trim().email().describe("User email"),
  password: import_zod4.z.coerce.string().trim().describe("User password")
});

// src/modules/user/login/index.ts
var { expiresIn, tokenKey } = config_default.auth;
var login_default = publicProcedure.meta({ description: "Endpoint dedicated for user login." }).input(loginSchema).query(async ({ input: { email, password }, ctx: { db } }) => {
  const user = await db.getRepository(User).findOne({
    select: { id: true, password: true },
    where: { email }
  });
  if (!user) {
    throw new import_server2.TRPCError({
      message: `User with email ${email} does not exist.`,
      code: "UNAUTHORIZED"
    });
  }
  const isMatch = await import_bcrypt.default.compare(password, user.password);
  if (!isMatch) {
    throw new import_server2.TRPCError({
      message: "Invalid password, please try again.",
      code: "UNAUTHORIZED"
    });
  }
  const payload = prepareTokenPayload(user);
  const token = import_jsonwebtoken.default.sign(payload, tokenKey, { expiresIn });
  return {
    id: user.id,
    token
  };
});

// src/modules/user/signup/index.ts
var import_bcrypt2 = __toESM(require("bcrypt"));
var import_server3 = require("@trpc/server");

// src/modules/user/signup/schema.ts
var import_zod5 = require("zod");
var signupSchema = import_zod5.z.object({
  email: import_zod5.z.string().toLowerCase().trim().email(),
  password: import_zod5.z.coerce.string().min(8).trim()
});

// src/modules/user/signup/index.ts
var signup_default = publicProcedure.input(signupSchema).mutation(async ({ input: { email, password }, ctx: { db } }) => {
  const hashedPassword = await import_bcrypt2.default.hash(password, 10);
  try {
    const user = await db.getRepository(User).save({ email, password: hashedPassword });
    return {
      id: user.id,
      email: user.email
    };
  } catch (error) {
    if (!(error instanceof Error)) {
      throw error;
    }
    if (error.message.includes("duplicate key")) {
      throw new import_server3.TRPCError({
        code: "BAD_REQUEST",
        message: `Email ${email} is already taken, please try another.`
      });
    }
    throw error;
  }
});

// src/modules/user/index.ts
var user_default = router({
  login: login_default,
  signup: signup_default
});

// src/trpc/authenticatedProcedure/index.ts
var import_jsonwebtoken2 = __toESM(require("jsonwebtoken"));

// src/trpc/authenticatedProcedure/buildAuthenticatedProcedure.ts
var import_zod8 = require("zod");
var import_server4 = require("@trpc/server");

// src/entities/user/schema.ts
var import_zod7 = require("zod");

// src/utils/validation.ts
var import_zod6 = require("zod");
function validates() {
  return {
    with: (schema2) => import_zod6.z.object(schema2)
  };
}

// src/entities/user/schema.ts
var userSchema = validates().with({
  id: import_zod7.z.number().int().positive(),
  email: import_zod7.z.string().trim().toLowerCase().email(),
  password: import_zod7.z.string().min(8).max(64)
});
var userInsertSchema = userSchema.omit({ id: true });
var authUserSchema = validates().with({
  id: import_zod7.z.number().int().positive()
});

// src/trpc/authenticatedProcedure/buildAuthenticatedProcedure.ts
var tokenSchema = import_zod8.z.object({
  user: authUserSchema
});
function buildAuthenticatedProcedure(verify) {
  function getUserFromToken(token) {
    try {
      const tokenVerified = verify(token);
      const tokenParsed = tokenSchema.parse(tokenVerified);
      return tokenParsed.user;
    } catch (error) {
      return null;
    }
  }
  return publicProcedure.use(({ ctx, next }) => {
    if (ctx.authUser) {
      return next({
        ctx: {
          authUser: ctx.authUser
        }
      });
    }
    if (!ctx.req) {
      throw new import_server4.TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Missing Express request object"
      });
    }
    const token = ctx.req.header("Authorization")?.replace("Bearer ", "");
    if (!token) {
      throw new import_server4.TRPCError({
        code: "UNAUTHORIZED",
        message: "Unauthenticated. Please log in."
      });
    }
    const authUser = getUserFromToken(token);
    if (!authUser) {
      throw new import_server4.TRPCError({
        code: "UNAUTHORIZED",
        message: "Invalid token."
      });
    }
    return next({
      ctx: {
        authUser
      }
    });
  });
}

// src/trpc/authenticatedProcedure/index.ts
var { tokenKey: tokenKey2 } = config_default.auth;
var verifyToken = (token) => import_jsonwebtoken2.default.verify(token, tokenKey2);
var authenticatedProcedure = buildAuthenticatedProcedure(verifyToken);

// src/modules/item/addItem/index.ts
var import_server5 = require("@trpc/server");

// src/entities/item/schema.ts
var import_zod9 = require("zod");
var itemSchema = validates().with({
  id: import_zod9.z.number().int().positive(),
  name: import_zod9.z.string().min(2, {
    message: "Item name must be at least 2 characters long."
  }).trim(),
  description: import_zod9.z.string().min(10, {
    message: "Item description must be at least 10 characters long."
  }).trim(),
  imageUrl: import_zod9.z.string().url(),
  price: import_zod9.z.number().int().positive(),
  width: import_zod9.z.number().positive(),
  length: import_zod9.z.number().positive(),
  x: import_zod9.z.number().positive(),
  y: import_zod9.z.number().positive()
});
var itemInsertSchema = itemSchema.omit({ id: true }).extend({
  roomId: import_zod9.z.number().int().positive()
});
var itemUpdateSchema = itemSchema.partial().required({ id: true });
var idSchema = itemSchema.pick({ id: true });
var itemCategoryUpdateSchema = idSchema.extend({
  categoryIds: import_zod9.z.array(import_zod9.z.number().int().positive())
});
var itemRoomUpdateSchema = idSchema.extend({
  roomId: import_zod9.z.number().int().positive()
});
var itemShopUpdateSchema = idSchema.extend({
  shopId: import_zod9.z.number().int().positive()
});
var updatePositionSchema = idSchema.extend({
  x: import_zod9.z.number().positive({ message: "Coordinate X must be positive." }),
  y: import_zod9.z.number().positive({ message: "Coordinate Y must be positive." })
});

// src/modules/item/addItem/index.ts
var addItem_default = authenticatedProcedure.input(itemInsertSchema).mutation(async ({ input: item, ctx: { db } }) => {
  const room = await db.getRepository(Room).findOneBy({ id: item.roomId });
  if (!room)
    throw new import_server5.TRPCError({
      code: "NOT_FOUND",
      message: `Room with ID ${item.roomId} does not exist.`
    });
  return db.getRepository(Item).save({
    ...item,
    room
  });
});

// src/modules/item/removeItem/index.ts
var import_server6 = require("@trpc/server");
var removeItem_default = authenticatedProcedure.input(idSchema).mutation(async ({ input: { id }, ctx: { db } }) => {
  const { affected } = await db.getRepository(Item).update({ id }, { room: null });
  if (affected === 0)
    throw new import_server6.TRPCError({
      code: "BAD_REQUEST",
      message: `Item with id ${id} does not exist.`
    });
  return {
    message: `Successfully remove ${affected} item from its room.`
  };
});

// src/modules/item/updatePosition/index.ts
var import_server7 = require("@trpc/server");
var updatePosition_default = publicProcedure.input(updatePositionSchema).mutation(async ({ input: { id, x, y }, ctx: { db } }) => {
  const found = await db.getRepository(Item).findOneBy({ id });
  if (!found)
    throw new import_server7.TRPCError({
      code: "NOT_FOUND",
      message: `Item with id ${id} does not exist.`
    });
  const item = await db.getRepository(Item).save({
    ...found,
    x,
    y
  });
  return {
    item
  };
});

// src/modules/item/updateCategory/index.ts
var import_server8 = require("@trpc/server");
var import_typeorm6 = require("typeorm");
var updateCategory_default = authenticatedProcedure.input(itemCategoryUpdateSchema).mutation(async ({ input: { id, categoryIds }, ctx: { db } }) => {
  const found = await db.getRepository(Item).findOneBy({ id });
  if (!found)
    throw new import_server8.TRPCError({
      code: "NOT_FOUND",
      message: `Item with id ${id} does not exist.`
    });
  const categories = await db.getRepository(Category).findBy({ id: (0, import_typeorm6.In)(categoryIds) });
  return db.getRepository(Item).save({
    ...found,
    categories: categories.filter((c) => c !== null)
  });
});

// src/modules/item/updateRoom/index.ts
var import_server9 = require("@trpc/server");
var updateRoom_default = authenticatedProcedure.input(itemRoomUpdateSchema).mutation(async ({ input: { id, roomId }, ctx: { db } }) => {
  const found = await db.getRepository(Item).findOneBy({ id });
  if (!found)
    throw new import_server9.TRPCError({
      code: "NOT_FOUND",
      message: `Item with id ${id} does not exist.`
    });
  const room = await db.getRepository(Room).findOneBy({ id: roomId });
  if (!room)
    throw new import_server9.TRPCError({
      code: "NOT_FOUND",
      message: `Room with id ${roomId} does not exist.`
    });
  return db.getRepository(Item).save({
    ...found,
    room
  });
});

// src/modules/item/removeCategories/index.ts
var import_server10 = require("@trpc/server");
var removeCategories_default = authenticatedProcedure.input(idSchema).mutation(async ({ input: { id }, ctx: { db } }) => {
  const itemFound = await db.getRepository(Item).findOneBy({ id });
  if (!itemFound) {
    throw new import_server10.TRPCError({
      code: "BAD_REQUEST",
      message: `Item with id ${id} does not exist.`
    });
  }
  return db.getRepository(Item).save({ ...itemFound, categories: [] });
});

// src/modules/item/removeRoom/index.ts
var import_server11 = require("@trpc/server");
var removeRoom_default = authenticatedProcedure.input(idSchema).mutation(async ({ input: { id }, ctx: { db } }) => {
  const itemFound = await db.getRepository(Item).findOneBy({ id });
  if (!itemFound)
    throw new import_server11.TRPCError({
      code: "NOT_FOUND",
      message: `Item with id ${id} does not exist.`
    });
  return db.getRepository(Item).save({ ...itemFound, room: null });
});

// src/modules/item/index.ts
var item_default = router({
  addItem: addItem_default,
  removeItem: removeItem_default,
  updatePosition: updatePosition_default,
  updateCategory: updateCategory_default,
  updateRoom: updateRoom_default,
  removeCategories: removeCategories_default,
  removeRoom: removeRoom_default
});

// src/entities/room/schema.ts
var import_zod10 = require("zod");
var roomSchema = validates().with({
  id: import_zod10.z.number().int().positive(),
  name: import_zod10.z.string().min(2, {
    message: "Room name must be at least 2 characters long."
  }),
  width: import_zod10.z.number().positive({ message: "Width cannot be 0 or a negative number. " }),
  length: import_zod10.z.number().positive({ message: "Length cannot be 0 or a negative number. " }),
  area: import_zod10.z.number().nonnegative()
});
var roomIdSchema = roomSchema.pick({ id: true });
var insertRoomSchema = roomSchema.omit({ id: true });
var updateRoomSchema = roomSchema.partial().required({ id: true });

// src/modules/room/deleteRoom/index.ts
var import_server12 = require("@trpc/server");
var deleteRoom_default = authenticatedProcedure.input(roomIdSchema).mutation(async ({ input: { id }, ctx: { db } }) => {
  const { affected } = await db.getRepository(Room).delete(id);
  if (affected === 0) {
    throw new import_server12.TRPCError({
      code: "NOT_FOUND",
      message: `Room with id ${id} not found.`
    });
  }
  return {
    message: `Room with ID ${id} deleted successfully.`
  };
});

// src/modules/room/createRoom/index.ts
var createRoom_default = authenticatedProcedure.input(insertRoomSchema).mutation(async ({ input: room, ctx: { db, authUser } }) => {
  const user = await db.getRepository(User).findOneBy({ id: authUser.id });
  const roomWithArea = {
    ...room,
    user,
    area: room.length * room.width
  };
  return db.getRepository(Room).save(roomWithArea);
});

// src/modules/room/updateRoom/index.ts
var import_server13 = require("@trpc/server");
var updateRoom_default2 = authenticatedProcedure.input(updateRoomSchema).mutation(async ({ input: room, ctx: { db } }) => {
  const { affected } = await db.getRepository(Room).update(room.id, room);
  if (affected === 0) {
    throw new import_server13.TRPCError({
      code: "NOT_FOUND",
      message: `Room with id ${room.id} not found.`
    });
  }
  return db.getRepository(Room).findOneByOrFail({ id: room.id });
});

// src/modules/room/loadRoom/index.ts
var loadRoom_default = authenticatedProcedure.input(roomIdSchema).query(
  async ({ input: { id }, ctx: { db } }) => db.getRepository(Room).findOne({ where: { id }, relations: { items: true } })
);

// src/modules/room/getRooms/index.ts
var getRooms_default = authenticatedProcedure.query(
  async ({ ctx: { db, authUser } }) => {
    const user = await db.getRepository(User).findOneBy({ id: authUser.id });
    return db.getRepository(Room).find({
      where: { user }
    });
  }
);

// src/modules/room/index.ts
var room_default = router({
  createRoom: createRoom_default,
  updateRoom: updateRoom_default2,
  deleteRoom: deleteRoom_default,
  getRooms: getRooms_default,
  loadRoom: loadRoom_default
});

// src/entities/message/schema.ts
var import_zod11 = require("zod");
var roomSchema2 = validates().with({
  id: import_zod11.z.number().int().positive(),
  role: import_zod11.z.string().min(1),
  content: import_zod11.z.string().min(1, { message: "Question must be at least 1 character long." })
});
var chatMessageSchema = roomSchema2.omit({ id: true }).extend({ user: import_zod11.z.object({ id: import_zod11.z.number().int().positive() }) });
var newMessageSchema = chatMessageSchema.omit({
  role: true,
  user: true
});

// src/modules/message/service/openai/index.ts
var import_server14 = require("@trpc/server");

// src/modules/message/service/openai/repository.ts
var repository_default = (db, authUser) => ({
  repository: db.getRepository(Message),
  async getHistory() {
    return await this.repository.find({
      where: { user: authUser },
      select: { role: true, content: true }
    });
  },
  async saveMessages(messages) {
    await this.repository.save(messages);
  }
});

// src/modules/message/service/openai/generator.ts
var generator_default = (ai2) => ({
  async generateResponse(history) {
    let response = null;
    try {
      response = await getAnswer(ai2, history);
    } catch (error) {
      console.log(error);
    }
    return response;
  }
});
async function getAnswer(ai2, messages) {
  const completion = await ai2.chat.completions.create({
    messages,
    model: "gpt-3.5-turbo"
  });
  return {
    role: "assistant",
    content: completion.choices[0].message.content
  };
}

// src/modules/message/service/openai/index.ts
var FIRST_MESSAGE = {
  role: "system",
  content: "You are a chatbot which is created with the sole purpose to help users with room interior design. Any question related to room interior design, you should answer. If the question is not related to room interior design, you should inform the user that you are not able to answer the question."
};
var openai_default = (db, authUser, ai2) => ({
  repository: repository_default(db, authUser),
  generator: generator_default(ai2),
  async run(content) {
    const newMessage = {
      role: "user",
      content
    };
    const history = await this.repository.getHistory();
    const isFirstMessage = history.length === 0;
    if (isFirstMessage) {
      history.push(FIRST_MESSAGE);
    }
    history.push(newMessage);
    const chatResponse = await this.generator.generateResponse(history);
    if (!chatResponse || !chatResponse?.content)
      throw new import_server14.TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "Something went wrong: assistant's response is empty."
      });
    const messagesToSave = [
      {
        user: authUser,
        ...newMessage
      },
      {
        user: authUser,
        ...chatResponse
      }
    ];
    await this.repository.saveMessages(
      isFirstMessage ? [{ ...FIRST_MESSAGE, user: authUser }, ...messagesToSave] : messagesToSave
    );
    return chatResponse.content;
  }
});

// src/modules/message/chat/index.ts
var chat_default = authenticatedProcedure.input(newMessageSchema).mutation(async ({ input: { content }, ctx: { db, authUser, ai: ai2 } }) => {
  const service = openai_default(db, authUser, ai2);
  const message = await service.run(content);
  return {
    message
  };
});

// src/modules/index.ts
var appRouter = router({
  user: user_default,
  item: item_default,
  room: room_default,
  chat: chat_default
});

// src/app.ts
function createApp(db, ai2) {
  const app = (0, import_express.default)();
  app.use((0, import_cors.default)());
  app.use(import_express.default.json());
  app.use("/health", (_, res) => {
    res.status(200).send("OK");
  });
  app.use("/ready", (_, res) => {
    res.status(200).send("OK");
  });
  app.use(
    "/panel",
    (_, res) => res.status(200).send(
      (0, import_trpc_panel.renderTrpcPanel)(appRouter, {
        url: "http://localhost:3000/v1/trpc",
        transformer: "superjson"
      })
    )
  );
  app.use(
    "/v1/trpc",
    (0, import_express2.createExpressMiddleware)({
      createContext: ({
        req,
        res
      }) => ({
        db,
        req,
        res,
        ai: ai2
      }),
      router: appRouter
    })
  );
  return app;
}

// src/database/index.ts
var import_path = require("path");
var import_typeorm7 = require("typeorm");
var import_typeorm_naming_strategies = require("typeorm-naming-strategies");
var import_pg_mem = __toESM(require_pg_mem());
function createDatabase(options = {}) {
  if (options.type === "pg-mem") {
    return createMemoryDatabase();
  }
  return new import_typeorm7.DataSource({
    entities: entities_exports,
    migrations: [relative("./migrations/**/*.ts")],
    namingStrategy: new import_typeorm_naming_strategies.SnakeNamingStrategy(),
    ...options
  });
}
function createMemoryDatabase() {
  const pgMemory = (0, import_pg_mem.newDb)();
  pgMemory.public.registerFunction({
    name: "current_database",
    implementation: () => "test"
  });
  pgMemory.public.registerFunction({
    name: "version",
    implementation: () => "1"
  });
  return pgMemory.adapters.createTypeormDataSource({
    type: "postgres",
    entities: entities_exports,
    synchronize: true,
    logging: false,
    namingStrategy: new import_typeorm_naming_strategies.SnakeNamingStrategy()
  });
}
function relative(...paths) {
  return (0, import_path.join)(__dirname, ...paths);
}

// src/modules/message/service/openai/config/open-ai.ts
var import_openai2 = __toESM(require("openai"));
function buildAi() {
  return new import_openai2.default({
    apiKey: config_default.ai.apiKey
  });
}

// src/index.ts
var database = createDatabase(config_default.database);
var ai = buildAi();
database.initialize().then(() => {
  const app = createApp(database, ai);
  app.listen(config_default.port, () => {
    console.log(`Server is running at http://localhost:${config_default.port}`);
  });
});
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=index.js.map